<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../CorsWorker.js":
/*!************************!*\
  !*** ../CorsWorker.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CorsWorker: () => (/* binding */ CorsWorker)
/* harmony export */ });
/*
Source: https://github.com/webpack/webpack/discussions/14648

Browsers do not support CORS for web workers (but they should?). This is a workaround to load a script from a different origin.
*/
class CorsWorker {
    constructor(url, options) {
        this.url = url;
        this.options = options;
        this.inited = false;
    }
    async init() {
        if (this.inited)
            return this;
        this.inited = true;
        try {
            const response = await fetch(this.url);
            if (!response.ok)
                throw new Error();
            const text = await response.text();
            const objectURL = URL.createObjectURL(new Blob([text], {
                type: "application/javascript",
            }));
            this._worker = new Worker(objectURL, { type: this.options?.type, name: this.options?.name });
        }
        catch (err) {
            throw new Error("Failed to create worker");
        }
        return this;
    }
    get worker() {
        if (!this._worker)
            throw new Error("CorsWorker did not start properly");
        return this._worker;
    }
}


/***/ }),

/***/ "../EventsHandler.js":
/*!***************************!*\
  !*** ../EventsHandler.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* binding */ Event),
/* harmony export */   EventsHandler: () => (/* binding */ EventsHandler)
/* harmony export */ });
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Event_defaultPrevented, _EventsHandler_listeners, _EventsHandler_globalListeners;
class Event {
    constructor(type, payload) {
        this.type = type;
        this.payload = payload;
        _Event_defaultPrevented.set(this, false);
    }
    preventDefault() {
        __classPrivateFieldSet(this, _Event_defaultPrevented, true, "f");
    }
    get defaultPrevented() {
        return __classPrivateFieldGet(this, _Event_defaultPrevented, "f");
    }
}
_Event_defaultPrevented = new WeakMap();
class EventsHandler {
    constructor() {
        _EventsHandler_listeners.set(this, new Map());
        _EventsHandler_globalListeners.set(this, new Set());
    }
    addEventListener(type, listener) {
        if (!type)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").add(listener);
        else {
            if (!__classPrivateFieldGet(this, _EventsHandler_listeners, "f").has(type))
                __classPrivateFieldGet(this, _EventsHandler_listeners, "f").set(type, new Set());
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.add(listener);
        }
        return listener;
    }
    removeEventListener(type, listener) {
        if (type === null)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").delete(listener);
        else
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.delete(listener);
    }
    emitEvent(type, payload) {
        const ev = new Event(type, payload);
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.forEach(listener => listener(ev));
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").forEach(listener => listener(ev));
        return ev;
    }
    clearListeners() {
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").clear();
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").clear();
    }
}
_EventsHandler_listeners = new WeakMap(), _EventsHandler_globalListeners = new WeakMap();


/***/ }),

/***/ "../Extension.js":
/*!***********************!*\
  !*** ../Extension.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension)
/* harmony export */ });
/* harmony import */ var _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CorsWorker.js */ "../CorsWorker.js");
/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Module.js */ "../Module.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared.js */ "../shared.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");




class Extension extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__.EventsHandler {
    constructor(provider, init) {
        super();
        this.provider = provider;
        this.init = init;
        this.url = "";
        this._pkg = {};
        this.started = false;
        /** `<path, { instances: <Module, data>, sharedState: any }>` */
        this.cache = new Map();
        this.logs = !!provider.options?.logs;
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        // load meta (package.json)
        const file = await this.loadFile("package.json");
        const text = await file.text();
        this._pkg = JSON.parse(text);
    }
    /** When the filter is empty no modules are returned */
    filterModules(filter) {
        const all = this.getAllModules();
        const idsSet = new Set(Array.isArray(filter.id) ? filter.id : [filter.id]);
        const notIdsSet = new Set(Array.isArray(filter.notId) ? filter.notId : [filter.notId]);
        const pathsSet = new Set(Array.isArray(filter.path) ? filter.path : [filter.path]);
        const notPathsSet = new Set(Array.isArray(filter.notPath) ? filter.notPath : [filter.notPath]);
        return all.filter(module => {
            let include = idsSet.has(module.id) || pathsSet.has(module.meta.path) || !!filter.check?.(module);
            if (include && notIdsSet.size && notIdsSet.has(module.id))
                include = false;
            if (include && notPathsSet.size && notPathsSet.has(module.meta.path))
                include = false;
            return include;
        });
    }
    getAllModules() {
        return Array.from(this.cache.values()).flatMap(({ instances }) => Array.from(instances.values()));
    }
    /**
     * @param path Use _null_ or empty string for the packages entry file
     */
    async launchModule(path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path || "");
        // IMP use correct npm version for the newest worker build (extensionrunner@version)
        const corsWorker = new _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__.CorsWorker(_shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr + "/npm/extensionrunner@1.0.33/worker.js", {
            type: "module",
            name: `${this.init.name}:${path}`,
        });
        await corsWorker.init();
        const mod = this.initModule(corsWorker.worker, _shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr, path, out, options || {});
        return mod.start();
    }
    async launchComponent(parentElement, path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path);
        // Most CDNs do not directly serve html files, they serve the html as a string in a response. So does jsdelivr and unpkg.
        // So we fetch the html and use ifrm.srcdoc to load the html
        const iframe = document.createElement("iframe");
        let url;
        let origin;
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            origin = "https://raw.githack.com";
            url = `${origin}/${owner}/${repo}/${this.init.version}/${path}`;
        }
        else if (this.type === "npm") {
            // TODO see Info.md CDNs
            origin = "https://unpkg.com";
            url = `${origin}/${this.init.name}@${this.init.version}/${path}`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        iframe.src = url;
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
        // TODOD more attrs?
        // wait for load
        return new Promise((resolve, reject) => {
            iframe.onload = async (e) => {
                if (!iframe.contentWindow)
                    return reject("`contentWindow`ndow not defined");
                const mod = this.initModule(iframe.contentWindow, origin, path, out, options || {});
                resolve(mod.start());
            };
            iframe.addEventListener("error", e => {
                reject(new Error(e.message));
            });
            parentElement.appendChild(iframe);
        });
    }
    initModule(target, origin, path, out, options) {
        // create meta
        let meta = {
            authToken: (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.randomId)(),
            name: this.init.name,
            path,
            initialState: this.cache.get(path)?.state,
            version: this.init.version,
            type: this.init.type,
        };
        meta = this.init.meta ? this.init.meta(meta) : meta;
        if (options.meta)
            meta = options.meta(meta);
        if (options.initialState !== undefined)
            meta.initialState = options.initialState;
        // create module
        const populateState = options.allowPopulateState ?? false;
        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_1__.Module(this, {
            origin,
            target,
            meta: meta,
            out,
            operationTimeout: this.init.operationTimeout,
            connectionTimeout: this.init.connectionTimeout,
            allowPopulateState: typeof populateState === "boolean"
                ? populateState
                : (newState, merge) => populateState(newState, merge, mod),
        });
        // propagate events
        mod.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        mod.addEventListener("state_populate", async (ev) => {
            // The new state gets pushed back to modules with the same path or just to the module
            // itself, base on populate option
            const populate = ev.payload.options?.populate !== false;
            if (populate) {
                if (this.cache.has(path))
                    this.cache.get(path).state = ev.payload;
                else
                    this.cache.set(path, { instances: new Map(), state: ev.payload });
            }
            const pushResults = await this.pushState(ev.payload.state, {
                filter: populate ? { path: mod.meta.path } : { id: mod.id },
                merge: !!ev.payload.options?.merge,
            });
            this.emitEvent("state_populate", {
                module: mod,
                state: ev.payload.state,
                options: ev.payload.options,
                result: pushResults,
            });
        });
        mod.addEventListener("destroy", () => {
            this.cache.get(path)?.instances.delete(mod.id);
            this.emitEvent("module_destroy", mod);
        });
        mod.addEventListener("error", ev => {
            this.emitEvent("error", { error: ev.payload, origin: mod });
        });
        // cache
        let instances = this.cache.get(path)?.instances;
        if (!instances) {
            instances = new Map();
            this.cache.set(path, { instances, state: undefined });
        }
        instances.set(mod.id, mod);
        this.emitEvent("module_load", mod);
        return mod;
    }
    get id() {
        return this.init.type + "%" + this.init.name;
    }
    get pkg() {
        return this._pkg;
    }
    get type() {
        return this.init.type;
    }
    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */
    async loadFile(path) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.loadFile)(this.init.type, this.init.name, this.init.version, path);
    }
    async pushState(newState, options) {
        return await this.forEachModule(module => {
            module.pushState(newState, { merge: options?.merge !== false });
        }, {
            parallel: true,
        });
    }
    async forEachModule(callback, options) {
        const result = { failed: [], affected: [], result: [], errors: [] };
        const modules = options?.filter ? this.filterModules(options.filter) : this.getAllModules();
        if (options?.parallel) {
            const par = await Promise.all(modules.map(async (module) => {
                try {
                    return { error: null, result: await callback(module), module };
                }
                catch (err) {
                    return { error: err, result: undefined, module };
                }
            }));
            par.forEach(p => {
                if (p.error) {
                    result.failed.push(p.module);
                    result.errors.push(p.error);
                }
                else {
                    result.affected.push(p.module);
                    result.result.push(p.result);
                }
            });
        }
        else {
            for (const module of modules) {
                try {
                    result.result.push(await callback(module));
                    result.affected.push(module);
                }
                catch (err) {
                    result.failed.push(module);
                    result.errors.push(err);
                }
            }
        }
        return result;
    }
    async destroy() {
        const actions = await this.forEachModule(module => module.destroy(), { parallel: true });
        this.cache.clear();
        this.clearListeners();
        this.emitEvent("destroy", undefined);
        return actions;
    }
    err(info, event) {
        const msg = event instanceof Event
            ? (event.message || event.data || "").toString()
            : event instanceof Error
                ? event.message
                : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        if (this.logs)
            console.error(info, err);
        this.emitEvent("error", err);
        return err;
    }
}


/***/ }),

/***/ "../Module.js":
/*!********************!*\
  !*** ../Module.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "../shared.js");


/** Represents an iframe or a worker */
class Module extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(extension, init) {
        super();
        this.extension = extension;
        this.init = init;
        this.id = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.randomId)();
        this.started = false;
        this.logs = !!this.extension.provider.options?.logs;
    }
    async start() {
        if (this.started)
            return this;
        this.started = true;
        return new Promise((resolve, reject) => {
            // In CORS context target is Window (iframe.contentWindow)
            // We cant define target.onmessage or target.onerror on a cross origin Window
            // Thats why we listen to the message event on the global object and check the source
            let resolved = false;
            const messagesListener = async (e) => {
                // origin = "" -> same origin
                if (e.origin !== "" && e.origin !== this.init.origin)
                    return;
                if (e.data?.__token !== this.meta.authToken)
                    return;
                if (typeof e?.data?.__type !== "string")
                    return;
                const type = e.data.__type;
                switch (type) {
                    case "state_populate":
                        let receivedState = e.data.state;
                        if (!receivedState || typeof receivedState !== "object")
                            return this.err("Invalid state received", e);
                        const options = e.data.options || {};
                        let newState;
                        if (this.init.allowPopulateState) {
                            const merge = !!options.merge;
                            const allowed = this.init.allowPopulateState === true ||
                                this.init.allowPopulateState?.(receivedState, merge);
                            if (!allowed)
                                return;
                            // state allowed but modified
                            if (typeof allowed === "object")
                                receivedState = allowed;
                            else
                                newState = receivedState;
                        }
                        else {
                            return;
                        }
                        this.emitEvent("state_populate", {
                            state: newState,
                            options,
                        });
                        break;
                    case "operation":
                        const { args, operation, __port: port } = e.data;
                        if (!port)
                            return this.err("Operation Channel Error", "Port not found");
                        let op = await this.init.out?.[operation];
                        if (typeof op !== "function")
                            op = null;
                        port.onmessageerror = e => {
                            this.err("Operation Channel Error", e);
                        };
                        if (op) {
                            try {
                                const result = await op.apply(this, args);
                                port.postMessage({
                                    __type: "operation:result",
                                    payload: result,
                                });
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result,
                                    error: null,
                                });
                            }
                            catch (err) {
                                const e = this.err("Operation Execution Error", err);
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result: undefined,
                                    error: e,
                                });
                                return;
                            }
                        }
                        else {
                            this.emitEvent(`op:${operation}`, {
                                args,
                                result: undefined,
                                error: null,
                            });
                        }
                        break;
                    case "ready":
                        if (!resolved)
                            resolve(this);
                        this.emitEvent("load", undefined);
                        resolved = true;
                        break;
                }
            };
            /*
             worker messages are only received via Worker.onmessage,
             whereas iframe messages are received via window.onmessage or iframe.contentWindow.onmessage.
             So we need to handle workers and iframes differently
            */
            // Worker
            if (this.init.target instanceof Worker) {
                if (this.logs)
                    console.log("Listening on worker for messages");
                this.init.target.addEventListener("message", messagesListener);
            }
            // IFrame
            else {
                if (this.logs)
                    console.log("Listening on window for messages");
                window.addEventListener("message", messagesListener);
            }
            // Post meta:
            // - Workers need this to import the module in the worker initialization, whoich dynamically imports the module
            // - Iframes need this to init their meta
            this.init.target.postMessage({ __type: "meta", meta: this.init.meta }, { targetOrigin: this.init.origin });
            setTimeout(() => {
                if (!resolved)
                    reject(this.err("Connection timeout", null));
            }, this.init.connectionTimeout || 5000);
        });
    }
    get state() {
        return this._state;
    }
    get meta() {
        return this.init.meta;
    }
    err(info, event) {
        const msg = event instanceof Event
            ? (event.message || event.data || "").toString()
            : event instanceof Error
                ? event.message
                : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        if (this.logs)
            console.error(info, err);
        this.emitEvent("error", err);
        return err;
    }
    postMessage(type, data, transfer) {
        this.init.target.postMessage({ ...data, __type: type }, { transfer, targetOrigin: this.init.origin });
    }
    async execute(operation, ...args) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.receiveData)(this.init.target, "operation", { args, operation }, this.init.origin, [], this.init.operationTimeout);
    }
    async pushState(newState, options) {
        let s;
        if (options?.merge !== false) {
            if (this.init.mergeStates) {
                s = this.init.mergeStates(this.state, newState);
            }
            else {
                s = { ...this.state, ...newState };
            }
        }
        else
            s = newState;
        await this.postMessage("state_push", {
            state: s,
        });
        // Set state for this module (push state success)
        // Set state only here, so the state in the module is the same as here (the provider)
        this._state = s;
        // return a complete state here
        //  as the state in modules is overwritten in the adapter with the pushed state
        return s;
    }
    destroy() {
        if (this.init.target instanceof Worker) {
            try {
                this.init.target.terminate();
            }
            catch (err) { }
        }
        this.clearListeners();
        this.emitEvent("destroy", undefined);
    }
}


/***/ }),

/***/ "../Provider.js":
/*!**********************!*\
  !*** ../Provider.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");


class Provider extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(options) {
        super();
        this.options = options;
        this.cache = new Map();
    }
    async loadExtension(extensionInit) {
        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_1__.Extension(this, extensionInit);
        try {
            await extension.start();
        }
        catch (err) {
            throw new Error(`Failed to load extension: ${err?.toString()}`);
        }
        // propagate events
        extension.addEventListener("state_populate", e => {
            this.emitEvent("state_populate", { extension, module: e.payload.module, state: e.payload.state, options: e.payload.module });
        });
        extension.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        extension.addEventListener("destroy", e => {
            this.cache.delete(extension.id);
            this.emitEvent("extension_destroy", extension);
        });
        this.emitEvent("extension_load", extension);
        // cache
        this.cache.set(extension.id, extension);
        return extension;
    }
    allExtensions() {
        return Array.from(this.cache.values());
    }
    getExtension(id) {
        return this.cache.get(id) || null;
    }
    destroy() {
        const extensions = Array.from(this.cache.values());
        extensions.forEach(extension => extension.destroy());
        this.cache.clear();
    }
}


/***/ }),

/***/ "../index.js":
/*!*******************!*\
  !*** ../index.js ***!
  \*******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* reexport safe */ _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__.Event),
/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");
/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ "../Provider.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);


/***/ }),

/***/ "../shared.js":
/*!********************!*\
  !*** ../shared.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMessageData: () => (/* binding */ getMessageData),
/* harmony export */   getUrl: () => (/* binding */ getUrl),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   jsdelivr: () => (/* binding */ jsdelivr),
/* harmony export */   loadFile: () => (/* binding */ loadFile),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   receiveData: () => (/* binding */ receiveData),
/* harmony export */   relPath: () => (/* binding */ relPath)
/* harmony export */ });
function relPath(path) {
    if (path.startsWith("./"))
        path = path.slice(2);
    else if (path.startsWith("/"))
        path = path.slice(1);
    return path;
}
function getMessageData(e, type) {
    if (e.data && typeof e.data === "object" && e.data.__type === type)
        return e.data;
    return null;
}
/** 25 char long pseudo cryptic id */
function randomId() {
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let uniqueId = "";
    for (let i = 0; i < 25; i++) {
        const randomIndex = Math.floor(Math.random() * chars.length);
        uniqueId += chars[randomIndex];
    }
    return uniqueId;
}
const isBrowser = typeof window !== "undefined" && window === window.self;
async function receiveData(target, type, data, origin = "*", transfer, errTimeout = 5000) {
    return new Promise((resolve, reject) => {
        const channel = new MessageChannel();
        const out = channel.port1;
        const _in = channel.port2;
        let resolved = false;
        setTimeout(() => {
            if (!resolved)
                reject(new Error("Operation timeout"));
        }, errTimeout || 5000);
        out.onmessage = async (e) => {
            const data = getMessageData(e, type + ":result");
            if (data) {
                resolved = true;
                resolve(data.payload);
            }
        };
        _in.onmessageerror = e => {
            reject(new Error("Channel Error (in)"));
        };
        out.onmessageerror = e => {
            reject(new Error("Channel Error (out)"));
        };
        target.postMessage({ ...data, __type: type, __port: _in }, { targetOrigin: origin, transfer: [_in, ...(transfer || [])] });
    });
}
const jsdelivr = "https://cdn.jsdelivr.net";
function getUrl(type, name, version, path) {
    let baseUrl;
    if (type === "github") {
        const [owner, repo] = name.split("/");
        baseUrl = `${jsdelivr}/gh/${owner}/${repo}@${version}/`;
    }
    else if (type === "npm") {
        baseUrl = `${jsdelivr}/npm/${name}@${version}/`;
    }
    else
        throw new Error("Invalid type ('npm' or 'github' expected)");
    if (path) {
        path = relPath(path);
        return baseUrl + path;
    }
    else
        return baseUrl;
}
async function loadFile(type, name, version, path) {
    if (path.startsWith("/"))
        path = path.slice(1);
    else if (path.startsWith("./"))
        path = path.slice(2);
    const response = await fetch(getUrl(type, name, version, path), type === "github" ? {} : {});
    if (!response.ok) {
        const error = new Error(`Failed to load file: ${response.statusText}`);
        error.response = response;
        throw new Error(`Failed to load file: ${response.statusText}`);
    }
    return response;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ "../index.js");

const commitSha = "e1b2eb07b6009931c9e8455c3461a3ca2ef0ac1f";
main().catch(err => console.error(err));
const providerApi = {
    echo: text => {
        text = text || "";
        return text + "  " + text + "  " + text;
    },
    alert: message => {
        alert(message || "<empty>");
    },
    print: (...text) => {
        const container = document.getElementById("print");
        if (container)
            console.log("Print:", (text || ["<empty>"]).join(" "));
    },
    greet: (name, age) => {
        alert("Hello " + name + " AGE " + age);
    },
};
async function launchIFrames(extension) {
    const container = document.getElementById("iframe");
    const container2 = document.getElementById("iframe2");
    const resetBtn = document.getElementById("reset");
    if (container && container2 && resetBtn) {
        const componentModule = await extension.launchComponent(container, "dist/frames/counter/counter.html", providerApi, { allowPopulateState: true });
        const componentModule2 = await extension.launchComponent(container2, "dist/frames/counter/counter.html", providerApi, { allowPopulateState: true });
        setInterval(async () => {
            const newCounter = await componentModule.execute("increment");
            await componentModule2.execute("increment");
            console.log(`New counter <${newCounter}> returned by 'increment' execute (Should also be displayed in the iframe)`);
        }, 3000);
        resetBtn.onclick = () => {
            componentModule.execute("reset");
            componentModule.execute("print", "Resetted", "from", "main window");
        };
    }
}
async function launchModule(extension) {
    const module = await extension.launchModule("dist/math.js", providerApi);
    console.log("Module loaded:", extension);
    const operationBtn = document.getElementById("operation");
    if (operationBtn) {
        operationBtn.onclick = async () => {
            if (!module)
                return alert("Module not loaded");
            const sum = await module.execute("add", 1, 5);
            const d = await module.execute("substract", 10, 2);
            alert("Sum: " + sum + " Sub: " + d);
        };
    }
}
async function main() {
    addEventListener("message", e => {
        console.log("Message received ::", e.data);
    });
    const prov = new _index__WEBPACK_IMPORTED_MODULE_0__["default"]({ logs: true });
    const extension = await prov.loadExtension({
        type: "github",
        name: "andre-hctulc/extensionrunner-test-extension",
        version: commitSha,
    });
    console.log("Extension loaded:", extension);
    const info = document.getElementById("info");
    if (info)
        info.innerHTML = `${extension.pkg.name}@${extension.pkg.version} SHA ${commitSha}`;
    launchModule(extension).catch(err => console.error("Error launching module", err));
    launchIFrames(extension).catch(err => console.error("Error launching iframe", err));
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QW9CO0FBQzVFO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7Ozs7Ozs7VUNoRkE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7OztBQ05tQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCwwQkFBMEI7QUFDeEosZ0lBQWdJLDBCQUEwQjtBQUMxSjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsOENBQVEsR0FBRyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUIsR0FBRyx1QkFBdUIsTUFBTSxVQUFVO0FBQ3pGO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3QvLi4vQ29yc1dvcmtlci5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL0V2ZW50c0hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uLi9FeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vdGVzdC8uLi9Nb2R1bGUuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uLi9Qcm92aWRlci5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL2luZGV4LmpzIiwid2VicGFjazovL3Rlc3QvLi4vc2hhcmVkLmpzIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly90ZXN0Ly4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Tb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svZGlzY3Vzc2lvbnMvMTQ2NDhcblxuQnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgQ09SUyBmb3Igd2ViIHdvcmtlcnMgKGJ1dCB0aGV5IHNob3VsZD8pLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCB0byBsb2FkIGEgc2NyaXB0IGZyb20gYSBkaWZmZXJlbnQgb3JpZ2luLlxuKi9cbmV4cG9ydCBjbGFzcyBDb3JzV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLmluaXRlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMudXJsKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0VVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbdGV4dF0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtlciA9IG5ldyBXb3JrZXIob2JqZWN0VVJMLCB7IHR5cGU6IHRoaXMub3B0aW9ucz8udHlwZSwgbmFtZTogdGhpcy5vcHRpb25zPy5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgd29ya2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgd29ya2VyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3dvcmtlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnNXb3JrZXIgZGlkIG5vdCBzdGFydCBwcm9wZXJseVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtlcjtcbiAgICB9XG59XG4iLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzO1xuZXhwb3J0IGNsYXNzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIF9FdmVudF9kZWZhdWx0UHJldmVudGVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgfVxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FdmVudF9kZWZhdWx0UHJldmVudGVkLCB0cnVlLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBkZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRfZGVmYXVsdFByZXZlbnRlZCwgXCJmXCIpO1xuICAgIH1cbn1cbl9FdmVudF9kZWZhdWx0UHJldmVudGVkID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBjbGFzcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgICAgICBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMuc2V0KHRoaXMsIG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMsIFwiZlwiKS5hZGQobGlzdGVuZXIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIFwiZlwiKS5oYXModHlwZSkpXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIFwiZlwiKS5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuZ2V0KHR5cGUpPy5hZGQobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodHlwZSA9PT0gbnVsbClcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzLCBcImZcIikuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIFwiZlwiKS5nZXQodHlwZSk/LmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIGVtaXRFdmVudCh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGV2ID0gbmV3IEV2ZW50KHR5cGUsIHBheWxvYWQpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihldikpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycywgXCJmXCIpLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZXYpKTtcbiAgICAgICAgcmV0dXJuIGV2O1xuICAgIH1cbiAgICBjbGVhckxpc3RlbmVycygpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMsIFwiZlwiKS5jbGVhcigpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLmNsZWFyKCk7XG4gICAgfVxufVxuX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKSwgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbiIsImltcG9ydCB7IENvcnNXb3JrZXIgfSBmcm9tIFwiLi9Db3JzV29ya2VyLmpzXCI7XG5pbXBvcnQgeyBNb2R1bGUgfSBmcm9tIFwiLi9Nb2R1bGUuanNcIjtcbmltcG9ydCB7IGpzZGVsaXZyLCBsb2FkRmlsZSwgcmFuZG9tSWQsIHJlbFBhdGggfSBmcm9tIFwiLi9zaGFyZWQuanNcIjtcbmltcG9ydCB7IEV2ZW50c0hhbmRsZXIgfSBmcm9tIFwiLi9FdmVudHNIYW5kbGVyLmpzXCI7XG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uIGV4dGVuZHMgRXZlbnRzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGluaXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICB0aGlzLnVybCA9IFwiXCI7XG4gICAgICAgIHRoaXMuX3BrZyA9IHt9O1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIGA8cGF0aCwgeyBpbnN0YW5jZXM6IDxNb2R1bGUsIGRhdGE+LCBzaGFyZWRTdGF0ZTogYW55IH0+YCAqL1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxvZ3MgPSAhIXByb3ZpZGVyLm9wdGlvbnM/LmxvZ3M7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBsb2FkIG1ldGEgKHBhY2thZ2UuanNvbilcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMubG9hZEZpbGUoXCJwYWNrYWdlLmpzb25cIik7XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBmaWxlLnRleHQoKTtcbiAgICAgICAgdGhpcy5fcGtnID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gICAgLyoqIFdoZW4gdGhlIGZpbHRlciBpcyBlbXB0eSBubyBtb2R1bGVzIGFyZSByZXR1cm5lZCAqL1xuICAgIGZpbHRlck1vZHVsZXMoZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IGFsbCA9IHRoaXMuZ2V0QWxsTW9kdWxlcygpO1xuICAgICAgICBjb25zdCBpZHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLmlkKSA/IGZpbHRlci5pZCA6IFtmaWx0ZXIuaWRdKTtcbiAgICAgICAgY29uc3Qgbm90SWRzU2V0ID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZpbHRlci5ub3RJZCkgPyBmaWx0ZXIubm90SWQgOiBbZmlsdGVyLm5vdElkXSk7XG4gICAgICAgIGNvbnN0IHBhdGhzU2V0ID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZpbHRlci5wYXRoKSA/IGZpbHRlci5wYXRoIDogW2ZpbHRlci5wYXRoXSk7XG4gICAgICAgIGNvbnN0IG5vdFBhdGhzU2V0ID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZpbHRlci5ub3RQYXRoKSA/IGZpbHRlci5ub3RQYXRoIDogW2ZpbHRlci5ub3RQYXRoXSk7XG4gICAgICAgIHJldHVybiBhbGwuZmlsdGVyKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5jbHVkZSA9IGlkc1NldC5oYXMobW9kdWxlLmlkKSB8fCBwYXRoc1NldC5oYXMobW9kdWxlLm1ldGEucGF0aCkgfHwgISFmaWx0ZXIuY2hlY2s/Lihtb2R1bGUpO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGUgJiYgbm90SWRzU2V0LnNpemUgJiYgbm90SWRzU2V0Lmhhcyhtb2R1bGUuaWQpKVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlICYmIG5vdFBhdGhzU2V0LnNpemUgJiYgbm90UGF0aHNTZXQuaGFzKG1vZHVsZS5tZXRhLnBhdGgpKVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWxsTW9kdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jYWNoZS52YWx1ZXMoKSkuZmxhdE1hcCgoeyBpbnN0YW5jZXMgfSkgPT4gQXJyYXkuZnJvbShpbnN0YW5jZXMudmFsdWVzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhdGggVXNlIF9udWxsXyBvciBlbXB0eSBzdHJpbmcgZm9yIHRoZSBwYWNrYWdlcyBlbnRyeSBmaWxlXG4gICAgICovXG4gICAgYXN5bmMgbGF1bmNoTW9kdWxlKHBhdGgsIG91dCwgb3B0aW9ucykge1xuICAgICAgICBwYXRoID0gcmVsUGF0aChwYXRoIHx8IFwiXCIpO1xuICAgICAgICAvLyBJTVAgdXNlIGNvcnJlY3QgbnBtIHZlcnNpb24gZm9yIHRoZSBuZXdlc3Qgd29ya2VyIGJ1aWxkIChleHRlbnNpb25ydW5uZXJAdmVyc2lvbilcbiAgICAgICAgY29uc3QgY29yc1dvcmtlciA9IG5ldyBDb3JzV29ya2VyKGpzZGVsaXZyICsgXCIvbnBtL2V4dGVuc2lvbnJ1bm5lckAxLjAuMzMvd29ya2VyLmpzXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmluaXQubmFtZX06JHtwYXRofWAsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBjb3JzV29ya2VyLmluaXQoKTtcbiAgICAgICAgY29uc3QgbW9kID0gdGhpcy5pbml0TW9kdWxlKGNvcnNXb3JrZXIud29ya2VyLCBqc2RlbGl2ciwgcGF0aCwgb3V0LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgcmV0dXJuIG1vZC5zdGFydCgpO1xuICAgIH1cbiAgICBhc3luYyBsYXVuY2hDb21wb25lbnQocGFyZW50RWxlbWVudCwgcGF0aCwgb3V0LCBvcHRpb25zKSB7XG4gICAgICAgIHBhdGggPSByZWxQYXRoKHBhdGgpO1xuICAgICAgICAvLyBNb3N0IENETnMgZG8gbm90IGRpcmVjdGx5IHNlcnZlIGh0bWwgZmlsZXMsIHRoZXkgc2VydmUgdGhlIGh0bWwgYXMgYSBzdHJpbmcgaW4gYSByZXNwb25zZS4gU28gZG9lcyBqc2RlbGl2ciBhbmQgdW5wa2cuXG4gICAgICAgIC8vIFNvIHdlIGZldGNoIHRoZSBodG1sIGFuZCB1c2UgaWZybS5zcmNkb2MgdG8gbG9hZCB0aGUgaHRtbFxuICAgICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBsZXQgb3JpZ2luO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImdpdGh1YlwiKSB7XG4gICAgICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gdGhpcy5pbml0Lm5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgb3JpZ2luID0gXCJodHRwczovL3Jhdy5naXRoYWNrLmNvbVwiO1xuICAgICAgICAgICAgdXJsID0gYCR7b3JpZ2lufS8ke293bmVyfS8ke3JlcG99LyR7dGhpcy5pbml0LnZlcnNpb259LyR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJucG1cIikge1xuICAgICAgICAgICAgLy8gVE9ETyBzZWUgSW5mby5tZCBDRE5zXG4gICAgICAgICAgICBvcmlnaW4gPSBcImh0dHBzOi8vdW5wa2cuY29tXCI7XG4gICAgICAgICAgICB1cmwgPSBgJHtvcmlnaW59LyR7dGhpcy5pbml0Lm5hbWV9QCR7dGhpcy5pbml0LnZlcnNpb259LyR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSAoJ25wbScgb3IgJ2dpdGh1YicgZXhwZWN0ZWQpXCIpO1xuICAgICAgICBpZnJhbWUuc3JjID0gdXJsO1xuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwic2FuZGJveFwiLCBcImFsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW5cIik7XG4gICAgICAgIC8vIFRPRE9EIG1vcmUgYXR0cnM/XG4gICAgICAgIC8vIHdhaXQgZm9yIGxvYWRcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmcmFtZS5vbmxvYWQgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoXCJgY29udGVudFdpbmRvd2BuZG93IG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZCA9IHRoaXMuaW5pdE1vZHVsZShpZnJhbWUuY29udGVudFdpbmRvdywgb3JpZ2luLCBwYXRoLCBvdXQsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kLnN0YXJ0KCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdE1vZHVsZSh0YXJnZXQsIG9yaWdpbiwgcGF0aCwgb3V0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBtZXRhXG4gICAgICAgIGxldCBtZXRhID0ge1xuICAgICAgICAgICAgYXV0aFRva2VuOiByYW5kb21JZCgpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5pbml0Lm5hbWUsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgaW5pdGlhbFN0YXRlOiB0aGlzLmNhY2hlLmdldChwYXRoKT8uc3RhdGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmluaXQudmVyc2lvbixcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuaW5pdC50eXBlLFxuICAgICAgICB9O1xuICAgICAgICBtZXRhID0gdGhpcy5pbml0Lm1ldGEgPyB0aGlzLmluaXQubWV0YShtZXRhKSA6IG1ldGE7XG4gICAgICAgIGlmIChvcHRpb25zLm1ldGEpXG4gICAgICAgICAgICBtZXRhID0gb3B0aW9ucy5tZXRhKG1ldGEpO1xuICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG1ldGEuaW5pdGlhbFN0YXRlID0gb3B0aW9ucy5pbml0aWFsU3RhdGU7XG4gICAgICAgIC8vIGNyZWF0ZSBtb2R1bGVcbiAgICAgICAgY29uc3QgcG9wdWxhdGVTdGF0ZSA9IG9wdGlvbnMuYWxsb3dQb3B1bGF0ZVN0YXRlID8/IGZhbHNlO1xuICAgICAgICBjb25zdCBtb2QgPSBuZXcgTW9kdWxlKHRoaXMsIHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgICAgICBvdXQsXG4gICAgICAgICAgICBvcGVyYXRpb25UaW1lb3V0OiB0aGlzLmluaXQub3BlcmF0aW9uVGltZW91dCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiB0aGlzLmluaXQuY29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgICAgICBhbGxvd1BvcHVsYXRlU3RhdGU6IHR5cGVvZiBwb3B1bGF0ZVN0YXRlID09PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgID8gcG9wdWxhdGVTdGF0ZVxuICAgICAgICAgICAgICAgIDogKG5ld1N0YXRlLCBtZXJnZSkgPT4gcG9wdWxhdGVTdGF0ZShuZXdTdGF0ZSwgbWVyZ2UsIG1vZCksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwcm9wYWdhdGUgZXZlbnRzXG4gICAgICAgIG1vZC5hZGRFdmVudExpc3RlbmVyKG51bGwsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmIChldi50eXBlLnN0YXJ0c1dpdGgoXCJvcDpcIikpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZXYudHlwZSwgZXYucGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb2QuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlX3BvcHVsYXRlXCIsIGFzeW5jIChldikgPT4ge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBzdGF0ZSBnZXRzIHB1c2hlZCBiYWNrIHRvIG1vZHVsZXMgd2l0aCB0aGUgc2FtZSBwYXRoIG9yIGp1c3QgdG8gdGhlIG1vZHVsZVxuICAgICAgICAgICAgLy8gaXRzZWxmLCBiYXNlIG9uIHBvcHVsYXRlIG9wdGlvblxuICAgICAgICAgICAgY29uc3QgcG9wdWxhdGUgPSBldi5wYXlsb2FkLm9wdGlvbnM/LnBvcHVsYXRlICE9PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwb3B1bGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhwYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5nZXQocGF0aCkuc3RhdGUgPSBldi5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgeyBpbnN0YW5jZXM6IG5ldyBNYXAoKSwgc3RhdGU6IGV2LnBheWxvYWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwdXNoUmVzdWx0cyA9IGF3YWl0IHRoaXMucHVzaFN0YXRlKGV2LnBheWxvYWQuc3RhdGUsIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHBvcHVsYXRlID8geyBwYXRoOiBtb2QubWV0YS5wYXRoIH0gOiB7IGlkOiBtb2QuaWQgfSxcbiAgICAgICAgICAgICAgICBtZXJnZTogISFldi5wYXlsb2FkLm9wdGlvbnM/Lm1lcmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcInN0YXRlX3BvcHVsYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogZXYucGF5bG9hZC5zdGF0ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBldi5wYXlsb2FkLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBwdXNoUmVzdWx0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kLmFkZEV2ZW50TGlzdGVuZXIoXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZ2V0KHBhdGgpPy5pbnN0YW5jZXMuZGVsZXRlKG1vZC5pZCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcIm1vZHVsZV9kZXN0cm95XCIsIG1vZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb2QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGV2ID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiZXJyb3JcIiwgeyBlcnJvcjogZXYucGF5bG9hZCwgb3JpZ2luOiBtb2QgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjYWNoZVxuICAgICAgICBsZXQgaW5zdGFuY2VzID0gdGhpcy5jYWNoZS5nZXQocGF0aCk/Lmluc3RhbmNlcztcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KHBhdGgsIHsgaW5zdGFuY2VzLCBzdGF0ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlcy5zZXQobW9kLmlkLCBtb2QpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm1vZHVsZV9sb2FkXCIsIG1vZCk7XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC50eXBlICsgXCIlXCIgKyB0aGlzLmluaXQubmFtZTtcbiAgICB9XG4gICAgZ2V0IHBrZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BrZztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQudHlwZTtcbiAgICB9XG4gICAgLyoqIElmIHRoZSByZXNwb25zZSBpcyBub3Qgb2ssIHRoZSBgUmVzcG9uc2VgIHdpbGwgYmUgc2V0IG9uIHRoZSB0aHJvd24gZXJyb3IgKGBFcnJvci5yZXNwb25zZWApICovXG4gICAgYXN5bmMgbG9hZEZpbGUocGF0aCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgbG9hZEZpbGUodGhpcy5pbml0LnR5cGUsIHRoaXMuaW5pdC5uYW1lLCB0aGlzLmluaXQudmVyc2lvbiwgcGF0aCk7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hTdGF0ZShuZXdTdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mb3JFYWNoTW9kdWxlKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBtb2R1bGUucHVzaFN0YXRlKG5ld1N0YXRlLCB7IG1lcmdlOiBvcHRpb25zPy5tZXJnZSAhPT0gZmFsc2UgfSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHBhcmFsbGVsOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZm9yRWFjaE1vZHVsZShjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGZhaWxlZDogW10sIGFmZmVjdGVkOiBbXSwgcmVzdWx0OiBbXSwgZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gb3B0aW9ucz8uZmlsdGVyID8gdGhpcy5maWx0ZXJNb2R1bGVzKG9wdGlvbnMuZmlsdGVyKSA6IHRoaXMuZ2V0QWxsTW9kdWxlcygpO1xuICAgICAgICBpZiAob3B0aW9ucz8ucGFyYWxsZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhciA9IGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZXMubWFwKGFzeW5jIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgcmVzdWx0OiBhd2FpdCBjYWxsYmFjayhtb2R1bGUpLCBtb2R1bGUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyLCByZXN1bHQ6IHVuZGVmaW5lZCwgbW9kdWxlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcGFyLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHAuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZhaWxlZC5wdXNoKHAubW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKHAuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFmZmVjdGVkLnB1c2gocC5tb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVzdWx0LnB1c2gocC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXN1bHQucHVzaChhd2FpdCBjYWxsYmFjayhtb2R1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFmZmVjdGVkLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZmFpbGVkLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCB0aGlzLmZvckVhY2hNb2R1bGUobW9kdWxlID0+IG1vZHVsZS5kZXN0cm95KCksIHsgcGFyYWxsZWw6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcImRlc3Ryb3lcIiwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfVxuICAgIGVycihpbmZvLCBldmVudCkge1xuICAgICAgICBjb25zdCBtc2cgPSBldmVudCBpbnN0YW5jZW9mIEV2ZW50XG4gICAgICAgICAgICA/IChldmVudC5tZXNzYWdlIHx8IGV2ZW50LmRhdGEgfHwgXCJcIikudG9TdHJpbmcoKVxuICAgICAgICAgICAgOiBldmVudCBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgPyBldmVudC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYCR7aW5mb30ke21zZyA/IFwiOiBcIiArIG1zZyA6IFwiXCJ9YCk7XG4gICAgICAgIGlmICh0aGlzLmxvZ3MpXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGluZm8sIGVycik7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudHNIYW5kbGVyIH0gZnJvbSBcIi4vRXZlbnRzSGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgcmFuZG9tSWQsIHJlY2VpdmVEYXRhIH0gZnJvbSBcIi4vc2hhcmVkLmpzXCI7XG4vKiogUmVwcmVzZW50cyBhbiBpZnJhbWUgb3IgYSB3b3JrZXIgKi9cbmV4cG9ydCBjbGFzcyBNb2R1bGUgZXh0ZW5kcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleHRlbnNpb24sIGluaXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBleHRlbnNpb247XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMuaWQgPSByYW5kb21JZCgpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dzID0gISF0aGlzLmV4dGVuc2lvbi5wcm92aWRlci5vcHRpb25zPy5sb2dzO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gSW4gQ09SUyBjb250ZXh0IHRhcmdldCBpcyBXaW5kb3cgKGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgLy8gV2UgY2FudCBkZWZpbmUgdGFyZ2V0Lm9ubWVzc2FnZSBvciB0YXJnZXQub25lcnJvciBvbiBhIGNyb3NzIG9yaWdpbiBXaW5kb3dcbiAgICAgICAgICAgIC8vIFRoYXRzIHdoeSB3ZSBsaXN0ZW4gdG8gdGhlIG1lc3NhZ2UgZXZlbnQgb24gdGhlIGdsb2JhbCBvYmplY3QgYW5kIGNoZWNrIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXNMaXN0ZW5lciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luID0gXCJcIiAtPiBzYW1lIG9yaWdpblxuICAgICAgICAgICAgICAgIGlmIChlLm9yaWdpbiAhPT0gXCJcIiAmJiBlLm9yaWdpbiAhPT0gdGhpcy5pbml0Lm9yaWdpbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGE/Ll9fdG9rZW4gIT09IHRoaXMubWV0YS5hdXRoVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGU/LmRhdGE/Ll9fdHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBlLmRhdGEuX190eXBlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RhdGVfcG9wdWxhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWNlaXZlZFN0YXRlID0gZS5kYXRhLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZFN0YXRlIHx8IHR5cGVvZiByZWNlaXZlZFN0YXRlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycihcIkludmFsaWQgc3RhdGUgcmVjZWl2ZWRcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gZS5kYXRhLm9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0LmFsbG93UG9wdWxhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlID0gISFvcHRpb25zLm1lcmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWQgPSB0aGlzLmluaXQuYWxsb3dQb3B1bGF0ZVN0YXRlID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5hbGxvd1BvcHVsYXRlU3RhdGU/LihyZWNlaXZlZFN0YXRlLCBtZXJnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgYWxsb3dlZCBidXQgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFsbG93ZWQgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdGUgPSBhbGxvd2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSByZWNlaXZlZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJzdGF0ZV9wb3B1bGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3BlcmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFyZ3MsIG9wZXJhdGlvbiwgX19wb3J0OiBwb3J0IH0gPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyKFwiT3BlcmF0aW9uIENoYW5uZWwgRXJyb3JcIiwgXCJQb3J0IG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcCA9IGF3YWl0IHRoaXMuaW5pdC5vdXQ/LltvcGVyYXRpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQub25tZXNzYWdlZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycihcIk9wZXJhdGlvbiBDaGFubmVsIEVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogXCJvcGVyYXRpb246cmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChgb3A6JHtvcGVyYXRpb259YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcy5lcnIoXCJPcGVyYXRpb24gRXhlY3V0aW9uIEVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KGBvcDoke29wZXJhdGlvbn1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChgb3A6JHtvcGVyYXRpb259YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcImxvYWRcIiwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgIHdvcmtlciBtZXNzYWdlcyBhcmUgb25seSByZWNlaXZlZCB2aWEgV29ya2VyLm9ubWVzc2FnZSxcbiAgICAgICAgICAgICB3aGVyZWFzIGlmcmFtZSBtZXNzYWdlcyBhcmUgcmVjZWl2ZWQgdmlhIHdpbmRvdy5vbm1lc3NhZ2Ugb3IgaWZyYW1lLmNvbnRlbnRXaW5kb3cub25tZXNzYWdlLlxuICAgICAgICAgICAgIFNvIHdlIG5lZWQgdG8gaGFuZGxlIHdvcmtlcnMgYW5kIGlmcmFtZXMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBXb3JrZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXQudGFyZ2V0IGluc3RhbmNlb2YgV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9ncylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMaXN0ZW5pbmcgb24gd29ya2VyIGZvciBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VzTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSUZyYW1lXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2dzKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxpc3RlbmluZyBvbiB3aW5kb3cgZm9yIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtZXNzYWdlc0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvc3QgbWV0YTpcbiAgICAgICAgICAgIC8vIC0gV29ya2VycyBuZWVkIHRoaXMgdG8gaW1wb3J0IHRoZSBtb2R1bGUgaW4gdGhlIHdvcmtlciBpbml0aWFsaXphdGlvbiwgd2hvaWNoIGR5bmFtaWNhbGx5IGltcG9ydHMgdGhlIG1vZHVsZVxuICAgICAgICAgICAgLy8gLSBJZnJhbWVzIG5lZWQgdGhpcyB0byBpbml0IHRoZWlyIG1ldGFcbiAgICAgICAgICAgIHRoaXMuaW5pdC50YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IFwibWV0YVwiLCBtZXRhOiB0aGlzLmluaXQubWV0YSB9LCB7IHRhcmdldE9yaWdpbjogdGhpcy5pbml0Lm9yaWdpbiB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmVycihcIkNvbm5lY3Rpb24gdGltZW91dFwiLCBudWxsKSk7XG4gICAgICAgICAgICB9LCB0aGlzLmluaXQuY29ubmVjdGlvblRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IG1ldGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQubWV0YTtcbiAgICB9XG4gICAgZXJyKGluZm8sIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGV2ZW50IGluc3RhbmNlb2YgRXZlbnRcbiAgICAgICAgICAgID8gKGV2ZW50Lm1lc3NhZ2UgfHwgZXZlbnQuZGF0YSB8fCBcIlwiKS50b1N0cmluZygpXG4gICAgICAgICAgICA6IGV2ZW50IGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICA/IGV2ZW50Lm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgJHtpbmZvfSR7bXNnID8gXCI6IFwiICsgbXNnIDogXCJcIn1gKTtcbiAgICAgICAgaWYgKHRoaXMubG9ncylcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoaW5mbywgZXJyKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgICBwb3N0TWVzc2FnZSh0eXBlLCBkYXRhLCB0cmFuc2Zlcikge1xuICAgICAgICB0aGlzLmluaXQudGFyZ2V0LnBvc3RNZXNzYWdlKHsgLi4uZGF0YSwgX190eXBlOiB0eXBlIH0sIHsgdHJhbnNmZXIsIHRhcmdldE9yaWdpbjogdGhpcy5pbml0Lm9yaWdpbiB9KTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZShvcGVyYXRpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlY2VpdmVEYXRhKHRoaXMuaW5pdC50YXJnZXQsIFwib3BlcmF0aW9uXCIsIHsgYXJncywgb3BlcmF0aW9uIH0sIHRoaXMuaW5pdC5vcmlnaW4sIFtdLCB0aGlzLmluaXQub3BlcmF0aW9uVGltZW91dCk7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hTdGF0ZShuZXdTdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgcztcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm1lcmdlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdC5tZXJnZVN0YXRlcykge1xuICAgICAgICAgICAgICAgIHMgPSB0aGlzLmluaXQubWVyZ2VTdGF0ZXModGhpcy5zdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHsgLi4udGhpcy5zdGF0ZSwgLi4ubmV3U3RhdGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzID0gbmV3U3RhdGU7XG4gICAgICAgIGF3YWl0IHRoaXMucG9zdE1lc3NhZ2UoXCJzdGF0ZV9wdXNoXCIsIHtcbiAgICAgICAgICAgIHN0YXRlOiBzLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2V0IHN0YXRlIGZvciB0aGlzIG1vZHVsZSAocHVzaCBzdGF0ZSBzdWNjZXNzKVxuICAgICAgICAvLyBTZXQgc3RhdGUgb25seSBoZXJlLCBzbyB0aGUgc3RhdGUgaW4gdGhlIG1vZHVsZSBpcyB0aGUgc2FtZSBhcyBoZXJlICh0aGUgcHJvdmlkZXIpXG4gICAgICAgIHRoaXMuX3N0YXRlID0gcztcbiAgICAgICAgLy8gcmV0dXJuIGEgY29tcGxldGUgc3RhdGUgaGVyZVxuICAgICAgICAvLyAgYXMgdGhlIHN0YXRlIGluIG1vZHVsZXMgaXMgb3ZlcndyaXR0ZW4gaW4gdGhlIGFkYXB0ZXIgd2l0aCB0aGUgcHVzaGVkIHN0YXRlXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pbml0LnRhcmdldCBpbnN0YW5jZW9mIFdvcmtlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQudGFyZ2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcImRlc3Ryb3lcIiwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudHNIYW5kbGVyIH0gZnJvbSBcIi4vRXZlbnRzSGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIi4vRXh0ZW5zaW9uLmpzXCI7XG5leHBvcnQgY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRFeHRlbnNpb24oZXh0ZW5zaW9uSW5pdCkge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uKHRoaXMsIGV4dGVuc2lvbkluaXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXh0ZW5zaW9uLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBleHRlbnNpb246ICR7ZXJyPy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBldmVudHNcbiAgICAgICAgZXh0ZW5zaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0ZV9wb3B1bGF0ZVwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwic3RhdGVfcG9wdWxhdGVcIiwgeyBleHRlbnNpb24sIG1vZHVsZTogZS5wYXlsb2FkLm1vZHVsZSwgc3RhdGU6IGUucGF5bG9hZC5zdGF0ZSwgb3B0aW9uczogZS5wYXlsb2FkLm1vZHVsZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4dGVuc2lvbi5hZGRFdmVudExpc3RlbmVyKG51bGwsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmIChldi50eXBlLnN0YXJ0c1dpdGgoXCJvcDpcIikpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZXYudHlwZSwgZXYucGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBleHRlbnNpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRlc3Ryb3lcIiwgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShleHRlbnNpb24uaWQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJleHRlbnNpb25fZGVzdHJveVwiLCBleHRlbnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJleHRlbnNpb25fbG9hZFwiLCBleHRlbnNpb24pO1xuICAgICAgICAvLyBjYWNoZVxuICAgICAgICB0aGlzLmNhY2hlLnNldChleHRlbnNpb24uaWQsIGV4dGVuc2lvbik7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGFsbEV4dGVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2FjaGUudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXRFeHRlbnNpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLnZhbHVlcygpKTtcbiAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiBleHRlbnNpb24uZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIH1cbn1cbiIsImV4cG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCIuL0V4dGVuc2lvbi5qc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi9Qcm92aWRlci5qc1wiO1xuZXhwb3J0IHsgRXZlbnQgfSBmcm9tIFwiLi9FdmVudHNIYW5kbGVyLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBQcm92aWRlcjtcbiIsImV4cG9ydCBmdW5jdGlvbiByZWxQYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgIGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUpIHtcbiAgICBpZiAoZS5kYXRhICYmIHR5cGVvZiBlLmRhdGEgPT09IFwib2JqZWN0XCIgJiYgZS5kYXRhLl9fdHlwZSA9PT0gdHlwZSlcbiAgICAgICAgcmV0dXJuIGUuZGF0YTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKiAyNSBjaGFyIGxvbmcgcHNldWRvIGNyeXB0aWMgaWQgKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgICBjb25zdCBjaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gICAgbGV0IHVuaXF1ZUlkID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpO1xuICAgICAgICB1bmlxdWVJZCArPSBjaGFyc1tyYW5kb21JbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVJZDtcbn1cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyA9PT0gd2luZG93LnNlbGY7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjZWl2ZURhdGEodGFyZ2V0LCB0eXBlLCBkYXRhLCBvcmlnaW4gPSBcIipcIiwgdHJhbnNmZXIsIGVyclRpbWVvdXQgPSA1MDAwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjb25zdCBvdXQgPSBjaGFubmVsLnBvcnQxO1xuICAgICAgICBjb25zdCBfaW4gPSBjaGFubmVsLnBvcnQyO1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJPcGVyYXRpb24gdGltZW91dFwiKSk7XG4gICAgICAgIH0sIGVyclRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIG91dC5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUgKyBcIjpyZXN1bHRcIik7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF9pbi5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKGluKVwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIG91dC5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKG91dClcIikpO1xuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQucG9zdE1lc3NhZ2UoeyAuLi5kYXRhLCBfX3R5cGU6IHR5cGUsIF9fcG9ydDogX2luIH0sIHsgdGFyZ2V0T3JpZ2luOiBvcmlnaW4sIHRyYW5zZmVyOiBbX2luLCAuLi4odHJhbnNmZXIgfHwgW10pXSB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBqc2RlbGl2ciA9IFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0XCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKHR5cGUsIG5hbWUsIHZlcnNpb24sIHBhdGgpIHtcbiAgICBsZXQgYmFzZVVybDtcbiAgICBpZiAodHlwZSA9PT0gXCJnaXRodWJcIikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgIGJhc2VVcmwgPSBgJHtqc2RlbGl2cn0vZ2gvJHtvd25lcn0vJHtyZXBvfUAke3ZlcnNpb259L2A7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwibnBtXCIpIHtcbiAgICAgICAgYmFzZVVybCA9IGAke2pzZGVsaXZyfS9ucG0vJHtuYW1lfUAke3ZlcnNpb259L2A7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHJlbFBhdGgocGF0aCk7XG4gICAgICAgIHJldHVybiBiYXNlVXJsICsgcGF0aDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYmFzZVVybDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkRmlsZSh0eXBlLCBuYW1lLCB2ZXJzaW9uLCBwYXRoKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKVxuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGdldFVybCh0eXBlLCBuYW1lLCB2ZXJzaW9uLCBwYXRoKSwgdHlwZSA9PT0gXCJnaXRodWJcIiA/IHt9IDoge30pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGZpbGU6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBmaWxlOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IFByb3ZpZGVyIGZyb20gXCIuLi8uLi9pbmRleFwiO1xuY29uc3QgY29tbWl0U2hhID0gXCJlMWIyZWIwN2I2MDA5OTMxYzllODQ1NWMzNDYxYTNjYTJlZjBhYzFmXCI7XG5tYWluKCkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG5jb25zdCBwcm92aWRlckFwaSA9IHtcbiAgICBlY2hvOiB0ZXh0ID0+IHtcbiAgICAgICAgdGV4dCA9IHRleHQgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHRleHQgKyBcIiAgXCIgKyB0ZXh0ICsgXCIgIFwiICsgdGV4dDtcbiAgICB9LFxuICAgIGFsZXJ0OiBtZXNzYWdlID0+IHtcbiAgICAgICAgYWxlcnQobWVzc2FnZSB8fCBcIjxlbXB0eT5cIik7XG4gICAgfSxcbiAgICBwcmludDogKC4uLnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcmludFwiKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJpbnQ6XCIsICh0ZXh0IHx8IFtcIjxlbXB0eT5cIl0pLmpvaW4oXCIgXCIpKTtcbiAgICB9LFxuICAgIGdyZWV0OiAobmFtZSwgYWdlKSA9PiB7XG4gICAgICAgIGFsZXJ0KFwiSGVsbG8gXCIgKyBuYW1lICsgXCIgQUdFIFwiICsgYWdlKTtcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGxhdW5jaElGcmFtZXMoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZnJhbWVcIik7XG4gICAgY29uc3QgY29udGFpbmVyMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaWZyYW1lMlwiKTtcbiAgICBjb25zdCByZXNldEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzZXRcIik7XG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIyICYmIHJlc2V0QnRuKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudE1vZHVsZSA9IGF3YWl0IGV4dGVuc2lvbi5sYXVuY2hDb21wb25lbnQoY29udGFpbmVyLCBcImRpc3QvZnJhbWVzL2NvdW50ZXIvY291bnRlci5odG1sXCIsIHByb3ZpZGVyQXBpLCB7IGFsbG93UG9wdWxhdGVTdGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50TW9kdWxlMiA9IGF3YWl0IGV4dGVuc2lvbi5sYXVuY2hDb21wb25lbnQoY29udGFpbmVyMiwgXCJkaXN0L2ZyYW1lcy9jb3VudGVyL2NvdW50ZXIuaHRtbFwiLCBwcm92aWRlckFwaSwgeyBhbGxvd1BvcHVsYXRlU3RhdGU6IHRydWUgfSk7XG4gICAgICAgIHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvdW50ZXIgPSBhd2FpdCBjb21wb25lbnRNb2R1bGUuZXhlY3V0ZShcImluY3JlbWVudFwiKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbXBvbmVudE1vZHVsZTIuZXhlY3V0ZShcImluY3JlbWVudFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBOZXcgY291bnRlciA8JHtuZXdDb3VudGVyfT4gcmV0dXJuZWQgYnkgJ2luY3JlbWVudCcgZXhlY3V0ZSAoU2hvdWxkIGFsc28gYmUgZGlzcGxheWVkIGluIHRoZSBpZnJhbWUpYCk7XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICByZXNldEJ0bi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50TW9kdWxlLmV4ZWN1dGUoXCJyZXNldFwiKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZHVsZS5leGVjdXRlKFwicHJpbnRcIiwgXCJSZXNldHRlZFwiLCBcImZyb21cIiwgXCJtYWluIHdpbmRvd1wiKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBsYXVuY2hNb2R1bGUoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgbW9kdWxlID0gYXdhaXQgZXh0ZW5zaW9uLmxhdW5jaE1vZHVsZShcImRpc3QvbWF0aC5qc1wiLCBwcm92aWRlckFwaSk7XG4gICAgY29uc29sZS5sb2coXCJNb2R1bGUgbG9hZGVkOlwiLCBleHRlbnNpb24pO1xuICAgIGNvbnN0IG9wZXJhdGlvbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BlcmF0aW9uXCIpO1xuICAgIGlmIChvcGVyYXRpb25CdG4pIHtcbiAgICAgICAgb3BlcmF0aW9uQnRuLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1vZHVsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxlcnQoXCJNb2R1bGUgbm90IGxvYWRlZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IGF3YWl0IG1vZHVsZS5leGVjdXRlKFwiYWRkXCIsIDEsIDUpO1xuICAgICAgICAgICAgY29uc3QgZCA9IGF3YWl0IG1vZHVsZS5leGVjdXRlKFwic3Vic3RyYWN0XCIsIDEwLCAyKTtcbiAgICAgICAgICAgIGFsZXJ0KFwiU3VtOiBcIiArIHN1bSArIFwiIFN1YjogXCIgKyBkKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGUgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk1lc3NhZ2UgcmVjZWl2ZWQgOjpcIiwgZS5kYXRhKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm92ID0gbmV3IFByb3ZpZGVyKHsgbG9nczogdHJ1ZSB9KTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBhd2FpdCBwcm92LmxvYWRFeHRlbnNpb24oe1xuICAgICAgICB0eXBlOiBcImdpdGh1YlwiLFxuICAgICAgICBuYW1lOiBcImFuZHJlLWhjdHVsYy9leHRlbnNpb25ydW5uZXItdGVzdC1leHRlbnNpb25cIixcbiAgICAgICAgdmVyc2lvbjogY29tbWl0U2hhLFxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKFwiRXh0ZW5zaW9uIGxvYWRlZDpcIiwgZXh0ZW5zaW9uKTtcbiAgICBjb25zdCBpbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvXCIpO1xuICAgIGlmIChpbmZvKVxuICAgICAgICBpbmZvLmlubmVySFRNTCA9IGAke2V4dGVuc2lvbi5wa2cubmFtZX1AJHtleHRlbnNpb24ucGtnLnZlcnNpb259IFNIQSAke2NvbW1pdFNoYX1gO1xuICAgIGxhdW5jaE1vZHVsZShleHRlbnNpb24pLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKFwiRXJyb3IgbGF1bmNoaW5nIG1vZHVsZVwiLCBlcnIpKTtcbiAgICBsYXVuY2hJRnJhbWVzKGV4dGVuc2lvbikuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsYXVuY2hpbmcgaWZyYW1lXCIsIGVycikpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <h2>Module (dist/math.js)</h2>
        <button id="operation">Operation (add and substract)</button>
        <h2>IFrame (dist/frames/counter/index.html)</h2>
        <button id="increment">Counter increment</button>
        <div style="display: flex; gap: 10px;">
            <div id="iframe" style="height: 500px width: 500px;;"></div>
            <div id="iframe2" style="height: 500px width: 500px;;"></div>
        </div>

        <button id="reset">Reset counter (frame1)</button>
    </body>
</html>
