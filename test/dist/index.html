<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/extensionrunner/Extension.js":
/*!***************************************************!*\
  !*** ./node_modules/extensionrunner/Extension.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension)
/* harmony export */ });
/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Module.js */ "./node_modules/extensionrunner/Module.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "./node_modules/extensionrunner/shared.js");
/* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker.js */ "./node_modules/extensionrunner/worker.js");



const jsdelivr = "https://cdn.jsdelivr.net";
class Extension extends _shared_js__WEBPACK_IMPORTED_MODULE_1__.Events {
    constructor(provider, init) {
        super();
        this.provider = provider;
        this.init = init;
        this.url = "";
        this._pkg = {};
        this.started = false;
        /** `<module_id, { instances: <Module, data>, sharedState: any }>` */
        this.cache = new Map();
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            this.url = `${jsdelivr}/gh/${owner}/${repo}@${init.version}/`;
        }
        else if (this.type === "npm") {
            this.url = `${jsdelivr}/npm/${init.name}@${init.version}/`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        // load meta (package.json)
        const file = await this.loadFile("package.json");
        const text = await file.text();
        this._pkg = JSON.parse(text);
    }
    /**
     * @param path Use _null_ or empty string for the packages entry file
     */
    async launchModule(path, out, meta) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.relPath)(path || "");
        /** The worker code is transformed to a string on build, so we can alwys import it here and start the worker */
        const workerCode = _worker_js__WEBPACK_IMPORTED_MODULE_2__.code;
        const blob = new Blob([workerCode], { type: "application/javascript" });
        const url = URL.createObjectURL(blob); // TODO revoke object url
        const worker_ = new Worker(url, { type: "module" });
        const mod = this.initModule(worker_, jsdelivr, path, out, meta);
        return mod.start();
    }
    async launchIFrame(parentElement, path, out, meta) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.relPath)(path);
        // Most CDNs do not directly serve html files, they serve the html as a string in a response. So does jsdelivr and unpkg.
        // So we fetch the html and use ifrm.srcdoc to load the html
        const iframe = document.createElement("iframe");
        let url;
        let origin;
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            origin = "https://raw.githack.com";
            url = `https://raw.githack.com/${owner}/${repo}/${this.init.version}/${path}`;
        }
        else if (this.type === "npm") {
            // TODO see Info.md CDNs
            origin = "https://unpkg.com";
            url = `${origin}/${this.init.name}@${this.init.version}/${path}`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        iframe.src = url;
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
        // TODOD more attrs?
        // wait for load
        return new Promise((resolve, reject) => {
            iframe.onload = async (e) => {
                if (!iframe.contentWindow)
                    return reject("`contentWindow`ndow not defined");
                const mod = this.initModule(iframe.contentWindow, origin, path, out, meta);
                resolve(mod.start());
            };
            iframe.addEventListener("error", e => {
                reject(new Error(e.message));
            });
            parentElement.appendChild(iframe);
        });
    }
    initModule(target, origin, path, out, meta) {
        // genrate random id
        let _meta = {
            authToken: (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.randomId)(),
            name: this.init.name,
            path,
            state: this.cache.get(path)?.sharedState,
            version: this.init.version,
            type: this.init.type,
        };
        _meta = this.init.meta ? this.init.meta(_meta) : _meta;
        if (meta)
            _meta = meta(_meta);
        // create module
        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_0__.Module(this, origin, target, _meta, out, {
            onPushState: (newState, populate) => {
                if (populate)
                    this.pushState(path, newState, undefined, [mod]);
                this.init.onPushState?.(newState, mod);
            },
            onEvent: (type, payload) => {
                this.notifyListeners?.(type, payload, mod);
            },
            operationTimeout: this.init.operationTimeout,
            connectionTimeout: this.init.connectionTimeout,
        });
        // cache
        let instances = this.cache.get(path)?.instances;
        if (!instances) {
            instances = new Map();
            this.cache.set(path, { instances, sharedState: undefined });
        }
        instances.set(mod, { state: undefined });
        return mod;
    }
    get id() {
        return this.init.type + "%" + this.init.name;
    }
    get pkg() {
        return this._pkg;
    }
    get type() {
        return this.init.type;
    }
    getUrl(path, searchParams) {
        if (searchParams && !searchParams.startsWith("?"))
            searchParams = "?" + searchParams;
        return this.url + path + (searchParams || "");
    }
    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */
    async loadFile(path) {
        if (path.startsWith("/"))
            path = path.slice(1);
        else if (path.startsWith("./"))
            path = path.slice(2);
        const response = await fetch(this.getUrl(path), this.type === "github" ? {} : {});
        if (!response.ok) {
            const error = new Error(`Failed to load file: ${response.statusText}`);
            error.response = response;
            throw new Error(`Failed to load file: ${response.statusText}`);
        }
        return response;
    }
    pushState(moduleId, newState, instance, exclude) {
        const exclSet = new Set(exclude);
        const cache = this.cache.get(moduleId);
        if (cache) {
            if (instance) {
                if (!exclSet.has(instance))
                    instance.pushState(newState);
            }
            else {
                const modules = Array.from(cache.instances.keys());
                modules.forEach(instance => {
                    if (!exclSet.has(instance))
                        instance.pushState(newState);
                });
            }
        }
    }
    emitEvent(type, payload, filter) {
        for (const moduleId of this.cache.keys()) {
            const modules = Array.from(this.cache.get(moduleId)?.instances.keys() || []);
            modules.forEach(instance => {
                if (filter && !filter(moduleId, instance))
                    return;
                instance.emitEvent(type, payload);
            });
        }
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/Module.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/Module.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module)
/* harmony export */ });
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ "./node_modules/extensionrunner/shared.js");

/** Represents an iframe or a worker */
class Module {
    constructor(extension, origin, target, meta, out, options) {
        this.extension = extension;
        this.origin = origin;
        this.target = target;
        this.meta = meta;
        this.out = out;
        this.options = options;
        this.inited = false;
        this.started = false;
        this.logs = !!this.extension.provider.options?.logs;
    }
    async start() {
        if (this.started)
            return this;
        this.started = true;
        return new Promise((resolve, reject) => {
            // In CORS context target is Window (iframe.contentWindow)
            // We cant define target.onmessage or target.onerror on a cross origin Window
            // Thats why we listen to the message event on the global object and check the source
            let resolved = false;
            const messagesListener = async (e) => {
                // authenticate
                // TODO if (e.origin !== this.origin) return;
                // TODO if (e.data?.__token !== this.meta.authToken) return;
                if (typeof e?.data?.__type !== "string")
                    return;
                const type = e.data.__type;
                switch (type) {
                    case "state_push":
                        this._state = e.data.state;
                        this.options.onPushState?.(e.data.state, !!e.data.populate);
                        break;
                    case "event":
                        this.options.onEvent?.(e.data.event, e.data.args);
                        break;
                    case "operation":
                        const { args, operation, __port: port } = e.data;
                        if (!port)
                            return this.err("Operation Channel Error", "Port not found");
                        const op = await this.out[operation];
                        if (typeof op !== "function")
                            return this.err("Operation not found", null);
                        port.onmessageerror = e => {
                            this.err("Operation Channel Error", e);
                        };
                        try {
                            const result = await op(...args);
                            port.postMessage({ __type: "operation:result", payload: result });
                        }
                        catch (err) {
                            return this.err("Operation Execution Error", err);
                        }
                        break;
                    case "ready":
                        resolved = true;
                        // init events once
                        if (!this.inited) {
                            this.inited = true;
                            // init postMessage (received by worker.ts or iframe)
                            const events = new MessageChannel();
                            const eventsIn = events.port1;
                            const eventsOut = events.port2;
                            eventsIn.onmessageerror = e => {
                                this.err("Events Channel (in) Error", e);
                            };
                            eventsOut.onmessageerror = e => {
                                this.err("Events Channel (out) Error", e);
                            };
                            resolve(this);
                        }
                        break;
                }
            };
            /*
             worker messages are only received via Worker.onmessage,
             whereas iframe messages are received via window.onmessage or iframe.contentWindow.onmessage.
             So we need to handle workers and iframes differently
            */
            // Worker
            if (this.target instanceof Worker) {
                if (this.logs)
                    console.log("Listening on worker for messages");
                this.target.addEventListener("message", messagesListener);
            }
            // IFrame
            else {
                if (this.logs)
                    console.log("Listening on window for messages");
                window.addEventListener("message", messagesListener);
            }
            // Post meta:
            // - Workers need this to import the module in the worker initialization, whoich dynamically imports the module
            // - Iframes need this to init their meta
            this.target.postMessage({ __type: "meta", meta: this.meta }, { targetOrigin: "*" }); // TODO targetOrigin
            setTimeout(() => {
                if (!resolved)
                    reject(this.err("Connection timeout", null));
            }, this.options.connectionTimeout || 5000);
        });
    }
    get state() {
        return this._state;
    }
    err(info, event) {
        const msg = event instanceof Event ? (event.message || event.data || "").toString() : event instanceof Error ? event.message : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        this.options?.onError?.(err);
        console.error(info, err);
        return err;
    }
    postMessage(type, data, transfer) {
        this.target.postMessage({ ...data, __type: type }, { transfer });
    }
    async execute(operation, ...args) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.receiveData)(this.target, "operation", { args, operation }, [], this.options.operationTimeout);
    }
    async emitEvent(type, payload) {
        this.postMessage("event", { event: type, args: payload });
    }
    async pushState(newState) {
        this.postMessage("state_push", { state: newState });
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/Provider.js":
/*!**************************************************!*\
  !*** ./node_modules/extensionrunner/Provider.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/extensionrunner/Extension.js");

class Provider {
    constructor(options) {
        this.options = options;
        this.cache = new Map();
    }
    async loadExtension(extensionInit) {
        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension(this, extensionInit);
        try {
            await extension.start();
        }
        catch (err) {
            throw new Error(`Failed to load extension: ${err}`);
        }
        this.cache.set(extension.id, extension);
        return extension;
    }
    allExtensions() {
        return Array.from(this.cache.values());
    }
    getExtension(id) {
        return this.cache.get(id) || null;
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/index.js":
/*!***********************************************!*\
  !*** ./node_modules/extensionrunner/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/extensionrunner/Extension.js");
/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ "./node_modules/extensionrunner/Provider.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);


/***/ }),

/***/ "./node_modules/extensionrunner/shared.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/shared.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Events: () => (/* binding */ Events),
/* harmony export */   getMessageData: () => (/* binding */ getMessageData),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   receiveData: () => (/* binding */ receiveData),
/* harmony export */   relPath: () => (/* binding */ relPath)
/* harmony export */ });
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Events_listeners;
function relPath(path) {
    if (path.startsWith("./"))
        path = path.slice(2);
    else if (path.startsWith("/"))
        path = path.slice(1);
    return path;
}
function getMessageData(e, type) {
    if (e.data && typeof e.data === "object" && e.data.__type === type)
        return e.data;
    return null;
}
function randomId() {
    const timestamp = new Date().getTime();
    const random = Math.random().toString(36).substring(2, 9);
    return `${timestamp}${random}`;
}
async function receiveData(target, type, data, transfer, errTimeout = 5000) {
    return new Promise((resolve, reject) => {
        const channel = new MessageChannel();
        const out = channel.port1;
        const _in = channel.port2;
        let resolved = false;
        setTimeout(() => {
            if (!resolved)
                reject(new Error("Operation timeout"));
        }, errTimeout || 5000);
        out.onmessage = async (e) => {
            const data = getMessageData(e, type + ":result");
            if (data) {
                resolved = true;
                resolve(data.payload);
            }
        };
        _in.onmessageerror = e => {
            reject(new Error("Channel Error (in)"));
        };
        out.onmessageerror = e => {
            reject(new Error("Channel Error (out)"));
        };
        target.postMessage({ ...data, __type: type, __port: _in }, { transfer: [_in, ...transfer] });
    });
}
class Events {
    constructor() {
        _Events_listeners.set(this, new Map());
    }
    addEventListener(type, listener) {
        if (!__classPrivateFieldGet(this, _Events_listeners, "f").has(type))
            __classPrivateFieldGet(this, _Events_listeners, "f").set(type, new Set());
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.add(listener);
    }
    removeEventListener(type, listener) {
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.delete(listener);
    }
    notifyListeners(type, ...args) {
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.forEach(listener => listener(...args));
    }
}
_Events_listeners = new WeakMap();


/***/ }),

/***/ "./node_modules/extensionrunner/worker.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/worker.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code)
/* harmony export */ });
const code=`
/*
Import the extension module from github or unpkg
Do not use imports here, they ccannot be resolved (See script postbuild)
*/
let started = false;
const isNonEmptyStr = (s) => !!s && typeof s === "string";
// First message must be the meta!
self.onmessage = async (e) => {
    if (started)
        return;
    started = true;
    // If init message
    if (e.data?.__type == "meta" && typeof e.data.meta === "object") {
        const meta = e.data.meta;
        // Check meta
        if (!isNonEmptyStr(meta.path))
            throw new Error("Invalid path");
        if (!isNonEmptyStr(meta.version))
            throw new Error("Invalid name");
        if (!isNonEmptyStr(meta.path))
            throw new Error("Invalid version");
        // init meta
        self.meta = meta;
        // import module (for side effects - imported modules should use \`Adapter\`)
        let importUrl;
        // do not use template strings here, post build script wraps this code in \`\`
        if (meta.type === "npm") {
            // unpkg
            importUrl = "https://cdn.jsdelivr.net/gh/" + meta.name + "@" + meta.version + "/" + meta.path;
        }
        else if (meta.type === "github") {
            // Use jsdelivr for github, as github does not support Commit shas or CORS
            const [owner, repo] = meta.name.split("/");
            importUrl = "https://cdn.jsdelivr.net/npm/" + meta.name + "@" + meta.version + "/" + meta.path;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        try {
            const mod = await import(importUrl);
            postMessage({ __type: "ready", __token: meta.authToken });
        }
        catch (err) {
            console.error("Failed to import module", err);
            postMessage({ __type: "import_error", __token: meta.authToken });
        }
    }
};
export {};

`

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var extensionrunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! extensionrunner */ "./node_modules/extensionrunner/index.js");


main().catch(err => console.error(err));

async function main() {
    addEventListener("message", e => {
        console.log("Message received ::", e.data);
    });

    const prov = new extensionrunner__WEBPACK_IMPORTED_MODULE_0__["default"]({ logs: true });
    const commitSha = "0d0148d65a0032daf1c7ac77db726aa4ea020338";
    const extension = await prov.loadExtension({
        type: "github",
        name: "andre-hctulc/extensionrunner-test-extension",
        version: commitSha,
        out: {
            echo: text => alert(text + " ... " + text + " .. . .    ." + text),
        },
        onStatePush: (newState, module) => {
            alert("State Push received:", newState);
        },
    });

    console.log("Extension loaded:", extension);

    const info = document.getElementById("info");
    info.innerHTML = `Test-Extension loaded: ${extension.pkg.name}@${extension.pkg.version} SHA ${commitSha}`;

    // pushState

    const stateBtn = document.getElementById("state");

    let counter = 0;

    stateBtn.onclick = () => {
        extension.pushState({ message: "Counter: " + ++counter });
    };

    // launch

    // launchModule(extension).catch(err => console.error("Error launching module", err));
    launchIFrame(extension).catch(err => console.error("Error launching iframe", err));
}

async function launchModule(extension) {
    const module = await extension.launchModule("dist/math.js");

    console.log("Module loaded:", extension);

    // module operations

    const eventBtn = document.getElementById("event");
    const operationBtn = document.getElementById("operation");

    eventBtn.onclick = () => {
        extension.emitEvent("greet", "Hello world!");
    };

    operationBtn.onclick = async () => {
        if (!module) return alert("Module not loaded");
        const sum = await module.execute("add", 1, 5);
        const d = await module.execute("substract", 10, 2);
        alert("Sum: " + sum + " Sub: " + d);
    };
}

async function launchIFrame(extension) {
    // iframe

    const container = document.getElementById("iframe");

    if (container) {
        const iframeModule = await extension.launchIFrame(container, "dist/frames/counter/index.html", {});
    }
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0NBQWtDO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5R0FBeUc7QUFDekc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvZXh0ZW5zaW9ucnVubmVyL0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4vbm9kZV9tb2R1bGVzL2V4dGVuc2lvbnJ1bm5lci9Nb2R1bGUuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9leHRlbnNpb25ydW5uZXIvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9leHRlbnNpb25ydW5uZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9leHRlbnNpb25ydW5uZXIvc2hhcmVkLmpzIiwid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvZXh0ZW5zaW9ucnVubmVyL3dvcmtlci5qcyIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdGVzdC8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb2R1bGUgfSBmcm9tIFwiLi9Nb2R1bGUuanNcIjtcbmltcG9ydCB7IEV2ZW50cywgcmFuZG9tSWQsIHJlbFBhdGggfSBmcm9tIFwiLi9zaGFyZWQuanNcIjtcbmltcG9ydCAqIGFzIHdvcmtlciBmcm9tIFwiLi93b3JrZXIuanNcIjtcbmNvbnN0IGpzZGVsaXZyID0gXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXRcIjtcbmV4cG9ydCBjbGFzcyBFeHRlbnNpb24gZXh0ZW5kcyBFdmVudHMge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBpbml0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgdGhpcy51cmwgPSBcIlwiO1xuICAgICAgICB0aGlzLl9wa2cgPSB7fTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBgPG1vZHVsZV9pZCwgeyBpbnN0YW5jZXM6IDxNb2R1bGUsIGRhdGE+LCBzaGFyZWRTdGF0ZTogYW55IH0+YCAqL1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImdpdGh1YlwiKSB7XG4gICAgICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gdGhpcy5pbml0Lm5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgdGhpcy51cmwgPSBgJHtqc2RlbGl2cn0vZ2gvJHtvd25lcn0vJHtyZXBvfUAke2luaXQudmVyc2lvbn0vYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwibnBtXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gYCR7anNkZWxpdnJ9L25wbS8ke2luaXQubmFtZX1AJHtpbml0LnZlcnNpb259L2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBsb2FkIG1ldGEgKHBhY2thZ2UuanNvbilcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMubG9hZEZpbGUoXCJwYWNrYWdlLmpzb25cIik7XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBmaWxlLnRleHQoKTtcbiAgICAgICAgdGhpcy5fcGtnID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhdGggVXNlIF9udWxsXyBvciBlbXB0eSBzdHJpbmcgZm9yIHRoZSBwYWNrYWdlcyBlbnRyeSBmaWxlXG4gICAgICovXG4gICAgYXN5bmMgbGF1bmNoTW9kdWxlKHBhdGgsIG91dCwgbWV0YSkge1xuICAgICAgICBwYXRoID0gcmVsUGF0aChwYXRoIHx8IFwiXCIpO1xuICAgICAgICAvKiogVGhlIHdvcmtlciBjb2RlIGlzIHRyYW5zZm9ybWVkIHRvIGEgc3RyaW5nIG9uIGJ1aWxkLCBzbyB3ZSBjYW4gYWx3eXMgaW1wb3J0IGl0IGhlcmUgYW5kIHN0YXJ0IHRoZSB3b3JrZXIgKi9cbiAgICAgICAgY29uc3Qgd29ya2VyQ29kZSA9IHdvcmtlci5jb2RlO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3dvcmtlckNvZGVdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiIH0pO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpOyAvLyBUT0RPIHJldm9rZSBvYmplY3QgdXJsXG4gICAgICAgIGNvbnN0IHdvcmtlcl8gPSBuZXcgV29ya2VyKHVybCwgeyB0eXBlOiBcIm1vZHVsZVwiIH0pO1xuICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmluaXRNb2R1bGUod29ya2VyXywganNkZWxpdnIsIHBhdGgsIG91dCwgbWV0YSk7XG4gICAgICAgIHJldHVybiBtb2Quc3RhcnQoKTtcbiAgICB9XG4gICAgYXN5bmMgbGF1bmNoSUZyYW1lKHBhcmVudEVsZW1lbnQsIHBhdGgsIG91dCwgbWV0YSkge1xuICAgICAgICBwYXRoID0gcmVsUGF0aChwYXRoKTtcbiAgICAgICAgLy8gTW9zdCBDRE5zIGRvIG5vdCBkaXJlY3RseSBzZXJ2ZSBodG1sIGZpbGVzLCB0aGV5IHNlcnZlIHRoZSBodG1sIGFzIGEgc3RyaW5nIGluIGEgcmVzcG9uc2UuIFNvIGRvZXMganNkZWxpdnIgYW5kIHVucGtnLlxuICAgICAgICAvLyBTbyB3ZSBmZXRjaCB0aGUgaHRtbCBhbmQgdXNlIGlmcm0uc3JjZG9jIHRvIGxvYWQgdGhlIGh0bWxcbiAgICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgbGV0IHVybDtcbiAgICAgICAgbGV0IG9yaWdpbjtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJnaXRodWJcIikge1xuICAgICAgICAgICAgY29uc3QgW293bmVyLCByZXBvXSA9IHRoaXMuaW5pdC5uYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIG9yaWdpbiA9IFwiaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb21cIjtcbiAgICAgICAgICAgIHVybCA9IGBodHRwczovL3Jhdy5naXRoYWNrLmNvbS8ke293bmVyfS8ke3JlcG99LyR7dGhpcy5pbml0LnZlcnNpb259LyR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJucG1cIikge1xuICAgICAgICAgICAgLy8gVE9ETyBzZWUgSW5mby5tZCBDRE5zXG4gICAgICAgICAgICBvcmlnaW4gPSBcImh0dHBzOi8vdW5wa2cuY29tXCI7XG4gICAgICAgICAgICB1cmwgPSBgJHtvcmlnaW59LyR7dGhpcy5pbml0Lm5hbWV9QCR7dGhpcy5pbml0LnZlcnNpb259LyR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSAoJ25wbScgb3IgJ2dpdGh1YicgZXhwZWN0ZWQpXCIpO1xuICAgICAgICBpZnJhbWUuc3JjID0gdXJsO1xuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwic2FuZGJveFwiLCBcImFsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW5cIik7XG4gICAgICAgIC8vIFRPRE9EIG1vcmUgYXR0cnM/XG4gICAgICAgIC8vIHdhaXQgZm9yIGxvYWRcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmcmFtZS5vbmxvYWQgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoXCJgY29udGVudFdpbmRvd2BuZG93IG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZCA9IHRoaXMuaW5pdE1vZHVsZShpZnJhbWUuY29udGVudFdpbmRvdywgb3JpZ2luLCBwYXRoLCBvdXQsIG1ldGEpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kLnN0YXJ0KCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdE1vZHVsZSh0YXJnZXQsIG9yaWdpbiwgcGF0aCwgb3V0LCBtZXRhKSB7XG4gICAgICAgIC8vIGdlbnJhdGUgcmFuZG9tIGlkXG4gICAgICAgIGxldCBfbWV0YSA9IHtcbiAgICAgICAgICAgIGF1dGhUb2tlbjogcmFuZG9tSWQoKSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuaW5pdC5uYW1lLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNhY2hlLmdldChwYXRoKT8uc2hhcmVkU3RhdGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmluaXQudmVyc2lvbixcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuaW5pdC50eXBlLFxuICAgICAgICB9O1xuICAgICAgICBfbWV0YSA9IHRoaXMuaW5pdC5tZXRhID8gdGhpcy5pbml0Lm1ldGEoX21ldGEpIDogX21ldGE7XG4gICAgICAgIGlmIChtZXRhKVxuICAgICAgICAgICAgX21ldGEgPSBtZXRhKF9tZXRhKTtcbiAgICAgICAgLy8gY3JlYXRlIG1vZHVsZVxuICAgICAgICBjb25zdCBtb2QgPSBuZXcgTW9kdWxlKHRoaXMsIG9yaWdpbiwgdGFyZ2V0LCBfbWV0YSwgb3V0LCB7XG4gICAgICAgICAgICBvblB1c2hTdGF0ZTogKG5ld1N0YXRlLCBwb3B1bGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwb3B1bGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUocGF0aCwgbmV3U3RhdGUsIHVuZGVmaW5lZCwgW21vZF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5vblB1c2hTdGF0ZT8uKG5ld1N0YXRlLCBtb2QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXZlbnQ6ICh0eXBlLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnM/Lih0eXBlLCBwYXlsb2FkLCBtb2QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZXJhdGlvblRpbWVvdXQ6IHRoaXMuaW5pdC5vcGVyYXRpb25UaW1lb3V0LFxuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHRoaXMuaW5pdC5jb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNhY2hlXG4gICAgICAgIGxldCBpbnN0YW5jZXMgPSB0aGlzLmNhY2hlLmdldChwYXRoKT8uaW5zdGFuY2VzO1xuICAgICAgICBpZiAoIWluc3RhbmNlcykge1xuICAgICAgICAgICAgaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgeyBpbnN0YW5jZXMsIHNoYXJlZFN0YXRlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2VzLnNldChtb2QsIHsgc3RhdGU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0LnR5cGUgKyBcIiVcIiArIHRoaXMuaW5pdC5uYW1lO1xuICAgIH1cbiAgICBnZXQgcGtnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGtnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC50eXBlO1xuICAgIH1cbiAgICBnZXRVcmwocGF0aCwgc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIGlmIChzZWFyY2hQYXJhbXMgJiYgIXNlYXJjaFBhcmFtcy5zdGFydHNXaXRoKFwiP1wiKSlcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcyA9IFwiP1wiICsgc2VhcmNoUGFyYW1zO1xuICAgICAgICByZXR1cm4gdGhpcy51cmwgKyBwYXRoICsgKHNlYXJjaFBhcmFtcyB8fCBcIlwiKTtcbiAgICB9XG4gICAgLyoqIElmIHRoZSByZXNwb25zZSBpcyBub3Qgb2ssIHRoZSBgUmVzcG9uc2VgIHdpbGwgYmUgc2V0IG9uIHRoZSB0aHJvd24gZXJyb3IgKGBFcnJvci5yZXNwb25zZWApICovXG4gICAgYXN5bmMgbG9hZEZpbGUocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBlbHNlIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSlcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZ2V0VXJsKHBhdGgpLCB0aGlzLnR5cGUgPT09IFwiZ2l0aHViXCIgPyB7fSA6IHt9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGZpbGU6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGZpbGU6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIHB1c2hTdGF0ZShtb2R1bGVJZCwgbmV3U3RhdGUsIGluc3RhbmNlLCBleGNsdWRlKSB7XG4gICAgICAgIGNvbnN0IGV4Y2xTZXQgPSBuZXcgU2V0KGV4Y2x1ZGUpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGUuZ2V0KG1vZHVsZUlkKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4Y2xTZXQuaGFzKGluc3RhbmNlKSlcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucHVzaFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZXMgPSBBcnJheS5mcm9tKGNhY2hlLmluc3RhbmNlcy5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIG1vZHVsZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhjbFNldC5oYXMoaW5zdGFuY2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucHVzaFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0RXZlbnQodHlwZSwgcGF5bG9hZCwgZmlsdGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlSWQgb2YgdGhpcy5jYWNoZS5rZXlzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZXMgPSBBcnJheS5mcm9tKHRoaXMuY2FjaGUuZ2V0KG1vZHVsZUlkKT8uaW5zdGFuY2VzLmtleXMoKSB8fCBbXSk7XG4gICAgICAgICAgICBtb2R1bGVzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlcihtb2R1bGVJZCwgaW5zdGFuY2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZW1pdEV2ZW50KHR5cGUsIHBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyByZWNlaXZlRGF0YSB9IGZyb20gXCIuL3NoYXJlZC5qc1wiO1xuLyoqIFJlcHJlc2VudHMgYW4gaWZyYW1lIG9yIGEgd29ya2VyICovXG5leHBvcnQgY2xhc3MgTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihleHRlbnNpb24sIG9yaWdpbiwgdGFyZ2V0LCBtZXRhLCBvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBleHRlbnNpb247XG4gICAgICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgICAgdGhpcy5vdXQgPSBvdXQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ3MgPSAhIXRoaXMuZXh0ZW5zaW9uLnByb3ZpZGVyLm9wdGlvbnM/LmxvZ3M7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBJbiBDT1JTIGNvbnRleHQgdGFyZ2V0IGlzIFdpbmRvdyAoaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAvLyBXZSBjYW50IGRlZmluZSB0YXJnZXQub25tZXNzYWdlIG9yIHRhcmdldC5vbmVycm9yIG9uIGEgY3Jvc3Mgb3JpZ2luIFdpbmRvd1xuICAgICAgICAgICAgLy8gVGhhdHMgd2h5IHdlIGxpc3RlbiB0byB0aGUgbWVzc2FnZSBldmVudCBvbiB0aGUgZ2xvYmFsIG9iamVjdCBhbmQgY2hlY2sgdGhlIHNvdXJjZVxuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlc0xpc3RlbmVyID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBhdXRoZW50aWNhdGVcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGlmIChlLm9yaWdpbiAhPT0gdGhpcy5vcmlnaW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGlmIChlLmRhdGE/Ll9fdG9rZW4gIT09IHRoaXMubWV0YS5hdXRoVG9rZW4pIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGU/LmRhdGE/Ll9fdHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBlLmRhdGEuX190eXBlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RhdGVfcHVzaFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBlLmRhdGEuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25QdXNoU3RhdGU/LihlLmRhdGEuc3RhdGUsICEhZS5kYXRhLnBvcHVsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkV2ZW50Py4oZS5kYXRhLmV2ZW50LCBlLmRhdGEuYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wZXJhdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhcmdzLCBvcGVyYXRpb24sIF9fcG9ydDogcG9ydCB9ID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb3J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycihcIk9wZXJhdGlvbiBDaGFubmVsIEVycm9yXCIsIFwiUG9ydCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcCA9IGF3YWl0IHRoaXMub3V0W29wZXJhdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyKFwiT3BlcmF0aW9uIG5vdCBmb3VuZFwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQub25tZXNzYWdlZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycihcIk9wZXJhdGlvbiBDaGFubmVsIEVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3AoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZSh7IF9fdHlwZTogXCJvcGVyYXRpb246cmVzdWx0XCIsIHBheWxvYWQ6IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnIoXCJPcGVyYXRpb24gRXhlY3V0aW9uIEVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0IGV2ZW50cyBvbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXQgcG9zdE1lc3NhZ2UgKHJlY2VpdmVkIGJ5IHdvcmtlci50cyBvciBpZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzSW4gPSBldmVudHMucG9ydDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzT3V0ID0gZXZlbnRzLnBvcnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c0luLm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyKFwiRXZlbnRzIENoYW5uZWwgKGluKSBFcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c091dC5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycihcIkV2ZW50cyBDaGFubmVsIChvdXQpIEVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgIHdvcmtlciBtZXNzYWdlcyBhcmUgb25seSByZWNlaXZlZCB2aWEgV29ya2VyLm9ubWVzc2FnZSxcbiAgICAgICAgICAgICB3aGVyZWFzIGlmcmFtZSBtZXNzYWdlcyBhcmUgcmVjZWl2ZWQgdmlhIHdpbmRvdy5vbm1lc3NhZ2Ugb3IgaWZyYW1lLmNvbnRlbnRXaW5kb3cub25tZXNzYWdlLlxuICAgICAgICAgICAgIFNvIHdlIG5lZWQgdG8gaGFuZGxlIHdvcmtlcnMgYW5kIGlmcmFtZXMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBXb3JrZXJcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIFdvcmtlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvZ3MpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTGlzdGVuaW5nIG9uIHdvcmtlciBmb3IgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbWVzc2FnZXNMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJRnJhbWVcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvZ3MpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTGlzdGVuaW5nIG9uIHdpbmRvdyBmb3IgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VzTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9zdCBtZXRhOlxuICAgICAgICAgICAgLy8gLSBXb3JrZXJzIG5lZWQgdGhpcyB0byBpbXBvcnQgdGhlIG1vZHVsZSBpbiB0aGUgd29ya2VyIGluaXRpYWxpemF0aW9uLCB3aG9pY2ggZHluYW1pY2FsbHkgaW1wb3J0cyB0aGUgbW9kdWxlXG4gICAgICAgICAgICAvLyAtIElmcmFtZXMgbmVlZCB0aGlzIHRvIGluaXQgdGhlaXIgbWV0YVxuICAgICAgICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IFwibWV0YVwiLCBtZXRhOiB0aGlzLm1ldGEgfSwgeyB0YXJnZXRPcmlnaW46IFwiKlwiIH0pOyAvLyBUT0RPIHRhcmdldE9yaWdpblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZXJyKFwiQ29ubmVjdGlvbiB0aW1lb3V0XCIsIG51bGwpKTtcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dCB8fCA1MDAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICBlcnIoaW5mbywgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXZlbnQgaW5zdGFuY2VvZiBFdmVudCA/IChldmVudC5tZXNzYWdlIHx8IGV2ZW50LmRhdGEgfHwgXCJcIikudG9TdHJpbmcoKSA6IGV2ZW50IGluc3RhbmNlb2YgRXJyb3IgPyBldmVudC5tZXNzYWdlIDogXCJcIjtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAke2luZm99JHttc2cgPyBcIjogXCIgKyBtc2cgOiBcIlwifWApO1xuICAgICAgICB0aGlzLm9wdGlvbnM/Lm9uRXJyb3I/LihlcnIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGluZm8sIGVycik7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIHBvc3RNZXNzYWdlKHR5cGUsIGRhdGEsIHRyYW5zZmVyKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKHsgLi4uZGF0YSwgX190eXBlOiB0eXBlIH0sIHsgdHJhbnNmZXIgfSk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGUob3BlcmF0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWNlaXZlRGF0YSh0aGlzLnRhcmdldCwgXCJvcGVyYXRpb25cIiwgeyBhcmdzLCBvcGVyYXRpb24gfSwgW10sIHRoaXMub3B0aW9ucy5vcGVyYXRpb25UaW1lb3V0KTtcbiAgICB9XG4gICAgYXN5bmMgZW1pdEV2ZW50KHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZShcImV2ZW50XCIsIHsgZXZlbnQ6IHR5cGUsIGFyZ3M6IHBheWxvYWQgfSk7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKFwic3RhdGVfcHVzaFwiLCB7IHN0YXRlOiBuZXdTdGF0ZSB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tIFwiLi9FeHRlbnNpb24uanNcIjtcbmV4cG9ydCBjbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhc3luYyBsb2FkRXh0ZW5zaW9uKGV4dGVuc2lvbkluaXQpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IEV4dGVuc2lvbih0aGlzLCBleHRlbnNpb25Jbml0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGV4dGVuc2lvbi5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgZXh0ZW5zaW9uOiAke2Vycn1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLnNldChleHRlbnNpb24uaWQsIGV4dGVuc2lvbik7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGFsbEV4dGVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2FjaGUudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXRFeHRlbnNpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH1cbn1cbiIsImV4cG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCIuL0V4dGVuc2lvbi5qc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi9Qcm92aWRlci5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgUHJvdmlkZXI7XG4iLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRXZlbnRzX2xpc3RlbmVycztcbmV4cG9ydCBmdW5jdGlvbiByZWxQYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgIGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUpIHtcbiAgICBpZiAoZS5kYXRhICYmIHR5cGVvZiBlLmRhdGEgPT09IFwib2JqZWN0XCIgJiYgZS5kYXRhLl9fdHlwZSA9PT0gdHlwZSlcbiAgICAgICAgcmV0dXJuIGUuZGF0YTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCByYW5kb20gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSk7XG4gICAgcmV0dXJuIGAke3RpbWVzdGFtcH0ke3JhbmRvbX1gO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlY2VpdmVEYXRhKHRhcmdldCwgdHlwZSwgZGF0YSwgdHJhbnNmZXIsIGVyclRpbWVvdXQgPSA1MDAwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjb25zdCBvdXQgPSBjaGFubmVsLnBvcnQxO1xuICAgICAgICBjb25zdCBfaW4gPSBjaGFubmVsLnBvcnQyO1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJPcGVyYXRpb24gdGltZW91dFwiKSk7XG4gICAgICAgIH0sIGVyclRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIG91dC5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUgKyBcIjpyZXN1bHRcIik7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF9pbi5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKGluKVwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIG91dC5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKG91dClcIikpO1xuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQucG9zdE1lc3NhZ2UoeyAuLi5kYXRhLCBfX3R5cGU6IHR5cGUsIF9fcG9ydDogX2luIH0sIHsgdHJhbnNmZXI6IFtfaW4sIC4uLnRyYW5zZmVyXSB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjbGFzcyBFdmVudHMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfRXZlbnRzX2xpc3RlbmVycy5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c19saXN0ZW5lcnMsIFwiZlwiKS5oYXModHlwZSkpXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNfbGlzdGVuZXJzLCBcImZcIikuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c19saXN0ZW5lcnMsIFwiZlwiKS5nZXQodHlwZSk/LmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgbm90aWZ5TGlzdGVuZXJzKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gICAgfVxufVxuX0V2ZW50c19saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuIiwiZXhwb3J0IGNvbnN0IGNvZGU9YFxuLypcbkltcG9ydCB0aGUgZXh0ZW5zaW9uIG1vZHVsZSBmcm9tIGdpdGh1YiBvciB1bnBrZ1xuRG8gbm90IHVzZSBpbXBvcnRzIGhlcmUsIHRoZXkgY2Nhbm5vdCBiZSByZXNvbHZlZCAoU2VlIHNjcmlwdCBwb3N0YnVpbGQpXG4qL1xubGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbmNvbnN0IGlzTm9uRW1wdHlTdHIgPSAocykgPT4gISFzICYmIHR5cGVvZiBzID09PSBcInN0cmluZ1wiO1xuLy8gRmlyc3QgbWVzc2FnZSBtdXN0IGJlIHRoZSBtZXRhIVxuc2VsZi5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgIGlmIChzdGFydGVkKVxuICAgICAgICByZXR1cm47XG4gICAgc3RhcnRlZCA9IHRydWU7XG4gICAgLy8gSWYgaW5pdCBtZXNzYWdlXG4gICAgaWYgKGUuZGF0YT8uX190eXBlID09IFwibWV0YVwiICYmIHR5cGVvZiBlLmRhdGEubWV0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBtZXRhID0gZS5kYXRhLm1ldGE7XG4gICAgICAgIC8vIENoZWNrIG1ldGFcbiAgICAgICAgaWYgKCFpc05vbkVtcHR5U3RyKG1ldGEucGF0aCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhdGhcIik7XG4gICAgICAgIGlmICghaXNOb25FbXB0eVN0cihtZXRhLnZlcnNpb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuYW1lXCIpO1xuICAgICAgICBpZiAoIWlzTm9uRW1wdHlTdHIobWV0YS5wYXRoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvblwiKTtcbiAgICAgICAgLy8gaW5pdCBtZXRhXG4gICAgICAgIHNlbGYubWV0YSA9IG1ldGE7XG4gICAgICAgIC8vIGltcG9ydCBtb2R1bGUgKGZvciBzaWRlIGVmZmVjdHMgLSBpbXBvcnRlZCBtb2R1bGVzIHNob3VsZCB1c2UgXFxgQWRhcHRlclxcYClcbiAgICAgICAgbGV0IGltcG9ydFVybDtcbiAgICAgICAgLy8gZG8gbm90IHVzZSB0ZW1wbGF0ZSBzdHJpbmdzIGhlcmUsIHBvc3QgYnVpbGQgc2NyaXB0IHdyYXBzIHRoaXMgY29kZSBpbiBcXGBcXGBcbiAgICAgICAgaWYgKG1ldGEudHlwZSA9PT0gXCJucG1cIikge1xuICAgICAgICAgICAgLy8gdW5wa2dcbiAgICAgICAgICAgIGltcG9ydFVybCA9IFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL1wiICsgbWV0YS5uYW1lICsgXCJAXCIgKyBtZXRhLnZlcnNpb24gKyBcIi9cIiArIG1ldGEucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXRhLnR5cGUgPT09IFwiZ2l0aHViXCIpIHtcbiAgICAgICAgICAgIC8vIFVzZSBqc2RlbGl2ciBmb3IgZ2l0aHViLCBhcyBnaXRodWIgZG9lcyBub3Qgc3VwcG9ydCBDb21taXQgc2hhcyBvciBDT1JTXG4gICAgICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gbWV0YS5uYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIGltcG9ydFVybCA9IFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9cIiArIG1ldGEubmFtZSArIFwiQFwiICsgbWV0YS52ZXJzaW9uICsgXCIvXCIgKyBtZXRhLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoaW1wb3J0VXJsKTtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgX190eXBlOiBcInJlYWR5XCIsIF9fdG9rZW46IG1ldGEuYXV0aFRva2VuIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW1wb3J0IG1vZHVsZVwiLCBlcnIpO1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyBfX3R5cGU6IFwiaW1wb3J0X2Vycm9yXCIsIF9fdG9rZW46IG1ldGEuYXV0aFRva2VuIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCB7fTtcblxuYCIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IFByb3ZpZGVyIGZyb20gXCJleHRlbnNpb25ydW5uZXJcIjtcblxubWFpbigpLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGUgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk1lc3NhZ2UgcmVjZWl2ZWQgOjpcIiwgZS5kYXRhKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb3YgPSBuZXcgUHJvdmlkZXIoeyBsb2dzOiB0cnVlIH0pO1xuICAgIGNvbnN0IGNvbW1pdFNoYSA9IFwiMGQwMTQ4ZDY1YTAwMzJkYWYxYzdhYzc3ZGI3MjZhYTRlYTAyMDMzOFwiO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGF3YWl0IHByb3YubG9hZEV4dGVuc2lvbih7XG4gICAgICAgIHR5cGU6IFwiZ2l0aHViXCIsXG4gICAgICAgIG5hbWU6IFwiYW5kcmUtaGN0dWxjL2V4dGVuc2lvbnJ1bm5lci10ZXN0LWV4dGVuc2lvblwiLFxuICAgICAgICB2ZXJzaW9uOiBjb21taXRTaGEsXG4gICAgICAgIG91dDoge1xuICAgICAgICAgICAgZWNobzogdGV4dCA9PiBhbGVydCh0ZXh0ICsgXCIgLi4uIFwiICsgdGV4dCArIFwiIC4uIC4gLiAgICAuXCIgKyB0ZXh0KSxcbiAgICAgICAgfSxcbiAgICAgICAgb25TdGF0ZVB1c2g6IChuZXdTdGF0ZSwgbW9kdWxlKSA9PiB7XG4gICAgICAgICAgICBhbGVydChcIlN0YXRlIFB1c2ggcmVjZWl2ZWQ6XCIsIG5ld1N0YXRlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKFwiRXh0ZW5zaW9uIGxvYWRlZDpcIiwgZXh0ZW5zaW9uKTtcblxuICAgIGNvbnN0IGluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9cIik7XG4gICAgaW5mby5pbm5lckhUTUwgPSBgVGVzdC1FeHRlbnNpb24gbG9hZGVkOiAke2V4dGVuc2lvbi5wa2cubmFtZX1AJHtleHRlbnNpb24ucGtnLnZlcnNpb259IFNIQSAke2NvbW1pdFNoYX1gO1xuXG4gICAgLy8gcHVzaFN0YXRlXG5cbiAgICBjb25zdCBzdGF0ZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdGVcIik7XG5cbiAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICBzdGF0ZUJ0bi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBleHRlbnNpb24ucHVzaFN0YXRlKHsgbWVzc2FnZTogXCJDb3VudGVyOiBcIiArICsrY291bnRlciB9KTtcbiAgICB9O1xuXG4gICAgLy8gbGF1bmNoXG5cbiAgICAvLyBsYXVuY2hNb2R1bGUoZXh0ZW5zaW9uKS5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihcIkVycm9yIGxhdW5jaGluZyBtb2R1bGVcIiwgZXJyKSk7XG4gICAgbGF1bmNoSUZyYW1lKGV4dGVuc2lvbikuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsYXVuY2hpbmcgaWZyYW1lXCIsIGVycikpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsYXVuY2hNb2R1bGUoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgbW9kdWxlID0gYXdhaXQgZXh0ZW5zaW9uLmxhdW5jaE1vZHVsZShcImRpc3QvbWF0aC5qc1wiKTtcblxuICAgIGNvbnNvbGUubG9nKFwiTW9kdWxlIGxvYWRlZDpcIiwgZXh0ZW5zaW9uKTtcblxuICAgIC8vIG1vZHVsZSBvcGVyYXRpb25zXG5cbiAgICBjb25zdCBldmVudEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXZlbnRcIik7XG4gICAgY29uc3Qgb3BlcmF0aW9uQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGVyYXRpb25cIik7XG5cbiAgICBldmVudEJ0bi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBleHRlbnNpb24uZW1pdEV2ZW50KFwiZ3JlZXRcIiwgXCJIZWxsbyB3b3JsZCFcIik7XG4gICAgfTtcblxuICAgIG9wZXJhdGlvbkJ0bi5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIW1vZHVsZSkgcmV0dXJuIGFsZXJ0KFwiTW9kdWxlIG5vdCBsb2FkZWRcIik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGF3YWl0IG1vZHVsZS5leGVjdXRlKFwiYWRkXCIsIDEsIDUpO1xuICAgICAgICBjb25zdCBkID0gYXdhaXQgbW9kdWxlLmV4ZWN1dGUoXCJzdWJzdHJhY3RcIiwgMTAsIDIpO1xuICAgICAgICBhbGVydChcIlN1bTogXCIgKyBzdW0gKyBcIiBTdWI6IFwiICsgZCk7XG4gICAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbGF1bmNoSUZyYW1lKGV4dGVuc2lvbikge1xuICAgIC8vIGlmcmFtZVxuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZnJhbWVcIik7XG5cbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IGlmcmFtZU1vZHVsZSA9IGF3YWl0IGV4dGVuc2lvbi5sYXVuY2hJRnJhbWUoY29udGFpbmVyLCBcImRpc3QvZnJhbWVzL2NvdW50ZXIvaW5kZXguaHRtbFwiLCB7fSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <button id="operation">Operation (add and substract)</button>
        <button id="state">Push state</button>
        <button id="event">Emit Event (shape_change)</button>
        <div id="iframe"></div>
    </body>
</html>
