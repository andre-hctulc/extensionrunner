<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var extensionrunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! extensionrunner */ "./node_modules/extensionrunner/index.js");
/* module decorator */ module = __webpack_require__.hmd(module);


async function main() {
    const prov = new extensionrunner__WEBPACK_IMPORTED_MODULE_0__["default"]({});
    const sha = "51438071198aab2643772a2bc1b169dcdb2ec005";
    const extension = await prov.loadExtension({
        type: "github",
        name: "andre-hctulc/extensionrunner-test-extension",
        version: sha,
        out: {
            echo: text => alert(text + " ... " + text + " .. . .    ." + text),
        },
        onStatePush: (newState, module) => {
            alert("State Push received:", newState);
        },
    });

    console.log("Extension loaded:", extension);

    const info = document.getElementById("info");
    info.innerHTML = `Test-Extension loaded: ${extension.pkg.name}@${extension.pkg.version} SHA ${sha}`;

    try {
        const module = await extension.launchModule("dist/math.js");
        console.log("Module loaded:", extension);
    } catch (e) {
        console.error(e);
    }

    const eventBtn = document.getElementById("event");
    const operationBtn = document.getElementById("operation");
    const stateBtn = document.getElementById("state");

    eventBtn.onclick = () => {
        extension.emitEvent("greet", "Hello world!");
    };

    operationBtn.onclick = async () => {
        const sum = await module.execute("add", 1, 5);
        const d = extension.execute("substract", 10, 2);
        alert("Sum: " + sum + " Sub: " + d);
    };

    // pushState

    let counter = 0;

    stateBtn.onclick = () => {
        extension.pushState({ message: "Counter: " + ++counter });
    };
}

main();
//main2();

function main2() {
    const worker = new Worker("worker.js");
    worker.postMessage({
        __type: "meta",
        meta: {
            type: "github",
            name: "andre-hctulc/extensionrunner-test-extension",
            version: "09edc7ea69cdb025a97b5cd25f27535d9c40bede",
            path: "dist/math.js",
        },
    });
    worker.onmessage = e => {
        if (e.data?.__type === "ready") {
            alert("Worker is ready");
            console.log("Worker is ready");
        }
    };
    worker.onerror = e => {
        console.error(e);
    };
}


/***/ }),

/***/ "./node_modules/extensionrunner/Extension.js":
/*!***************************************************!*\
  !*** ./node_modules/extensionrunner/Extension.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension)
/* harmony export */ });
/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Module.js */ "./node_modules/extensionrunner/Module.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "./node_modules/extensionrunner/shared.js");
/* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker.js */ "./node_modules/extensionrunner/worker.js");



class Extension extends _shared_js__WEBPACK_IMPORTED_MODULE_1__.Events {
    constructor(init) {
        super();
        this.init = init;
        this.url = "";
        this.staticParams = "";
        this._pkg = {};
        this.started = false;
        /** `<module_id, { instances: <Module, data>, sharedState: any }>` */
        this.cache = new Map();
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            this.url = `https://api.github.com/repos/${owner}/${repo}/contents/`;
            this.staticParams = `?ref=${init.version}`;
        }
        else if (this.type === "npm") {
            this.url = `https://unpkg.com/${this.init.name}@${this.init.version}/`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        // load meta (package.json)
        const file = await this.loadFile("package.json");
        const text = await file.text();
        this._pkg = JSON.parse(text);
    }
    /**
     * @param path Use _null_ or empty string for the packages entry file
     */
    async launchModule(path, out, meta) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.relPath)(path || "");
        /** The worker code is transformed to a string on build, so we can alwys import it here and start the worker */
        const workerCode = _worker_js__WEBPACK_IMPORTED_MODULE_2__.code;
        const blob = new Blob([workerCode], { type: "application/javascript" });
        const url = URL.createObjectURL(blob); // TODO revoke object url
        const worker_ = new Worker(url, { type: "module" });
        const mod = this.initModule(worker_, path, out, meta);
        return mod.start();
    }
    async launchIFrame(parentElement, path, out, meta) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.relPath)(path);
        // create iframe and append to parentElement
        const iframe = document.createElement("iframe");
        iframe.src = this.url + path;
        // wait for load
        return new Promise((resolve, reject) => {
            iframe.onload = async (e) => {
                if (!iframe.contentWindow)
                    return reject("`contentWindow`ndow not defined");
                const mod = this.initModule(iframe.contentWindow, path, out, meta);
                resolve(mod.start());
            };
            iframe.addEventListener("error", e => {
                reject(new Error(e.message));
            });
            parentElement.appendChild(iframe);
        });
    }
    initModule(target, path, out, meta) {
        const id = `iframe:${path}`;
        // extend meta
        let _meta = {
            name: this.init.name,
            path,
            state: this.cache.get(id)?.sharedState,
            version: this.init.version,
            type: this.init.type,
        };
        _meta = this.init.meta ? this.init.meta(_meta) : _meta;
        if (meta)
            _meta = meta(_meta);
        // create module
        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_0__.Module(target, _meta, out, {
            onPushState: (newState, populate) => {
                if (populate)
                    this.pushState(id, newState, undefined, [mod]);
                this.init.onPushState?.(newState, mod);
            },
            onEvent: (type, payload) => {
                this.notifyListeners?.(type, payload, mod);
            },
            operationTimeout: this.init.operationTimeout,
            connectionTimeout: this.init.connectionTimeout,
        });
        // cache
        let instances = this.cache.get(id)?.instances;
        if (!instances) {
            instances = new Map();
            this.cache.set(id, { instances, sharedState: undefined });
        }
        instances.set(mod, { state: undefined });
        return mod;
    }
    get id() {
        return this.init.type + "%" + this.init.name;
    }
    get pkg() {
        return this._pkg;
    }
    get type() {
        return this.init.type;
    }
    getUrl(path, searchParams) {
        if (searchParams)
            searchParams = this.staticParams ? this.staticParams + "&" + searchParams : searchParams;
        else
            searchParams = this.staticParams;
        return this.url + path + searchParams;
    }
    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */
    async loadFile(path) {
        if (path.startsWith("/"))
            path = path.slice(1);
        else if (path.startsWith("./"))
            path = path.slice(2);
        const response = await fetch(this.getUrl(path), this.type === "github" ? { headers: { Accept: "application/vnd.github.raw+json" } } : {});
        if (!response.ok) {
            const error = new Error(`Failed to load file: ${response.statusText}`);
            error.response = response;
            throw new Error(`Failed to load file: ${response.statusText}`);
        }
        return response;
    }
    pushState(moduleId, newState, instance, exclude) {
        const exclSet = new Set(exclude);
        const cache = this.cache.get(moduleId);
        if (cache) {
            if (instance) {
                if (!exclSet.has(instance))
                    instance.pushState(newState);
            }
            else {
                const modules = Array.from(cache.instances.keys());
                modules.forEach(instance => {
                    if (!exclSet.has(instance))
                        instance.pushState(newState);
                });
            }
        }
    }
    emitEvent(type, payload, filter) {
        for (const moduleId of this.cache.keys()) {
            const modules = Array.from(this.cache.get(moduleId)?.instances.keys() || []);
            modules.forEach(instance => {
                if (filter && !filter(moduleId, instance))
                    return;
                instance.emitEvent(type, payload);
            });
        }
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/Module.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/Module.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module)
/* harmony export */ });
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ "./node_modules/extensionrunner/shared.js");

/** Represents an iframe or a worker */
class Module {
    constructor(target, meta, out, options) {
        this.target = target;
        this.meta = meta;
        this.out = out;
        this.options = options;
    }
    async start() {
        return new Promise((resolve, reject) => {
            let resolved = false;
            // handle messages
            this.target.onmessage = async (e) => {
                console.log("MESG");
                if (typeof e?.data?.__type !== "string")
                    return;
                const type = e.data.__type;
                switch (type) {
                    case "state_push":
                        this._state = e.data.state;
                        this.options.onPushState?.(e.data.state, !!e.data.populate);
                        break;
                    case "event":
                        this.options.onEvent?.(e.data.event, e.data.args);
                        break;
                    case "operation":
                        const { args, operation, port } = e.data;
                        const op = await this.out[operation];
                        port.onmessageerror = e => {
                            this.err("Operation Channel Error", e);
                        };
                        if (typeof op !== "function")
                            return this.err("Operation not found", null);
                        try {
                            const result = await op(...args);
                            port.postMessage({ __type: "operation:result", payload: result });
                        }
                        catch (err) {
                            return this.err("Operation Execution Error", err);
                        }
                        break;
                    case "ready":
                        resolved = true;
                        // init postMessage (received by worker.ts or iframe)
                        const events = new MessageChannel();
                        const eventsIn = events.port1;
                        const eventsOut = events.port2;
                        eventsIn.onmessageerror = e => {
                            this.err("Events Channel (in) Error", e);
                        };
                        eventsOut.onmessageerror = e => {
                            this.err("Events Channel (out) Error", e);
                        };
                        resolve(this);
                        break;
                }
            };
            // errors
            this.target.onmessageerror = (e) => {
                this.err("Message Error", e);
            };
            this.target.onerror = (e) => {
                this.err("Uncaught Error", e);
            };
            // Post meta, so the worker knows which module to import (for workers)
            // iframes do not neccessarily need this
            this.target.postMessage({ __type: "meta", meta: this.meta });
            setTimeout(() => {
                if (!resolved)
                    reject(this.err("Connection timeout", null));
            }, this.options.connectionTimeout || 5000);
        });
    }
    get state() {
        return this._state;
    }
    err(info, event) {
        const msg = event instanceof Event ? (event.message || event.data || "").toString() : event instanceof Error ? event.message : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        this.options?.onError?.(err);
        return err;
    }
    postMessage(type, data, transfer) {
        if (this.target instanceof Worker)
            this.target.postMessage({ __type: type, ...data }, { transfer });
        else if (this.target)
            this.target.postMessage({ __type: type, ...data }, "*", transfer);
    }
    async execute(operation, ...args) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.receiveData)(this.target, "operation", { args, operation }, [], this.options.operationTimeout);
    }
    async emitEvent(type, payload) {
        this.postMessage("event", { event: type, args: payload });
    }
    async pushState(newState) {
        this.postMessage("state_push", { state: newState });
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/Provider.js":
/*!**************************************************!*\
  !*** ./node_modules/extensionrunner/Provider.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/extensionrunner/Extension.js");

class Provider {
    constructor(options) {
        this.options = options;
        this.cache = new Map();
    }
    async loadExtension(extensionInit) {
        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension(extensionInit);
        try {
            await extension.start();
        }
        catch (err) {
            throw new Error(`Failed to load extension: ${err}`);
        }
        this.cache.set(extension.id, extension);
        return extension;
    }
    allExtensions() {
        return Array.from(this.cache.values());
    }
    getExtension(id) {
        return this.cache.get(id) || null;
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/index.js":
/*!***********************************************!*\
  !*** ./node_modules/extensionrunner/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/extensionrunner/Extension.js");
/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ "./node_modules/extensionrunner/Provider.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);


/***/ }),

/***/ "./node_modules/extensionrunner/shared.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/shared.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Events: () => (/* binding */ Events),
/* harmony export */   getMessageData: () => (/* binding */ getMessageData),
/* harmony export */   receiveData: () => (/* binding */ receiveData),
/* harmony export */   relPath: () => (/* binding */ relPath)
/* harmony export */ });
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Events_listeners;
function relPath(path) {
    if (path.startsWith("./"))
        path = path.slice(2);
    else if (path.startsWith("/"))
        path = path.slice(1);
    return path;
}
function getMessageData(e, type) {
    if (e.data && typeof e.data === "object" && e.data.__type === type)
        return e.data;
    return null;
}
async function receiveData(target, messageType, data, transfer, errTimeout = 5000) {
    return new Promise((resolve, reject) => {
        const channel = new MessageChannel();
        const out = channel.port1;
        const in_ = channel.port2;
        let resolved = false;
        setTimeout(() => {
            if (!resolved)
                reject(new Error("Operation timeout"));
        }, errTimeout || 5000);
        in_.onmessage = async (e) => {
            const data = getMessageData(e, messageType + ":result");
            if (data) {
                resolved = true;
                resolve(data.payload);
            }
        };
        in_.onmessageerror = e => {
            reject(new Error("Channel Error (in)"));
        };
        out.onmessageerror = e => {
            reject(new Error("Channel Error (out)"));
        };
        if (target instanceof Worker)
            target.postMessage({ __type: messageType, ...data }, { transfer: [in_, ...transfer] });
        else
            target.postMessage({ __type: messageType, ...data }, "*", [in_, ...transfer]);
    });
}
class Events {
    constructor() {
        _Events_listeners.set(this, new Map());
    }
    addEventListener(type, listener) {
        if (!__classPrivateFieldGet(this, _Events_listeners, "f").has(type))
            __classPrivateFieldGet(this, _Events_listeners, "f").set(type, new Set());
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.add(listener);
    }
    removeEventListener(type, listener) {
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.delete(listener);
    }
    notifyListeners(type, ...args) {
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.forEach(listener => listener(...args));
    }
}
_Events_listeners = new WeakMap();


/***/ }),

/***/ "./node_modules/extensionrunner/worker.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/worker.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code)
/* harmony export */ });
const code=`
/*
Import the extension module from github or unpkg
*/
let started = false;
const isNonEmptyStr = (s) => !!s && typeof s === "string";
self.onmessage = async (e) => {
    if (started)
        return;
    started = true;
    // If init message
    if (e.data?.__type == "meta" && typeof e.data.meta === "object") {
        const meta = e.data.meta;
        // Check meta
        if (!isNonEmptyStr(meta.path))
            throw new Error("Invalid path");
        if (!isNonEmptyStr(meta.version))
            throw new Error("Invalid name");
        if (!isNonEmptyStr(meta.path))
            throw new Error("Invalid version");
        // set meta globally
        self.__meta = meta;
        // import module (for side effects - imported modules should use \`Adapter\`)
        let importUrl;
        // do not use template strings here, post build script wraps this code in \`\`
        if (meta.type === "npm") {
            importUrl = "https://unpkg.com/" + meta.name + "@" + meta.version + "/" + meta.path;
        }
        else if (meta.type === "github") {
            const [owner, repo] = meta.name.split("/");
            importUrl = "github:" + owner + "/" + repo + "@" + meta.version;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        const mod = await import(importUrl);
        postMessage({ __type: "ready" });
    }
};
export {};

`

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCLElBQUksOEJBQThCO0FBQ2pHO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRCxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMvRE87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBOzs7Ozs7VUN4Q0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3pCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTs7Ozs7V0NWQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0Ly4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvZXh0ZW5zaW9ucnVubmVyL0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4vbm9kZV9tb2R1bGVzL2V4dGVuc2lvbnJ1bm5lci9Nb2R1bGUuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9leHRlbnNpb25ydW5uZXIvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9leHRlbnNpb25ydW5uZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9leHRlbnNpb25ydW5uZXIvc2hhcmVkLmpzIiwid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvZXh0ZW5zaW9ucnVubmVyL3dvcmtlci5qcyIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL2hhcm1vbnkgbW9kdWxlIGRlY29yYXRvciIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJvdmlkZXIgZnJvbSBcImV4dGVuc2lvbnJ1bm5lclwiO1xuXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICAgIGNvbnN0IHByb3YgPSBuZXcgUHJvdmlkZXIoe30pO1xuICAgIGNvbnN0IHNoYSA9IFwiNTE0MzgwNzExOThhYWIyNjQzNzcyYTJiYzFiMTY5ZGNkYjJlYzAwNVwiO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGF3YWl0IHByb3YubG9hZEV4dGVuc2lvbih7XG4gICAgICAgIHR5cGU6IFwiZ2l0aHViXCIsXG4gICAgICAgIG5hbWU6IFwiYW5kcmUtaGN0dWxjL2V4dGVuc2lvbnJ1bm5lci10ZXN0LWV4dGVuc2lvblwiLFxuICAgICAgICB2ZXJzaW9uOiBzaGEsXG4gICAgICAgIG91dDoge1xuICAgICAgICAgICAgZWNobzogdGV4dCA9PiBhbGVydCh0ZXh0ICsgXCIgLi4uIFwiICsgdGV4dCArIFwiIC4uIC4gLiAgICAuXCIgKyB0ZXh0KSxcbiAgICAgICAgfSxcbiAgICAgICAgb25TdGF0ZVB1c2g6IChuZXdTdGF0ZSwgbW9kdWxlKSA9PiB7XG4gICAgICAgICAgICBhbGVydChcIlN0YXRlIFB1c2ggcmVjZWl2ZWQ6XCIsIG5ld1N0YXRlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKFwiRXh0ZW5zaW9uIGxvYWRlZDpcIiwgZXh0ZW5zaW9uKTtcblxuICAgIGNvbnN0IGluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9cIik7XG4gICAgaW5mby5pbm5lckhUTUwgPSBgVGVzdC1FeHRlbnNpb24gbG9hZGVkOiAke2V4dGVuc2lvbi5wa2cubmFtZX1AJHtleHRlbnNpb24ucGtnLnZlcnNpb259IFNIQSAke3NoYX1gO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gYXdhaXQgZXh0ZW5zaW9uLmxhdW5jaE1vZHVsZShcImRpc3QvbWF0aC5qc1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJNb2R1bGUgbG9hZGVkOlwiLCBleHRlbnNpb24pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBjb25zdCBldmVudEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXZlbnRcIik7XG4gICAgY29uc3Qgb3BlcmF0aW9uQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGVyYXRpb25cIik7XG4gICAgY29uc3Qgc3RhdGVCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRlXCIpO1xuXG4gICAgZXZlbnRCdG4ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgZXh0ZW5zaW9uLmVtaXRFdmVudChcImdyZWV0XCIsIFwiSGVsbG8gd29ybGQhXCIpO1xuICAgIH07XG5cbiAgICBvcGVyYXRpb25CdG4ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3VtID0gYXdhaXQgbW9kdWxlLmV4ZWN1dGUoXCJhZGRcIiwgMSwgNSk7XG4gICAgICAgIGNvbnN0IGQgPSBleHRlbnNpb24uZXhlY3V0ZShcInN1YnN0cmFjdFwiLCAxMCwgMik7XG4gICAgICAgIGFsZXJ0KFwiU3VtOiBcIiArIHN1bSArIFwiIFN1YjogXCIgKyBkKTtcbiAgICB9O1xuXG4gICAgLy8gcHVzaFN0YXRlXG5cbiAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICBzdGF0ZUJ0bi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBleHRlbnNpb24ucHVzaFN0YXRlKHsgbWVzc2FnZTogXCJDb3VudGVyOiBcIiArICsrY291bnRlciB9KTtcbiAgICB9O1xufVxuXG5tYWluKCk7XG4vL21haW4yKCk7XG5cbmZ1bmN0aW9uIG1haW4yKCkge1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoXCJ3b3JrZXIuanNcIik7XG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgX190eXBlOiBcIm1ldGFcIixcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgdHlwZTogXCJnaXRodWJcIixcbiAgICAgICAgICAgIG5hbWU6IFwiYW5kcmUtaGN0dWxjL2V4dGVuc2lvbnJ1bm5lci10ZXN0LWV4dGVuc2lvblwiLFxuICAgICAgICAgICAgdmVyc2lvbjogXCIwOWVkYzdlYTY5Y2RiMDI1YTk3YjVjZDI1ZjI3NTM1ZDljNDBiZWRlXCIsXG4gICAgICAgICAgICBwYXRoOiBcImRpc3QvbWF0aC5qc1wiLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBlID0+IHtcbiAgICAgICAgaWYgKGUuZGF0YT8uX190eXBlID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgIGFsZXJ0KFwiV29ya2VyIGlzIHJlYWR5XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXb3JrZXIgaXMgcmVhZHlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdvcmtlci5vbmVycm9yID0gZSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IE1vZHVsZSB9IGZyb20gXCIuL01vZHVsZS5qc1wiO1xuaW1wb3J0IHsgRXZlbnRzLCByZWxQYXRoIH0gZnJvbSBcIi4vc2hhcmVkLmpzXCI7XG5pbXBvcnQgKiBhcyB3b3JrZXIgZnJvbSBcIi4vd29ya2VyLmpzXCI7XG5leHBvcnQgY2xhc3MgRXh0ZW5zaW9uIGV4dGVuZHMgRXZlbnRzIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICAgICAgdGhpcy5zdGF0aWNQYXJhbXMgPSBcIlwiO1xuICAgICAgICB0aGlzLl9wa2cgPSB7fTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBgPG1vZHVsZV9pZCwgeyBpbnN0YW5jZXM6IDxNb2R1bGUsIGRhdGE+LCBzaGFyZWRTdGF0ZTogYW55IH0+YCAqL1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImdpdGh1YlwiKSB7XG4gICAgICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gdGhpcy5pbml0Lm5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgdGhpcy51cmwgPSBgaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy8ke293bmVyfS8ke3JlcG99L2NvbnRlbnRzL2A7XG4gICAgICAgICAgICB0aGlzLnN0YXRpY1BhcmFtcyA9IGA/cmVmPSR7aW5pdC52ZXJzaW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcIm5wbVwiKSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IGBodHRwczovL3VucGtnLmNvbS8ke3RoaXMuaW5pdC5uYW1lfUAke3RoaXMuaW5pdC52ZXJzaW9ufS9gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSAoJ25wbScgb3IgJ2dpdGh1YicgZXhwZWN0ZWQpXCIpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gbG9hZCBtZXRhIChwYWNrYWdlLmpzb24pXG4gICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmxvYWRGaWxlKFwicGFja2FnZS5qc29uXCIpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgZmlsZS50ZXh0KCk7XG4gICAgICAgIHRoaXMuX3BrZyA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXRoIFVzZSBfbnVsbF8gb3IgZW1wdHkgc3RyaW5nIGZvciB0aGUgcGFja2FnZXMgZW50cnkgZmlsZVxuICAgICAqL1xuICAgIGFzeW5jIGxhdW5jaE1vZHVsZShwYXRoLCBvdXQsIG1ldGEpIHtcbiAgICAgICAgcGF0aCA9IHJlbFBhdGgocGF0aCB8fCBcIlwiKTtcbiAgICAgICAgLyoqIFRoZSB3b3JrZXIgY29kZSBpcyB0cmFuc2Zvcm1lZCB0byBhIHN0cmluZyBvbiBidWlsZCwgc28gd2UgY2FuIGFsd3lzIGltcG9ydCBpdCBoZXJlIGFuZCBzdGFydCB0aGUgd29ya2VyICovXG4gICAgICAgIGNvbnN0IHdvcmtlckNvZGUgPSB3b3JrZXIuY29kZTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFt3b3JrZXJDb2RlXSwgeyB0eXBlOiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB9KTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTsgLy8gVE9ETyByZXZva2Ugb2JqZWN0IHVybFxuICAgICAgICBjb25zdCB3b3JrZXJfID0gbmV3IFdvcmtlcih1cmwsIHsgdHlwZTogXCJtb2R1bGVcIiB9KTtcbiAgICAgICAgY29uc3QgbW9kID0gdGhpcy5pbml0TW9kdWxlKHdvcmtlcl8sIHBhdGgsIG91dCwgbWV0YSk7XG4gICAgICAgIHJldHVybiBtb2Quc3RhcnQoKTtcbiAgICB9XG4gICAgYXN5bmMgbGF1bmNoSUZyYW1lKHBhcmVudEVsZW1lbnQsIHBhdGgsIG91dCwgbWV0YSkge1xuICAgICAgICBwYXRoID0gcmVsUGF0aChwYXRoKTtcbiAgICAgICAgLy8gY3JlYXRlIGlmcmFtZSBhbmQgYXBwZW5kIHRvIHBhcmVudEVsZW1lbnRcbiAgICAgICAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgaWZyYW1lLnNyYyA9IHRoaXMudXJsICsgcGF0aDtcbiAgICAgICAgLy8gd2FpdCBmb3IgbG9hZFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcImBjb250ZW50V2luZG93YG5kb3cgbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kID0gdGhpcy5pbml0TW9kdWxlKGlmcmFtZS5jb250ZW50V2luZG93LCBwYXRoLCBvdXQsIG1ldGEpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kLnN0YXJ0KCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdE1vZHVsZSh0YXJnZXQsIHBhdGgsIG91dCwgbWV0YSkge1xuICAgICAgICBjb25zdCBpZCA9IGBpZnJhbWU6JHtwYXRofWA7XG4gICAgICAgIC8vIGV4dGVuZCBtZXRhXG4gICAgICAgIGxldCBfbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuaW5pdC5uYW1lLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNhY2hlLmdldChpZCk/LnNoYXJlZFN0YXRlLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5pbml0LnZlcnNpb24sXG4gICAgICAgICAgICB0eXBlOiB0aGlzLmluaXQudHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgX21ldGEgPSB0aGlzLmluaXQubWV0YSA/IHRoaXMuaW5pdC5tZXRhKF9tZXRhKSA6IF9tZXRhO1xuICAgICAgICBpZiAobWV0YSlcbiAgICAgICAgICAgIF9tZXRhID0gbWV0YShfbWV0YSk7XG4gICAgICAgIC8vIGNyZWF0ZSBtb2R1bGVcbiAgICAgICAgY29uc3QgbW9kID0gbmV3IE1vZHVsZSh0YXJnZXQsIF9tZXRhLCBvdXQsIHtcbiAgICAgICAgICAgIG9uUHVzaFN0YXRlOiAobmV3U3RhdGUsIHBvcHVsYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShpZCwgbmV3U3RhdGUsIHVuZGVmaW5lZCwgW21vZF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5vblB1c2hTdGF0ZT8uKG5ld1N0YXRlLCBtb2QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXZlbnQ6ICh0eXBlLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnM/Lih0eXBlLCBwYXlsb2FkLCBtb2QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZXJhdGlvblRpbWVvdXQ6IHRoaXMuaW5pdC5vcGVyYXRpb25UaW1lb3V0LFxuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHRoaXMuaW5pdC5jb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNhY2hlXG4gICAgICAgIGxldCBpbnN0YW5jZXMgPSB0aGlzLmNhY2hlLmdldChpZCk/Lmluc3RhbmNlcztcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGlkLCB7IGluc3RhbmNlcywgc2hhcmVkU3RhdGU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZXMuc2V0KG1vZCwgeyBzdGF0ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICByZXR1cm4gbW9kO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQudHlwZSArIFwiJVwiICsgdGhpcy5pbml0Lm5hbWU7XG4gICAgfVxuICAgIGdldCBwa2coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wa2c7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0LnR5cGU7XG4gICAgfVxuICAgIGdldFVybChwYXRoLCBzZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgaWYgKHNlYXJjaFBhcmFtcylcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcyA9IHRoaXMuc3RhdGljUGFyYW1zID8gdGhpcy5zdGF0aWNQYXJhbXMgKyBcIiZcIiArIHNlYXJjaFBhcmFtcyA6IHNlYXJjaFBhcmFtcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zID0gdGhpcy5zdGF0aWNQYXJhbXM7XG4gICAgICAgIHJldHVybiB0aGlzLnVybCArIHBhdGggKyBzZWFyY2hQYXJhbXM7XG4gICAgfVxuICAgIC8qKiBJZiB0aGUgcmVzcG9uc2UgaXMgbm90IG9rLCB0aGUgYFJlc3BvbnNlYCB3aWxsIGJlIHNldCBvbiB0aGUgdGhyb3duIGVycm9yIChgRXJyb3IucmVzcG9uc2VgKSAqL1xuICAgIGFzeW5jIGxvYWRGaWxlKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgZWxzZSBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikpXG4gICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmdldFVybChwYXRoKSwgdGhpcy50eXBlID09PSBcImdpdGh1YlwiID8geyBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnJhdytqc29uXCIgfSB9IDoge30pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgZmlsZTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgZmlsZTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgcHVzaFN0YXRlKG1vZHVsZUlkLCBuZXdTdGF0ZSwgaW5zdGFuY2UsIGV4Y2x1ZGUpIHtcbiAgICAgICAgY29uc3QgZXhjbFNldCA9IG5ldyBTZXQoZXhjbHVkZSk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZS5nZXQobW9kdWxlSWQpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghZXhjbFNldC5oYXMoaW5zdGFuY2UpKVxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5wdXNoU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlcyA9IEFycmF5LmZyb20oY2FjaGUuaW5zdGFuY2VzLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgbW9kdWxlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGNsU2V0LmhhcyhpbnN0YW5jZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5wdXNoU3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVtaXRFdmVudCh0eXBlLCBwYXlsb2FkLCBmaWx0ZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGVJZCBvZiB0aGlzLmNhY2hlLmtleXMoKSkge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlcyA9IEFycmF5LmZyb20odGhpcy5jYWNoZS5nZXQobW9kdWxlSWQpPy5pbnN0YW5jZXMua2V5cygpIHx8IFtdKTtcbiAgICAgICAgICAgIG1vZHVsZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyKG1vZHVsZUlkLCBpbnN0YW5jZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5lbWl0RXZlbnQodHlwZSwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHJlY2VpdmVEYXRhIH0gZnJvbSBcIi4vc2hhcmVkLmpzXCI7XG4vKiogUmVwcmVzZW50cyBhbiBpZnJhbWUgb3IgYSB3b3JrZXIgKi9cbmV4cG9ydCBjbGFzcyBNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbWV0YSwgb3V0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtZXNzYWdlc1xuICAgICAgICAgICAgdGhpcy50YXJnZXQub25tZXNzYWdlID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk1FU0dcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlPy5kYXRhPy5fX3R5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZS5kYXRhLl9fdHlwZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXRlX3B1c2hcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gZS5kYXRhLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uUHVzaFN0YXRlPy4oZS5kYXRhLnN0YXRlLCAhIWUuZGF0YS5wb3B1bGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25FdmVudD8uKGUuZGF0YS5ldmVudCwgZS5kYXRhLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXJncywgb3BlcmF0aW9uLCBwb3J0IH0gPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcCA9IGF3YWl0IHRoaXMub3V0W29wZXJhdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0Lm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnIoXCJPcGVyYXRpb24gQ2hhbm5lbCBFcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyKFwiT3BlcmF0aW9uIG5vdCBmb3VuZFwiLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3AoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZSh7IF9fdHlwZTogXCJvcGVyYXRpb246cmVzdWx0XCIsIHBheWxvYWQ6IHJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnIoXCJPcGVyYXRpb24gRXhlY3V0aW9uIEVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0IHBvc3RNZXNzYWdlIChyZWNlaXZlZCBieSB3b3JrZXIudHMgb3IgaWZyYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHNJbiA9IGV2ZW50cy5wb3J0MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50c091dCA9IGV2ZW50cy5wb3J0MjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c0luLm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnIoXCJFdmVudHMgQ2hhbm5lbCAoaW4pIEVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c091dC5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyKFwiRXZlbnRzIENoYW5uZWwgKG91dCkgRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBlcnJvcnNcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0Lm9ubWVzc2FnZWVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycihcIk1lc3NhZ2UgRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy50YXJnZXQub25lcnJvciA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnIoXCJVbmNhdWdodCBFcnJvclwiLCBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBQb3N0IG1ldGEsIHNvIHRoZSB3b3JrZXIga25vd3Mgd2hpY2ggbW9kdWxlIHRvIGltcG9ydCAoZm9yIHdvcmtlcnMpXG4gICAgICAgICAgICAvLyBpZnJhbWVzIGRvIG5vdCBuZWNjZXNzYXJpbHkgbmVlZCB0aGlzXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZSh7IF9fdHlwZTogXCJtZXRhXCIsIG1ldGE6IHRoaXMubWV0YSB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmVycihcIkNvbm5lY3Rpb24gdGltZW91dFwiLCBudWxsKSk7XG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgZXJyKGluZm8sIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGV2ZW50IGluc3RhbmNlb2YgRXZlbnQgPyAoZXZlbnQubWVzc2FnZSB8fCBldmVudC5kYXRhIHx8IFwiXCIpLnRvU3RyaW5nKCkgOiBldmVudCBpbnN0YW5jZW9mIEVycm9yID8gZXZlbnQubWVzc2FnZSA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgJHtpbmZvfSR7bXNnID8gXCI6IFwiICsgbXNnIDogXCJcIn1gKTtcbiAgICAgICAgdGhpcy5vcHRpb25zPy5vbkVycm9yPy4oZXJyKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgcG9zdE1lc3NhZ2UodHlwZSwgZGF0YSwgdHJhbnNmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgV29ya2VyKVxuICAgICAgICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IHR5cGUsIC4uLmRhdGEgfSwgeyB0cmFuc2ZlciB9KTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXQpXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5wb3N0TWVzc2FnZSh7IF9fdHlwZTogdHlwZSwgLi4uZGF0YSB9LCBcIipcIiwgdHJhbnNmZXIpO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlKG9wZXJhdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVjZWl2ZURhdGEodGhpcy50YXJnZXQsIFwib3BlcmF0aW9uXCIsIHsgYXJncywgb3BlcmF0aW9uIH0sIFtdLCB0aGlzLm9wdGlvbnMub3BlcmF0aW9uVGltZW91dCk7XG4gICAgfVxuICAgIGFzeW5jIGVtaXRFdmVudCh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2UoXCJldmVudFwiLCB7IGV2ZW50OiB0eXBlLCBhcmdzOiBwYXlsb2FkIH0pO1xuICAgIH1cbiAgICBhc3luYyBwdXNoU3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZShcInN0YXRlX3B1c2hcIiwgeyBzdGF0ZTogbmV3U3RhdGUgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIi4vRXh0ZW5zaW9uLmpzXCI7XG5leHBvcnQgY2xhc3MgUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZEV4dGVuc2lvbihleHRlbnNpb25Jbml0KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBFeHRlbnNpb24oZXh0ZW5zaW9uSW5pdCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBleHRlbnNpb24uc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGV4dGVuc2lvbjogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoZXh0ZW5zaW9uLmlkLCBleHRlbnNpb24pO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBhbGxFeHRlbnNpb25zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLnZhbHVlcygpKTtcbiAgICB9XG4gICAgZ2V0RXh0ZW5zaW9uKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChpZCkgfHwgbnVsbDtcbiAgICB9XG59XG4iLCJleHBvcnQgeyBFeHRlbnNpb24gfSBmcm9tIFwiLi9FeHRlbnNpb24uanNcIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcIi4vUHJvdmlkZXIuanNcIjtcbmV4cG9ydCBkZWZhdWx0IFByb3ZpZGVyO1xuIiwidmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0V2ZW50c19saXN0ZW5lcnM7XG5leHBvcnQgZnVuY3Rpb24gcmVsUGF0aChwYXRoKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKVxuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICBlbHNlIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKVxuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcbiAgICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXNzYWdlRGF0YShlLCB0eXBlKSB7XG4gICAgaWYgKGUuZGF0YSAmJiB0eXBlb2YgZS5kYXRhID09PSBcIm9iamVjdFwiICYmIGUuZGF0YS5fX3R5cGUgPT09IHR5cGUpXG4gICAgICAgIHJldHVybiBlLmRhdGE7XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjZWl2ZURhdGEodGFyZ2V0LCBtZXNzYWdlVHlwZSwgZGF0YSwgdHJhbnNmZXIsIGVyclRpbWVvdXQgPSA1MDAwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjb25zdCBvdXQgPSBjaGFubmVsLnBvcnQxO1xuICAgICAgICBjb25zdCBpbl8gPSBjaGFubmVsLnBvcnQyO1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJPcGVyYXRpb24gdGltZW91dFwiKSk7XG4gICAgICAgIH0sIGVyclRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIGluXy5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldE1lc3NhZ2VEYXRhKGUsIG1lc3NhZ2VUeXBlICsgXCI6cmVzdWx0XCIpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhLnBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpbl8ub25tZXNzYWdlZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDaGFubmVsIEVycm9yIChpbilcIikpO1xuICAgICAgICB9O1xuICAgICAgICBvdXQub25tZXNzYWdlZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDaGFubmVsIEVycm9yIChvdXQpXCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFdvcmtlcilcbiAgICAgICAgICAgIHRhcmdldC5wb3N0TWVzc2FnZSh7IF9fdHlwZTogbWVzc2FnZVR5cGUsIC4uLmRhdGEgfSwgeyB0cmFuc2ZlcjogW2luXywgLi4udHJhbnNmZXJdIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IG1lc3NhZ2VUeXBlLCAuLi5kYXRhIH0sIFwiKlwiLCBbaW5fLCAuLi50cmFuc2Zlcl0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIEV2ZW50cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIF9FdmVudHNfbGlzdGVuZXJzLnNldCh0aGlzLCBuZXcgTWFwKCkpO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzX2xpc3RlbmVycywgXCJmXCIpLmhhcyh0eXBlKSlcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c19saXN0ZW5lcnMsIFwiZlwiKS5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uYWRkKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNfbGlzdGVuZXJzLCBcImZcIikuZ2V0KHR5cGUpPy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgICBub3RpZnlMaXN0ZW5lcnModHlwZSwgLi4uYXJncykge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNfbGlzdGVuZXJzLCBcImZcIikuZ2V0KHR5cGUpPy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgICB9XG59XG5fRXZlbnRzX2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG4iLCJleHBvcnQgY29uc3QgY29kZT1gXG4vKlxuSW1wb3J0IHRoZSBleHRlbnNpb24gbW9kdWxlIGZyb20gZ2l0aHViIG9yIHVucGtnXG4qL1xubGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbmNvbnN0IGlzTm9uRW1wdHlTdHIgPSAocykgPT4gISFzICYmIHR5cGVvZiBzID09PSBcInN0cmluZ1wiO1xuc2VsZi5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgIGlmIChzdGFydGVkKVxuICAgICAgICByZXR1cm47XG4gICAgc3RhcnRlZCA9IHRydWU7XG4gICAgLy8gSWYgaW5pdCBtZXNzYWdlXG4gICAgaWYgKGUuZGF0YT8uX190eXBlID09IFwibWV0YVwiICYmIHR5cGVvZiBlLmRhdGEubWV0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBtZXRhID0gZS5kYXRhLm1ldGE7XG4gICAgICAgIC8vIENoZWNrIG1ldGFcbiAgICAgICAgaWYgKCFpc05vbkVtcHR5U3RyKG1ldGEucGF0aCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhdGhcIik7XG4gICAgICAgIGlmICghaXNOb25FbXB0eVN0cihtZXRhLnZlcnNpb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuYW1lXCIpO1xuICAgICAgICBpZiAoIWlzTm9uRW1wdHlTdHIobWV0YS5wYXRoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvblwiKTtcbiAgICAgICAgLy8gc2V0IG1ldGEgZ2xvYmFsbHlcbiAgICAgICAgc2VsZi5fX21ldGEgPSBtZXRhO1xuICAgICAgICAvLyBpbXBvcnQgbW9kdWxlIChmb3Igc2lkZSBlZmZlY3RzIC0gaW1wb3J0ZWQgbW9kdWxlcyBzaG91bGQgdXNlIFxcYEFkYXB0ZXJcXGApXG4gICAgICAgIGxldCBpbXBvcnRVcmw7XG4gICAgICAgIC8vIGRvIG5vdCB1c2UgdGVtcGxhdGUgc3RyaW5ncyBoZXJlLCBwb3N0IGJ1aWxkIHNjcmlwdCB3cmFwcyB0aGlzIGNvZGUgaW4gXFxgXFxgXG4gICAgICAgIGlmIChtZXRhLnR5cGUgPT09IFwibnBtXCIpIHtcbiAgICAgICAgICAgIGltcG9ydFVybCA9IFwiaHR0cHM6Ly91bnBrZy5jb20vXCIgKyBtZXRhLm5hbWUgKyBcIkBcIiArIG1ldGEudmVyc2lvbiArIFwiL1wiICsgbWV0YS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1ldGEudHlwZSA9PT0gXCJnaXRodWJcIikge1xuICAgICAgICAgICAgY29uc3QgW293bmVyLCByZXBvXSA9IG1ldGEubmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICBpbXBvcnRVcmwgPSBcImdpdGh1YjpcIiArIG93bmVyICsgXCIvXCIgKyByZXBvICsgXCJAXCIgKyBtZXRhLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgICAgIGNvbnN0IG1vZCA9IGF3YWl0IGltcG9ydChpbXBvcnRVcmwpO1xuICAgICAgICBwb3N0TWVzc2FnZSh7IF9fdHlwZTogXCJyZWFkeVwiIH0pO1xuICAgIH1cbn07XG5leHBvcnQge307XG5cbmAiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmhtZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlID0gT2JqZWN0LmNyZWF0ZShtb2R1bGUpO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0c2V0OiAoKSA9PiB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VTIE1vZHVsZXMgbWF5IG5vdCBhc3NpZ24gbW9kdWxlLmV4cG9ydHMgb3IgZXhwb3J0cy4qLCBVc2UgRVNNIGV4cG9ydCBzeW50YXgsIGluc3RlYWQ6ICcgKyBtb2R1bGUuaWQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <button id="operation">Operation (add and substract)</button>
        <button id="state">Push state</button>
        <button id="event">Emit Event (shape_change)</button>
    </body>
</html>
