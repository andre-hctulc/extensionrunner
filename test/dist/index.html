<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var extensionrunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! extensionrunner */ "./node_modules/extensionrunner/index.js");
/* module decorator */ module = __webpack_require__.hmd(module);


async function main() {
    const prov = new extensionrunner__WEBPACK_IMPORTED_MODULE_0__["default"]({});
    const sha = "51438071198aab2643772a2bc1b169dcdb2ec005";
    const extension = await prov.loadExtension({
        type: "github",
        name: "andre-hctulc/extensionrunner-test-extension",
        version: sha,
        out: {
            echo: text => alert(text + " ... " + text + " .. . .    ." + text),
        },
        onStatePush: (newState, module) => {
            alert("State Push received:", newState);
        },
    });

    console.log("Extension loaded:", extension);

    const info = document.getElementById("info");
    info.innerHTML = `Test-Extension loaded: ${extension.pkg.name}@${extension.pkg.version} SHA ${sha}`;

    try {
        const module = await extension.launchModule("dist/math.js");
        console.log("Module loaded:", extension);
    } catch (e) {
        console.error(e);
    }

    const eventBtn = document.getElementById("event");
    const operationBtn = document.getElementById("operation");
    const stateBtn = document.getElementById("state");

    eventBtn.onclick = () => {
        extension.emitEvent("greet", "Hello world!");
    };

    operationBtn.onclick = async () => {
        const sum = await module.execute("add", 1, 5);
        const d = extension.execute("substract", 10, 2);
        alert("Sum: " + sum + " Sub: " + d);
    };

    // pushState

    let counter = 0;

    stateBtn.onclick = () => {
        extension.pushState({ message: "Counter: " + ++counter });
    };
}

main();
//main2();

function main2() {
    const worker = new Worker("worker.js");
    worker.postMessage({
        __type: "meta",
        meta: {
            type: "github",
            name: "andre-hctulc/extensionrunner-test-extension",
            version: "09edc7ea69cdb025a97b5cd25f27535d9c40bede",
            path: "dist/math.js",
        },
    });
    worker.onmessage = e => {
        if (e.data?.__type === "ready") {
            alert("Worker is ready");
            console.log("Worker is ready");
        }
    };
    worker.onerror = e => {
        console.error(e);
    };
}


/***/ }),

/***/ "./node_modules/extensionrunner/Extension.js":
/*!***************************************************!*\
  !*** ./node_modules/extensionrunner/Extension.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension)
/* harmony export */ });
/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Module.js */ "./node_modules/extensionrunner/Module.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "./node_modules/extensionrunner/shared.js");
/* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./worker.js */ "./node_modules/extensionrunner/worker.js");



class Extension extends _shared_js__WEBPACK_IMPORTED_MODULE_1__.Events {
    constructor(init) {
        super();
        this.init = init;
        this.url = "";
        this.staticParams = "";
        this._pkg = {};
        this.started = false;
        /** `<module_id, { instances: <Module, data>, sharedState: any }>` */
        this.cache = new Map();
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            this.url = `https://api.github.com/repos/${owner}/${repo}/contents/`;
            this.staticParams = `?ref=${init.version}`;
        }
        else if (this.type === "npm") {
            this.url = `https://unpkg.com/${this.init.name}@${this.init.version}/`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        // load meta (package.json)
        const file = await this.loadFile("package.json");
        const text = await file.text();
        this._pkg = JSON.parse(text);
    }
    /**
     * @param path Use _null_ or empty string for the packages entry file
     */
    async launchModule(path, out, meta) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.relPath)(path || "");
        /** The worker code is transformed to a string on build, so we can alwys import it here and start the worker */
        const workerCode = _worker_js__WEBPACK_IMPORTED_MODULE_2__.code;
        const blob = new Blob([workerCode], { type: "module" });
        const url = URL.createObjectURL(blob); // TODO revoke object url
        const worker_ = new Worker(url);
        const mod = this.initModule(worker_, path, out, meta);
        return mod.start();
    }
    async launchIFrame(parentElement, path, out, meta) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.relPath)(path);
        // create iframe and append to parentElement
        const iframe = document.createElement("iframe");
        iframe.src = this.url + path;
        // wait for load
        return new Promise((resolve, reject) => {
            iframe.onload = async (e) => {
                if (!iframe.contentWindow)
                    return reject("`contentWindow`ndow not defined");
                const mod = this.initModule(iframe.contentWindow, path, out, meta);
                resolve(mod.start());
            };
            iframe.addEventListener("error", e => {
                reject(new Error(e.message));
            });
            parentElement.appendChild(iframe);
        });
    }
    initModule(target, path, out, meta) {
        const id = `iframe:${path}`;
        // extend meta
        let _meta = {
            name: this.init.name,
            path,
            state: this.cache.get(id)?.sharedState,
            version: this.init.version,
            type: this.init.type,
        };
        _meta = this.init.meta ? this.init.meta(_meta) : _meta;
        if (meta)
            _meta = meta(_meta);
        // create module
        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_0__.Module(target, _meta, out, {
            onPushState: (newState, populate) => {
                if (populate)
                    this.pushState(id, newState, undefined, [mod]);
                this.init.onPushState?.(newState, mod);
            },
            onEvent: (type, payload) => {
                this.notifyListeners?.(type, payload, mod);
            },
            operationTimeout: this.init.operationTimeout,
            connectionTimeout: this.init.connectionTimeout,
        });
        // cache
        let instances = this.cache.get(id)?.instances;
        if (!instances) {
            instances = new Map();
            this.cache.set(id, { instances, sharedState: undefined });
        }
        instances.set(mod, { state: undefined });
        return mod;
    }
    get id() {
        return this.init.type + "%" + this.init.name;
    }
    get pkg() {
        return this._pkg;
    }
    get type() {
        return this.init.type;
    }
    getUrl(path, searchParams) {
        if (searchParams)
            searchParams = this.staticParams ? this.staticParams + "&" + searchParams : searchParams;
        else
            searchParams = this.staticParams;
        return this.url + path + searchParams;
    }
    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */
    async loadFile(path) {
        if (path.startsWith("/"))
            path = path.slice(1);
        else if (path.startsWith("./"))
            path = path.slice(2);
        const response = await fetch(this.getUrl(path), this.type === "github" ? { headers: { Accept: "application/vnd.github.raw+json" } } : {});
        if (!response.ok) {
            const error = new Error(`Failed to load file: ${response.statusText}`);
            error.response = response;
            throw new Error(`Failed to load file: ${response.statusText}`);
        }
        return response;
    }
    pushState(moduleId, newState, instance, exclude) {
        const exclSet = new Set(exclude);
        const cache = this.cache.get(moduleId);
        if (cache) {
            if (instance) {
                if (!exclSet.has(instance))
                    instance.pushState(newState);
            }
            else {
                const modules = Array.from(cache.instances.keys());
                modules.forEach(instance => {
                    if (!exclSet.has(instance))
                        instance.pushState(newState);
                });
            }
        }
    }
    emitEvent(type, payload, filter) {
        for (const moduleId of this.cache.keys()) {
            const modules = Array.from(this.cache.get(moduleId)?.instances.keys() || []);
            modules.forEach(instance => {
                if (filter && !filter(moduleId, instance))
                    return;
                instance.emitEvent(type, payload);
            });
        }
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/Module.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/Module.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module)
/* harmony export */ });
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ "./node_modules/extensionrunner/shared.js");

/** Represents an iframe or a worker */
class Module {
    constructor(target, meta, out, options) {
        this.target = target;
        this.meta = meta;
        this.out = out;
        this.options = options;
    }
    async start() {
        return new Promise((resolve, reject) => {
            let resolved = false;
            // handle messages
            this.target.onmessage = async (e) => {
                console.log("MESG");
                if (typeof e?.data?.__type !== "string")
                    return;
                const type = e.data.__type;
                switch (type) {
                    case "state_push":
                        this._state = e.data.state;
                        this.options.onPushState?.(e.data.state, !!e.data.populate);
                        break;
                    case "event":
                        this.options.onEvent?.(e.data.event, e.data.args);
                        break;
                    case "operation":
                        const { args, operation, port } = e.data;
                        const op = await this.out[operation];
                        port.onmessageerror = e => {
                            this.err("Operation Channel Error", e);
                        };
                        if (typeof op !== "function")
                            return this.err("Operation not found", null);
                        try {
                            const result = await op(...args);
                            port.postMessage({ __type: "operation:result", payload: result });
                        }
                        catch (err) {
                            return this.err("Operation Execution Error", err);
                        }
                        break;
                    case "ready":
                        resolved = true;
                        // init postMessage (received by worker.ts or iframe)
                        const events = new MessageChannel();
                        const eventsIn = events.port1;
                        const eventsOut = events.port2;
                        eventsIn.onmessageerror = e => {
                            this.err("Events Channel (in) Error", e);
                        };
                        eventsOut.onmessageerror = e => {
                            this.err("Events Channel (out) Error", e);
                        };
                        resolve(this);
                        break;
                }
            };
            // errors
            this.target.onmessageerror = (e) => {
                this.err("Message Error", e);
            };
            this.target.onerror = (e) => {
                if (!resolved) {
                    resolved = true;
                    reject(this.err("Initialization Error", e));
                }
                else
                    this.err("Uncaught Error", e);
            };
            // Post meta, so the worker knows which module to import (for workers)
            // iframes do not neccessarily need this
            this.target.postMessage({ __type: "meta", meta: this.meta });
            setTimeout(() => {
                if (!resolved)
                    reject(this.err("Connection timeout", null));
            }, this.options.connectionTimeout || 5000);
        });
    }
    get state() {
        return this._state;
    }
    err(info, event) {
        const msg = event instanceof Event ? (event.message || event.data || "").toString() : event instanceof Error ? event.message : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        this.options?.onError?.(err);
        return err;
    }
    postMessage(type, data, transfer) {
        if (this.target instanceof Worker)
            this.target.postMessage({ __type: type, ...data }, { transfer });
        else if (this.target)
            this.target.postMessage({ __type: type, ...data }, "*", transfer);
    }
    async execute(operation, ...args) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.receiveData)(this.target, "operation", { args, operation }, [], this.options.operationTimeout);
    }
    async emitEvent(type, payload) {
        this.postMessage("event", { event: type, args: payload });
    }
    async pushState(newState) {
        this.postMessage("state_push", { state: newState });
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/Provider.js":
/*!**************************************************!*\
  !*** ./node_modules/extensionrunner/Provider.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/extensionrunner/Extension.js");

class Provider {
    constructor(options) {
        this.options = options;
        this.cache = new Map();
    }
    async loadExtension(extensionInit) {
        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension(extensionInit);
        try {
            await extension.start();
        }
        catch (err) {
            throw new Error(`Failed to load extension: ${err}`);
        }
        this.cache.set(extension.id, extension);
        return extension;
    }
    allExtensions() {
        return Array.from(this.cache.values());
    }
    getExtension(id) {
        return this.cache.get(id) || null;
    }
}


/***/ }),

/***/ "./node_modules/extensionrunner/index.js":
/*!***********************************************!*\
  !*** ./node_modules/extensionrunner/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "./node_modules/extensionrunner/Extension.js");
/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ "./node_modules/extensionrunner/Provider.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);


/***/ }),

/***/ "./node_modules/extensionrunner/shared.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/shared.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Events: () => (/* binding */ Events),
/* harmony export */   getMessageData: () => (/* binding */ getMessageData),
/* harmony export */   receiveData: () => (/* binding */ receiveData),
/* harmony export */   relPath: () => (/* binding */ relPath)
/* harmony export */ });
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Events_listeners;
function relPath(path) {
    if (path.startsWith("./"))
        path = path.slice(2);
    else if (path.startsWith("/"))
        path = path.slice(1);
    return path;
}
function getMessageData(e, type) {
    if (e.data && typeof e.data === "object" && e.data.__type === type)
        return e.data;
    return null;
}
async function receiveData(target, messageType, data, transfer, errTimeout = 5000) {
    return new Promise((resolve, reject) => {
        const channel = new MessageChannel();
        const out = channel.port1;
        const in_ = channel.port2;
        let resolved = false;
        setTimeout(() => {
            if (!resolved)
                reject(new Error("Operation timeout"));
        }, errTimeout || 5000);
        in_.onmessage = async (e) => {
            const data = getMessageData(e, messageType + ":result");
            if (data) {
                resolved = true;
                resolve(data.payload);
            }
        };
        in_.onmessageerror = e => {
            reject(new Error("Channel Error (in)"));
        };
        out.onmessageerror = e => {
            reject(new Error("Channel Error (out)"));
        };
        if (target instanceof Worker)
            target.postMessage({ __type: messageType, ...data }, { transfer: [in_, ...transfer] });
        else
            target.postMessage({ __type: messageType, ...data }, "*", [in_, ...transfer]);
    });
}
class Events {
    constructor() {
        _Events_listeners.set(this, new Map());
    }
    addEventListener(type, listener) {
        if (!__classPrivateFieldGet(this, _Events_listeners, "f").has(type))
            __classPrivateFieldGet(this, _Events_listeners, "f").set(type, new Set());
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.add(listener);
    }
    removeEventListener(type, listener) {
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.delete(listener);
    }
    notifyListeners(type, ...args) {
        __classPrivateFieldGet(this, _Events_listeners, "f").get(type)?.forEach(listener => listener(...args));
    }
}
_Events_listeners = new WeakMap();


/***/ }),

/***/ "./node_modules/extensionrunner/worker.js":
/*!************************************************!*\
  !*** ./node_modules/extensionrunner/worker.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   code: () => (/* binding */ code)
/* harmony export */ });
const code=`
/*
Import the extension module from github or unpkg
*/
let started = false;
const isNonEmptyStr = (s) => !!s && typeof s === "string";
self.onmessage = async (e) => {
    if (started)
        return;
    started = true;
    // If init message
    if (e.data?.__type == "meta" && typeof e.data.meta === "object") {
        const meta = e.data.meta;
        // Check meta
        if (!isNonEmptyStr(meta.path))
            throw new Error("Invalid path");
        if (!isNonEmptyStr(meta.version))
            throw new Error("Invalid name");
        if (!isNonEmptyStr(meta.path))
            throw new Error("Invalid version");
        // set meta globally
        self.__meta = meta;
        // import module (for side effects - imported modules should use \`Adapter\`)
        let importUrl;
        // do not use template strings here, post build script wraps this code in \`\`
        if (meta.type === "npm") {
            importUrl = "https://unpkg.com/" + meta.name + "@" + meta.version + "/" + meta.path;
        }
        else if (meta.type === "github") {
            const [owner, repo] = meta.name.split("/");
            importUrl = "github:" + owner + "/" + repo + "@" + meta.version;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        const mod = await import(importUrl);
        postMessage({ __type: "ready" });
    }
};
export {};

`

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhCQUE4QixJQUFJLDhCQUE4QjtBQUNqRztBQUNBLGlDQUFpQyw4QkFBOEI7QUFDL0QsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDL0RPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O1VDeENBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N6QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7Ozs7O1dDVkE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztVRU5BO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4vbm9kZV9tb2R1bGVzL2V4dGVuc2lvbnJ1bm5lci9FeHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9leHRlbnNpb25ydW5uZXIvTW9kdWxlLmpzIiwid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvZXh0ZW5zaW9ucnVubmVyL1Byb3ZpZGVyLmpzIiwid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvZXh0ZW5zaW9ucnVubmVyL2luZGV4LmpzIiwid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvZXh0ZW5zaW9ucnVubmVyL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4vbm9kZV9tb2R1bGVzL2V4dGVuc2lvbnJ1bm5lci93b3JrZXIuanMiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9oYXJtb255IG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb3ZpZGVyIGZyb20gXCJleHRlbnNpb25ydW5uZXJcIjtcblxuYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAgICBjb25zdCBwcm92ID0gbmV3IFByb3ZpZGVyKHt9KTtcbiAgICBjb25zdCBzaGEgPSBcIjUxNDM4MDcxMTk4YWFiMjY0Mzc3MmEyYmMxYjE2OWRjZGIyZWMwMDVcIjtcbiAgICBjb25zdCBleHRlbnNpb24gPSBhd2FpdCBwcm92LmxvYWRFeHRlbnNpb24oe1xuICAgICAgICB0eXBlOiBcImdpdGh1YlwiLFxuICAgICAgICBuYW1lOiBcImFuZHJlLWhjdHVsYy9leHRlbnNpb25ydW5uZXItdGVzdC1leHRlbnNpb25cIixcbiAgICAgICAgdmVyc2lvbjogc2hhLFxuICAgICAgICBvdXQ6IHtcbiAgICAgICAgICAgIGVjaG86IHRleHQgPT4gYWxlcnQodGV4dCArIFwiIC4uLiBcIiArIHRleHQgKyBcIiAuLiAuIC4gICAgLlwiICsgdGV4dCksXG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RhdGVQdXNoOiAobmV3U3RhdGUsIG1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgYWxlcnQoXCJTdGF0ZSBQdXNoIHJlY2VpdmVkOlwiLCBuZXdTdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhcIkV4dGVuc2lvbiBsb2FkZWQ6XCIsIGV4dGVuc2lvbik7XG5cbiAgICBjb25zdCBpbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvXCIpO1xuICAgIGluZm8uaW5uZXJIVE1MID0gYFRlc3QtRXh0ZW5zaW9uIGxvYWRlZDogJHtleHRlbnNpb24ucGtnLm5hbWV9QCR7ZXh0ZW5zaW9uLnBrZy52ZXJzaW9ufSBTSEEgJHtzaGF9YDtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IGF3YWl0IGV4dGVuc2lvbi5sYXVuY2hNb2R1bGUoXCJkaXN0L21hdGguanNcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTW9kdWxlIGxvYWRlZDpcIiwgZXh0ZW5zaW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImV2ZW50XCIpO1xuICAgIGNvbnN0IG9wZXJhdGlvbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BlcmF0aW9uXCIpO1xuICAgIGNvbnN0IHN0YXRlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0ZVwiKTtcblxuICAgIGV2ZW50QnRuLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIGV4dGVuc2lvbi5lbWl0RXZlbnQoXCJncmVldFwiLCBcIkhlbGxvIHdvcmxkIVwiKTtcbiAgICB9O1xuXG4gICAgb3BlcmF0aW9uQnRuLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1bSA9IGF3YWl0IG1vZHVsZS5leGVjdXRlKFwiYWRkXCIsIDEsIDUpO1xuICAgICAgICBjb25zdCBkID0gZXh0ZW5zaW9uLmV4ZWN1dGUoXCJzdWJzdHJhY3RcIiwgMTAsIDIpO1xuICAgICAgICBhbGVydChcIlN1bTogXCIgKyBzdW0gKyBcIiBTdWI6IFwiICsgZCk7XG4gICAgfTtcblxuICAgIC8vIHB1c2hTdGF0ZVxuXG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgc3RhdGVCdG4ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgZXh0ZW5zaW9uLnB1c2hTdGF0ZSh7IG1lc3NhZ2U6IFwiQ291bnRlcjogXCIgKyArK2NvdW50ZXIgfSk7XG4gICAgfTtcbn1cblxubWFpbigpO1xuLy9tYWluMigpO1xuXG5mdW5jdGlvbiBtYWluMigpIHtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKFwid29ya2VyLmpzXCIpO1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIF9fdHlwZTogXCJtZXRhXCIsXG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZ2l0aHViXCIsXG4gICAgICAgICAgICBuYW1lOiBcImFuZHJlLWhjdHVsYy9leHRlbnNpb25ydW5uZXItdGVzdC1leHRlbnNpb25cIixcbiAgICAgICAgICAgIHZlcnNpb246IFwiMDllZGM3ZWE2OWNkYjAyNWE5N2I1Y2QyNWYyNzUzNWQ5YzQwYmVkZVwiLFxuICAgICAgICAgICAgcGF0aDogXCJkaXN0L21hdGguanNcIixcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZSA9PiB7XG4gICAgICAgIGlmIChlLmRhdGE/Ll9fdHlwZSA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICBhbGVydChcIldvcmtlciBpcyByZWFkeVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIGlzIHJlYWR5XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3b3JrZXIub25lcnJvciA9IGUgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyBNb2R1bGUgfSBmcm9tIFwiLi9Nb2R1bGUuanNcIjtcbmltcG9ydCB7IEV2ZW50cywgcmVsUGF0aCB9IGZyb20gXCIuL3NoYXJlZC5qc1wiO1xuaW1wb3J0ICogYXMgd29ya2VyIGZyb20gXCIuL3dvcmtlci5qc1wiO1xuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbiBleHRlbmRzIEV2ZW50cyB7XG4gICAgY29uc3RydWN0b3IoaW5pdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICB0aGlzLnVybCA9IFwiXCI7XG4gICAgICAgIHRoaXMuc3RhdGljUGFyYW1zID0gXCJcIjtcbiAgICAgICAgdGhpcy5fcGtnID0ge307XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAvKiogYDxtb2R1bGVfaWQsIHsgaW5zdGFuY2VzOiA8TW9kdWxlLCBkYXRhPiwgc2hhcmVkU3RhdGU6IGFueSB9PmAgKi9cbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJnaXRodWJcIikge1xuICAgICAgICAgICAgY29uc3QgW293bmVyLCByZXBvXSA9IHRoaXMuaW5pdC5uYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIHRoaXMudXJsID0gYGh0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvJHtvd25lcn0vJHtyZXBvfS9jb250ZW50cy9gO1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNQYXJhbXMgPSBgP3JlZj0ke2luaXQudmVyc2lvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJucG1cIikge1xuICAgICAgICAgICAgdGhpcy51cmwgPSBgaHR0cHM6Ly91bnBrZy5jb20vJHt0aGlzLmluaXQubmFtZX1AJHt0aGlzLmluaXQudmVyc2lvbn0vYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGUgKCducG0nIG9yICdnaXRodWInIGV4cGVjdGVkKVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGxvYWQgbWV0YSAocGFja2FnZS5qc29uKVxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5sb2FkRmlsZShcInBhY2thZ2UuanNvblwiKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGZpbGUudGV4dCgpO1xuICAgICAgICB0aGlzLl9wa2cgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcGF0aCBVc2UgX251bGxfIG9yIGVtcHR5IHN0cmluZyBmb3IgdGhlIHBhY2thZ2VzIGVudHJ5IGZpbGVcbiAgICAgKi9cbiAgICBhc3luYyBsYXVuY2hNb2R1bGUocGF0aCwgb3V0LCBtZXRhKSB7XG4gICAgICAgIHBhdGggPSByZWxQYXRoKHBhdGggfHwgXCJcIik7XG4gICAgICAgIC8qKiBUaGUgd29ya2VyIGNvZGUgaXMgdHJhbnNmb3JtZWQgdG8gYSBzdHJpbmcgb24gYnVpbGQsIHNvIHdlIGNhbiBhbHd5cyBpbXBvcnQgaXQgaGVyZSBhbmQgc3RhcnQgdGhlIHdvcmtlciAqL1xuICAgICAgICBjb25zdCB3b3JrZXJDb2RlID0gd29ya2VyLmNvZGU7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbd29ya2VyQ29kZV0sIHsgdHlwZTogXCJtb2R1bGVcIiB9KTtcbiAgICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTsgLy8gVE9ETyByZXZva2Ugb2JqZWN0IHVybFxuICAgICAgICBjb25zdCB3b3JrZXJfID0gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmluaXRNb2R1bGUod29ya2VyXywgcGF0aCwgb3V0LCBtZXRhKTtcbiAgICAgICAgcmV0dXJuIG1vZC5zdGFydCgpO1xuICAgIH1cbiAgICBhc3luYyBsYXVuY2hJRnJhbWUocGFyZW50RWxlbWVudCwgcGF0aCwgb3V0LCBtZXRhKSB7XG4gICAgICAgIHBhdGggPSByZWxQYXRoKHBhdGgpO1xuICAgICAgICAvLyBjcmVhdGUgaWZyYW1lIGFuZCBhcHBlbmQgdG8gcGFyZW50RWxlbWVudFxuICAgICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBpZnJhbWUuc3JjID0gdGhpcy51cmwgKyBwYXRoO1xuICAgICAgICAvLyB3YWl0IGZvciBsb2FkXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZnJhbWUub25sb2FkID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KFwiYGNvbnRlbnRXaW5kb3dgbmRvdyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmluaXRNb2R1bGUoaWZyYW1lLmNvbnRlbnRXaW5kb3csIHBhdGgsIG91dCwgbWV0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtb2Quc3RhcnQoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0TW9kdWxlKHRhcmdldCwgcGF0aCwgb3V0LCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYGlmcmFtZToke3BhdGh9YDtcbiAgICAgICAgLy8gZXh0ZW5kIG1ldGFcbiAgICAgICAgbGV0IF9tZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5pbml0Lm5hbWUsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY2FjaGUuZ2V0KGlkKT8uc2hhcmVkU3RhdGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmluaXQudmVyc2lvbixcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuaW5pdC50eXBlLFxuICAgICAgICB9O1xuICAgICAgICBfbWV0YSA9IHRoaXMuaW5pdC5tZXRhID8gdGhpcy5pbml0Lm1ldGEoX21ldGEpIDogX21ldGE7XG4gICAgICAgIGlmIChtZXRhKVxuICAgICAgICAgICAgX21ldGEgPSBtZXRhKF9tZXRhKTtcbiAgICAgICAgLy8gY3JlYXRlIG1vZHVsZVxuICAgICAgICBjb25zdCBtb2QgPSBuZXcgTW9kdWxlKHRhcmdldCwgX21ldGEsIG91dCwge1xuICAgICAgICAgICAgb25QdXNoU3RhdGU6IChuZXdTdGF0ZSwgcG9wdWxhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9wdWxhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGlkLCBuZXdTdGF0ZSwgdW5kZWZpbmVkLCBbbW9kXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0Lm9uUHVzaFN0YXRlPy4obmV3U3RhdGUsIG1vZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25FdmVudDogKHR5cGUsIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycz8uKHR5cGUsIHBheWxvYWQsIG1vZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlcmF0aW9uVGltZW91dDogdGhpcy5pbml0Lm9wZXJhdGlvblRpbWVvdXQsXG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogdGhpcy5pbml0LmNvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2FjaGVcbiAgICAgICAgbGV0IGluc3RhbmNlcyA9IHRoaXMuY2FjaGUuZ2V0KGlkKT8uaW5zdGFuY2VzO1xuICAgICAgICBpZiAoIWluc3RhbmNlcykge1xuICAgICAgICAgICAgaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoaWQsIHsgaW5zdGFuY2VzLCBzaGFyZWRTdGF0ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlcy5zZXQobW9kLCB7IHN0YXRlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC50eXBlICsgXCIlXCIgKyB0aGlzLmluaXQubmFtZTtcbiAgICB9XG4gICAgZ2V0IHBrZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BrZztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQudHlwZTtcbiAgICB9XG4gICAgZ2V0VXJsKHBhdGgsIHNlYXJjaFBhcmFtcykge1xuICAgICAgICBpZiAoc2VhcmNoUGFyYW1zKVxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zID0gdGhpcy5zdGF0aWNQYXJhbXMgPyB0aGlzLnN0YXRpY1BhcmFtcyArIFwiJlwiICsgc2VhcmNoUGFyYW1zIDogc2VhcmNoUGFyYW1zO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMgPSB0aGlzLnN0YXRpY1BhcmFtcztcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsICsgcGF0aCArIHNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgLyoqIElmIHRoZSByZXNwb25zZSBpcyBub3Qgb2ssIHRoZSBgUmVzcG9uc2VgIHdpbGwgYmUgc2V0IG9uIHRoZSB0aHJvd24gZXJyb3IgKGBFcnJvci5yZXNwb25zZWApICovXG4gICAgYXN5bmMgbG9hZEZpbGUocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBlbHNlIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSlcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZ2V0VXJsKHBhdGgpLCB0aGlzLnR5cGUgPT09IFwiZ2l0aHViXCIgPyB7IGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5naXRodWIucmF3K2pzb25cIiB9IH0gOiB7fSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBmaWxlOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBmaWxlOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBwdXNoU3RhdGUobW9kdWxlSWQsIG5ld1N0YXRlLCBpbnN0YW5jZSwgZXhjbHVkZSkge1xuICAgICAgICBjb25zdCBleGNsU2V0ID0gbmV3IFNldChleGNsdWRlKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmNhY2hlLmdldChtb2R1bGVJZCk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGNsU2V0LmhhcyhpbnN0YW5jZSkpXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnB1c2hTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2R1bGVzID0gQXJyYXkuZnJvbShjYWNoZS5pbnN0YW5jZXMua2V5cygpKTtcbiAgICAgICAgICAgICAgICBtb2R1bGVzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4Y2xTZXQuaGFzKGluc3RhbmNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnB1c2hTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdEV2ZW50KHR5cGUsIHBheWxvYWQsIGZpbHRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZUlkIG9mIHRoaXMuY2FjaGUua2V5cygpKSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVzID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLmdldChtb2R1bGVJZCk/Lmluc3RhbmNlcy5rZXlzKCkgfHwgW10pO1xuICAgICAgICAgICAgbW9kdWxlcy5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIobW9kdWxlSWQsIGluc3RhbmNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmVtaXRFdmVudCh0eXBlLCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgcmVjZWl2ZURhdGEgfSBmcm9tIFwiLi9zaGFyZWQuanNcIjtcbi8qKiBSZXByZXNlbnRzIGFuIGlmcmFtZSBvciBhIHdvcmtlciAqL1xuZXhwb3J0IGNsYXNzIE1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBtZXRhLCBvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICAgIHRoaXMub3V0ID0gb3V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1lc3NhZ2VzXG4gICAgICAgICAgICB0aGlzLnRhcmdldC5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTUVTR1wiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGU/LmRhdGE/Ll9fdHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBlLmRhdGEuX190eXBlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RhdGVfcHVzaFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBlLmRhdGEuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25QdXNoU3RhdGU/LihlLmRhdGEuc3RhdGUsICEhZS5kYXRhLnBvcHVsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkV2ZW50Py4oZS5kYXRhLmV2ZW50LCBlLmRhdGEuYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wZXJhdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhcmdzLCBvcGVyYXRpb24sIHBvcnQgfSA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wID0gYXdhaXQgdGhpcy5vdXRbb3BlcmF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQub25tZXNzYWdlZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycihcIk9wZXJhdGlvbiBDaGFubmVsIEVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3AgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnIoXCJPcGVyYXRpb24gbm90IGZvdW5kXCIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcCguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKHsgX190eXBlOiBcIm9wZXJhdGlvbjpyZXN1bHRcIiwgcGF5bG9hZDogcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycihcIk9wZXJhdGlvbiBFeGVjdXRpb24gRXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluaXQgcG9zdE1lc3NhZ2UgKHJlY2VpdmVkIGJ5IHdvcmtlci50cyBvciBpZnJhbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50c0luID0gZXZlbnRzLnBvcnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzT3V0ID0gZXZlbnRzLnBvcnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzSW4ub25tZXNzYWdlZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycihcIkV2ZW50cyBDaGFubmVsIChpbikgRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzT3V0Lm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnIoXCJFdmVudHMgQ2hhbm5lbCAob3V0KSBFcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVycm9yc1xuICAgICAgICAgICAgdGhpcy50YXJnZXQub25tZXNzYWdlZXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyKFwiTWVzc2FnZSBFcnJvclwiLCBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZXJyKFwiSW5pdGlhbGl6YXRpb24gRXJyb3JcIiwgZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyKFwiVW5jYXVnaHQgRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUG9zdCBtZXRhLCBzbyB0aGUgd29ya2VyIGtub3dzIHdoaWNoIG1vZHVsZSB0byBpbXBvcnQgKGZvciB3b3JrZXJzKVxuICAgICAgICAgICAgLy8gaWZyYW1lcyBkbyBub3QgbmVjY2Vzc2FyaWx5IG5lZWQgdGhpc1xuICAgICAgICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IFwibWV0YVwiLCBtZXRhOiB0aGlzLm1ldGEgfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5lcnIoXCJDb25uZWN0aW9uIHRpbWVvdXRcIiwgbnVsbCkpO1xuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0IHx8IDUwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIGVycihpbmZvLCBldmVudCkge1xuICAgICAgICBjb25zdCBtc2cgPSBldmVudCBpbnN0YW5jZW9mIEV2ZW50ID8gKGV2ZW50Lm1lc3NhZ2UgfHwgZXZlbnQuZGF0YSB8fCBcIlwiKS50b1N0cmluZygpIDogZXZlbnQgaW5zdGFuY2VvZiBFcnJvciA/IGV2ZW50Lm1lc3NhZ2UgOiBcIlwiO1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYCR7aW5mb30ke21zZyA/IFwiOiBcIiArIG1zZyA6IFwiXCJ9YCk7XG4gICAgICAgIHRoaXMub3B0aW9ucz8ub25FcnJvcj8uKGVycik7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIHBvc3RNZXNzYWdlKHR5cGUsIGRhdGEsIHRyYW5zZmVyKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIFdvcmtlcilcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnBvc3RNZXNzYWdlKHsgX190eXBlOiB0eXBlLCAuLi5kYXRhIH0sIHsgdHJhbnNmZXIgfSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0KVxuICAgICAgICAgICAgdGhpcy50YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IHR5cGUsIC4uLmRhdGEgfSwgXCIqXCIsIHRyYW5zZmVyKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZShvcGVyYXRpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlY2VpdmVEYXRhKHRoaXMudGFyZ2V0LCBcIm9wZXJhdGlvblwiLCB7IGFyZ3MsIG9wZXJhdGlvbiB9LCBbXSwgdGhpcy5vcHRpb25zLm9wZXJhdGlvblRpbWVvdXQpO1xuICAgIH1cbiAgICBhc3luYyBlbWl0RXZlbnQodHlwZSwgcGF5bG9hZCkge1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKFwiZXZlbnRcIiwgeyBldmVudDogdHlwZSwgYXJnczogcGF5bG9hZCB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHVzaFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2UoXCJzdGF0ZV9wdXNoXCIsIHsgc3RhdGU6IG5ld1N0YXRlIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCIuL0V4dGVuc2lvbi5qc1wiO1xuZXhwb3J0IGNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRFeHRlbnNpb24oZXh0ZW5zaW9uSW5pdCkge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uKGV4dGVuc2lvbkluaXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXh0ZW5zaW9uLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBleHRlbnNpb246ICR7ZXJyfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGV4dGVuc2lvbi5pZCwgZXh0ZW5zaW9uKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG4gICAgYWxsRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jYWNoZS52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGdldEV4dGVuc2lvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoaWQpIHx8IG51bGw7XG4gICAgfVxufVxuIiwiZXhwb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIi4vRXh0ZW5zaW9uLmpzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCIuL1Byb3ZpZGVyLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBQcm92aWRlcjtcbiIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9FdmVudHNfbGlzdGVuZXJzO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbFBhdGgocGF0aCkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSlcbiAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMik7XG4gICAgZWxzZSBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZURhdGEoZSwgdHlwZSkge1xuICAgIGlmIChlLmRhdGEgJiYgdHlwZW9mIGUuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBlLmRhdGEuX190eXBlID09PSB0eXBlKVxuICAgICAgICByZXR1cm4gZS5kYXRhO1xuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlY2VpdmVEYXRhKHRhcmdldCwgbWVzc2FnZVR5cGUsIGRhdGEsIHRyYW5zZmVyLCBlcnJUaW1lb3V0ID0gNTAwMCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gY2hhbm5lbC5wb3J0MTtcbiAgICAgICAgY29uc3QgaW5fID0gY2hhbm5lbC5wb3J0MjtcbiAgICAgICAgbGV0IHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiT3BlcmF0aW9uIHRpbWVvdXRcIikpO1xuICAgICAgICB9LCBlcnJUaW1lb3V0IHx8IDUwMDApO1xuICAgICAgICBpbl8ub25tZXNzYWdlID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBnZXRNZXNzYWdlRGF0YShlLCBtZXNzYWdlVHlwZSArIFwiOnJlc3VsdFwiKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW5fLm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ2hhbm5lbCBFcnJvciAoaW4pXCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgb3V0Lm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ2hhbm5lbCBFcnJvciAob3V0KVwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBXb3JrZXIpXG4gICAgICAgICAgICB0YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IG1lc3NhZ2VUeXBlLCAuLi5kYXRhIH0sIHsgdHJhbnNmZXI6IFtpbl8sIC4uLnRyYW5zZmVyXSB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0LnBvc3RNZXNzYWdlKHsgX190eXBlOiBtZXNzYWdlVHlwZSwgLi4uZGF0YSB9LCBcIipcIiwgW2luXywgLi4udHJhbnNmZXJdKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjbGFzcyBFdmVudHMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfRXZlbnRzX2xpc3RlbmVycy5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c19saXN0ZW5lcnMsIFwiZlwiKS5oYXModHlwZSkpXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNfbGlzdGVuZXJzLCBcImZcIikuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c19saXN0ZW5lcnMsIFwiZlwiKS5nZXQodHlwZSk/LmFkZChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgbm90aWZ5TGlzdGVuZXJzKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gICAgfVxufVxuX0V2ZW50c19saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuIiwiZXhwb3J0IGNvbnN0IGNvZGU9YFxuLypcbkltcG9ydCB0aGUgZXh0ZW5zaW9uIG1vZHVsZSBmcm9tIGdpdGh1YiBvciB1bnBrZ1xuKi9cbmxldCBzdGFydGVkID0gZmFsc2U7XG5jb25zdCBpc05vbkVtcHR5U3RyID0gKHMpID0+ICEhcyAmJiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIjtcbnNlbGYub25tZXNzYWdlID0gYXN5bmMgKGUpID0+IHtcbiAgICBpZiAoc3RhcnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgIC8vIElmIGluaXQgbWVzc2FnZVxuICAgIGlmIChlLmRhdGE/Ll9fdHlwZSA9PSBcIm1ldGFcIiAmJiB0eXBlb2YgZS5kYXRhLm1ldGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IGUuZGF0YS5tZXRhO1xuICAgICAgICAvLyBDaGVjayBtZXRhXG4gICAgICAgIGlmICghaXNOb25FbXB0eVN0cihtZXRhLnBhdGgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRoXCIpO1xuICAgICAgICBpZiAoIWlzTm9uRW1wdHlTdHIobWV0YS52ZXJzaW9uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbmFtZVwiKTtcbiAgICAgICAgaWYgKCFpc05vbkVtcHR5U3RyKG1ldGEucGF0aCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcnNpb25cIik7XG4gICAgICAgIC8vIHNldCBtZXRhIGdsb2JhbGx5XG4gICAgICAgIHNlbGYuX19tZXRhID0gbWV0YTtcbiAgICAgICAgLy8gaW1wb3J0IG1vZHVsZSAoZm9yIHNpZGUgZWZmZWN0cyAtIGltcG9ydGVkIG1vZHVsZXMgc2hvdWxkIHVzZSBcXGBBZGFwdGVyXFxgKVxuICAgICAgICBsZXQgaW1wb3J0VXJsO1xuICAgICAgICAvLyBkbyBub3QgdXNlIHRlbXBsYXRlIHN0cmluZ3MgaGVyZSwgcG9zdCBidWlsZCBzY3JpcHQgd3JhcHMgdGhpcyBjb2RlIGluIFxcYFxcYFxuICAgICAgICBpZiAobWV0YS50eXBlID09PSBcIm5wbVwiKSB7XG4gICAgICAgICAgICBpbXBvcnRVcmwgPSBcImh0dHBzOi8vdW5wa2cuY29tL1wiICsgbWV0YS5uYW1lICsgXCJAXCIgKyBtZXRhLnZlcnNpb24gKyBcIi9cIiArIG1ldGEucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXRhLnR5cGUgPT09IFwiZ2l0aHViXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFtvd25lciwgcmVwb10gPSBtZXRhLm5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgaW1wb3J0VXJsID0gXCJnaXRodWI6XCIgKyBvd25lciArIFwiL1wiICsgcmVwbyArIFwiQFwiICsgbWV0YS52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSAoJ25wbScgb3IgJ2dpdGh1YicgZXhwZWN0ZWQpXCIpO1xuICAgICAgICBjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnQoaW1wb3J0VXJsKTtcbiAgICAgICAgcG9zdE1lc3NhZ2UoeyBfX3R5cGU6IFwicmVhZHlcIiB9KTtcbiAgICB9XG59O1xuZXhwb3J0IHt9O1xuXG5gIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5obWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZSA9IE9iamVjdC5jcmVhdGUobW9kdWxlKTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdHNldDogKCkgPT4ge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFUyBNb2R1bGVzIG1heSBub3QgYXNzaWduIG1vZHVsZS5leHBvcnRzIG9yIGV4cG9ydHMuKiwgVXNlIEVTTSBleHBvcnQgc3ludGF4LCBpbnN0ZWFkOiAnICsgbW9kdWxlLmlkKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <button id="operation">Operation (add and substract)</button>
        <button id="state">Push state</button>
        <button id="event">Emit Event (shape_change)</button>
    </body>
</html>
