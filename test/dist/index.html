<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../CorsWorker.js":
/*!************************!*\
  !*** ../CorsWorker.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CorsWorker: () => (/* binding */ CorsWorker)
/* harmony export */ });
/*
Source: https://github.com/webpack/webpack/discussions/14648

Browsers do not support CORS for web workers (but they should?). This is a workaround to load a script from a different origin.
*/
class CorsWorker {
    constructor(url, options) {
        this.url = url;
        this.options = options;
        this.inited = false;
    }
    async init() {
        if (this.inited)
            return this;
        this.inited = true;
        try {
            const response = await fetch(this.url);
            if (!response.ok)
                throw new Error();
            const text = await response.text();
            const objectURL = URL.createObjectURL(new Blob([text], {
                type: "application/javascript",
            }));
            this._worker = new Worker(objectURL, { type: this.options?.type, name: this.options?.name });
        }
        catch (err) {
            throw new Error("Failed to create worker");
        }
        return this;
    }
    get worker() {
        if (!this._worker)
            throw new Error("CorsWorker did not start properly");
        return this._worker;
    }
}


/***/ }),

/***/ "../EventsHandler.js":
/*!***************************!*\
  !*** ../EventsHandler.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* binding */ Event),
/* harmony export */   EventsHandler: () => (/* binding */ EventsHandler)
/* harmony export */ });
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Event_defaultPrevented, _EventsHandler_listeners, _EventsHandler_globalListeners;
class Event {
    constructor(type, payload) {
        this.type = type;
        this.payload = payload;
        _Event_defaultPrevented.set(this, false);
    }
    preventDefault() {
        __classPrivateFieldSet(this, _Event_defaultPrevented, true, "f");
    }
    get defaultPrevented() {
        return __classPrivateFieldGet(this, _Event_defaultPrevented, "f");
    }
}
_Event_defaultPrevented = new WeakMap();
class EventsHandler {
    constructor() {
        _EventsHandler_listeners.set(this, new Map());
        _EventsHandler_globalListeners.set(this, new Set());
    }
    addEventListener(type, listener) {
        if (!type)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").add(listener);
        else {
            if (!__classPrivateFieldGet(this, _EventsHandler_listeners, "f").has(type))
                __classPrivateFieldGet(this, _EventsHandler_listeners, "f").set(type, new Set());
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.add(listener);
        }
        return listener;
    }
    removeEventListener(type, listener) {
        if (type === null)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").delete(listener);
        else
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.delete(listener);
    }
    emitEvent(type, payload) {
        const ev = new Event(type, payload);
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.forEach(listener => listener(ev));
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").forEach(listener => listener(ev));
        return ev;
    }
    clearListeners() {
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").clear();
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").clear();
    }
}
_EventsHandler_listeners = new WeakMap(), _EventsHandler_globalListeners = new WeakMap();


/***/ }),

/***/ "../Extension.js":
/*!***********************!*\
  !*** ../Extension.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension)
/* harmony export */ });
/* harmony import */ var _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CorsWorker.js */ "../CorsWorker.js");
/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Module.js */ "../Module.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared.js */ "../shared.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");




class Extension extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__.EventsHandler {
    constructor(provider, init) {
        super();
        this.provider = provider;
        this.init = init;
        this.url = "";
        this._pkg = {};
        this.started = false;
        /** `<path, { instances: <Module, data>, sharedState: any }>` */
        this.cache = new Map();
        this.logs = !!provider.options?.logs;
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        // load meta (package.json)
        const file = await this.loadFile("package.json");
        const text = await file.text();
        this._pkg = JSON.parse(text);
    }
    /** When the filter is empty no modules are returned */
    filterModules(filter) {
        const all = this.getAllModules();
        const idsSet = new Set(Array.isArray(filter.id) ? filter.id : [filter.id]);
        const notIdsSet = new Set(Array.isArray(filter.notId) ? filter.notId : [filter.notId]);
        const pathsSet = new Set(Array.isArray(filter.path) ? filter.path : [filter.path]);
        const notPathsSet = new Set(Array.isArray(filter.notPath) ? filter.notPath : [filter.notPath]);
        return all.filter(module => {
            let include = idsSet.has(module.id) || pathsSet.has(module.meta.path) || !!filter.check?.(module);
            if (include && notIdsSet.size && notIdsSet.has(module.id))
                include = false;
            if (include && notPathsSet.size && notPathsSet.has(module.meta.path))
                include = false;
            return include;
        });
    }
    getAllModules() {
        return Array.from(this.cache.values()).flatMap(({ instances }) => Array.from(instances.values()));
    }
    /**
     * @param path Use _null_ or empty string for the packages entry file
     */
    async launchModule(path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path || "");
        // IMP use correct npm version for the newest worker build (extensionrunner@version)
        const corsWorker = new _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__.CorsWorker(_shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr + "/npm/extensionrunner@1.0.33/worker.js", {
            type: "module",
            name: `${this.init.name}:${path}`,
        });
        await corsWorker.init();
        const mod = this.initModule(corsWorker.worker, _shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr, path, out, options || {});
        return mod.start();
    }
    async launchComponent(parentElement, path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path);
        // Most CDNs do not directly serve html files, they serve the html as a string in a response. So does jsdelivr and unpkg.
        // So we fetch the html and use ifrm.srcdoc to load the html
        const iframe = document.createElement("iframe");
        let url;
        let origin;
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            origin = "https://raw.githack.com";
            url = `${origin}/${owner}/${repo}/${this.init.version}/${path}`;
        }
        else if (this.type === "npm") {
            // TODO see Info.md CDNs
            origin = "https://unpkg.com";
            url = `${origin}/${this.init.name}@${this.init.version}/${path}`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        iframe.src = url;
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
        // TODOD more attrs?
        // wait for load
        return new Promise((resolve, reject) => {
            iframe.onload = async (e) => {
                if (!iframe.contentWindow)
                    return reject("`contentWindow`ndow not defined");
                const mod = this.initModule(iframe.contentWindow, origin, path, out, options || {});
                resolve(mod.start());
            };
            iframe.addEventListener("error", e => {
                reject(new Error(e.message));
            });
            parentElement.appendChild(iframe);
        });
    }
    initModule(target, origin, path, out, options) {
        // create meta
        let meta = {
            authToken: (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.randomId)(),
            name: this.init.name,
            path,
            initialState: this.cache.get(path)?.state,
            version: this.init.version,
            type: this.init.type,
        };
        meta = this.init.meta ? this.init.meta(meta) : meta;
        if (options.meta)
            meta = options.meta(meta);
        if (options.initialState !== undefined)
            meta.initialState = options.initialState;
        // create module
        const populateState = options.allowPopulateState ?? false;
        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_1__.Module(this, {
            origin,
            target,
            meta: meta,
            out,
            operationTimeout: this.init.operationTimeout,
            connectionTimeout: this.init.connectionTimeout,
            allowPopulateState: typeof populateState === "boolean"
                ? populateState
                : (newState, merge) => populateState(newState, merge, mod),
        });
        // propagate events
        mod.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        mod.addEventListener("state_populate", async (ev) => {
            if (ev.payload.options?.populate === false)
                return;
            if (this.cache.has(path))
                this.cache.get(path).state = ev.payload;
            const pushResults = await this.pushState(ev.payload.state, {
                filter: { notId: mod.id, path: mod.meta.path },
            });
            this.emitEvent("state_populate", {
                module: mod,
                state: ev.payload.state,
                options: ev.payload.options,
                result: pushResults,
            });
        });
        mod.addEventListener("destroy", () => {
            this.cache.get(path)?.instances.delete(mod.id);
            this.emitEvent("module_destroy", mod);
        });
        mod.addEventListener("error", ev => {
            this.emitEvent("error", { error: ev.payload, origin: mod });
        });
        // cache
        let instances = this.cache.get(path)?.instances;
        if (!instances) {
            instances = new Map();
            this.cache.set(path, { instances, state: undefined });
        }
        instances.set(mod.id, mod);
        this.emitEvent("module_load", mod);
        return mod;
    }
    get id() {
        return this.init.type + "%" + this.init.name;
    }
    get pkg() {
        return this._pkg;
    }
    get type() {
        return this.init.type;
    }
    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */
    async loadFile(path) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.loadFile)(this.init.type, this.init.name, this.init.version, path);
    }
    async pushState(newState, options) {
        return await this.forEachModule(module => {
            module.pushState(newState, { merge: options?.merge ?? true });
        }, {
            parallel: true,
        });
    }
    async forEachModule(callback, options) {
        const result = { failed: [], affected: [], result: [], errors: [] };
        const modules = options?.filter ? this.filterModules(options.filter) : this.getAllModules();
        if (options?.parallel) {
            const par = await Promise.all(modules.map(async (module) => {
                try {
                    return { error: null, result: await callback(module), module };
                }
                catch (err) {
                    return { error: err, result: undefined, module };
                }
            }));
            par.forEach(p => {
                if (p.error) {
                    result.failed.push(p.module);
                    result.errors.push(p.error);
                }
                else {
                    result.affected.push(p.module);
                    result.result.push(p.result);
                }
            });
        }
        else {
            for (const module of modules) {
                try {
                    result.result.push(await callback(module));
                    result.affected.push(module);
                }
                catch (err) {
                    result.failed.push(module);
                    result.errors.push(err);
                }
            }
        }
        return result;
    }
    async destroy() {
        const actions = await this.forEachModule(module => module.destroy());
        this.cache.clear();
        this.clearListeners();
        this.emitEvent("destroy", undefined);
        return actions;
    }
    err(info, event) {
        const msg = event instanceof Event
            ? (event.message || event.data || "").toString()
            : event instanceof Error
                ? event.message
                : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        if (this.logs)
            console.error(info, err);
        this.emitEvent("error", err);
        return err;
    }
}


/***/ }),

/***/ "../Module.js":
/*!********************!*\
  !*** ../Module.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "../shared.js");


/** Represents an iframe or a worker */
class Module extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(extension, init) {
        super();
        this.extension = extension;
        this.init = init;
        this.id = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.randomId)();
        this.started = false;
        this.logs = !!this.extension.provider.options?.logs;
    }
    async start() {
        if (this.started)
            return this;
        this.started = true;
        return new Promise((resolve, reject) => {
            // In CORS context target is Window (iframe.contentWindow)
            // We cant define target.onmessage or target.onerror on a cross origin Window
            // Thats why we listen to the message event on the global object and check the source
            let resolved = false;
            const messagesListener = async (e) => {
                // origin = "" -> same origin
                if (e.origin !== "" && e.origin !== this.init.origin)
                    return;
                if (e.data?.__token !== this.meta.authToken)
                    return;
                if (typeof e?.data?.__type !== "string")
                    return;
                const type = e.data.__type;
                switch (type) {
                    case "state_populate":
                        let newState;
                        if (this.init.allowPopulateState) {
                            const merge = !!e.data.options?.merge;
                            let receivedState = e.data.state;
                            if (!receivedState || typeof receivedState !== "object") {
                                return this.err("Invalid state", e);
                            }
                            const allowed = this.init.allowPopulateState === true ||
                                this.init.allowPopulateState?.(receivedState, merge);
                            if (!allowed)
                                return;
                            // state allowed but modified
                            if (typeof allowed === "object")
                                receivedState = allowed;
                            if (merge) {
                                if (this.init.mergeStates)
                                    newState = this.init.mergeStates(this.state, receivedState);
                                else
                                    newState = { ...this.state, ...receivedState };
                            }
                            else
                                newState = receivedState;
                        }
                        else
                            return;
                        // The state gets populated to every module with this path but this one if e.data.options.populate !== false
                        // So we set the state of this module here. For the other modules its set in pushState
                        this._state = newState;
                        this.emitEvent("state_populate", {
                            state: newState,
                            options: e.data.options || {},
                        });
                        break;
                    case "operation":
                        const { args, operation, __port: port } = e.data;
                        if (!port)
                            return this.err("Operation Channel Error", "Port not found");
                        let op = await this.init.out?.[operation];
                        if (typeof op !== "function")
                            op = null;
                        port.onmessageerror = e => {
                            this.err("Operation Channel Error", e);
                        };
                        if (op) {
                            try {
                                const result = await op.apply(this, args);
                                port.postMessage({
                                    __type: "operation:result",
                                    payload: result,
                                });
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result,
                                    error: null,
                                });
                            }
                            catch (err) {
                                const e = this.err("Operation Execution Error", err);
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result: undefined,
                                    error: e,
                                });
                                return;
                            }
                        }
                        else {
                            this.emitEvent(`op:${operation}`, {
                                args,
                                result: undefined,
                                error: null,
                            });
                        }
                        break;
                    case "ready":
                        if (!resolved)
                            resolve(this);
                        this.emitEvent("load", undefined);
                        resolved = true;
                        break;
                }
            };
            /*
             worker messages are only received via Worker.onmessage,
             whereas iframe messages are received via window.onmessage or iframe.contentWindow.onmessage.
             So we need to handle workers and iframes differently
            */
            // Worker
            if (this.init.target instanceof Worker) {
                if (this.logs)
                    console.log("Listening on worker for messages");
                this.init.target.addEventListener("message", messagesListener);
            }
            // IFrame
            else {
                if (this.logs)
                    console.log("Listening on window for messages");
                window.addEventListener("message", messagesListener);
            }
            // Post meta:
            // - Workers need this to import the module in the worker initialization, whoich dynamically imports the module
            // - Iframes need this to init their meta
            this.init.target.postMessage({ __type: "meta", meta: this.init.meta }, { targetOrigin: this.init.origin });
            setTimeout(() => {
                if (!resolved)
                    reject(this.err("Connection timeout", null));
            }, this.init.connectionTimeout || 5000);
        });
    }
    get state() {
        return this._state;
    }
    get meta() {
        return this.init.meta;
    }
    err(info, event) {
        const msg = event instanceof Event
            ? (event.message || event.data || "").toString()
            : event instanceof Error
                ? event.message
                : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        if (this.logs)
            console.error(info, err);
        this.emitEvent("error", err);
        return err;
    }
    postMessage(type, data, transfer) {
        this.init.target.postMessage({ ...data, __type: type }, { transfer, targetOrigin: this.init.origin });
    }
    async execute(operation, ...args) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.receiveData)(this.init.target, "operation", { args, operation }, this.init.origin, [], this.init.operationTimeout);
    }
    async pushState(newState, options) {
        let s;
        if (options?.merge ?? false) {
            if (this.init.mergeStates) {
                s = this.init.mergeStates(this.state, newState);
            }
            else {
                s = { ...this.state, ...newState };
            }
        }
        else
            s = newState;
        this.postMessage("state_push", {
            state: s,
        });
        this._state = s;
        return s;
    }
    destroy() {
        if (this.init.target instanceof Worker) {
            try {
                this.init.target.terminate();
            }
            catch (err) { }
        }
        this.clearListeners();
        this.emitEvent("destroy", undefined);
    }
}


/***/ }),

/***/ "../Provider.js":
/*!**********************!*\
  !*** ../Provider.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");


class Provider extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(options) {
        super();
        this.options = options;
        this.cache = new Map();
    }
    async loadExtension(extensionInit) {
        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_1__.Extension(this, extensionInit);
        try {
            await extension.start();
        }
        catch (err) {
            throw new Error(`Failed to load extension: ${err?.toString()}`);
        }
        // propagate events
        extension.addEventListener("state_populate", e => {
            this.emitEvent("state_populate", { extension, module: e.payload.module, state: e.payload.state, options: e.payload.module });
        });
        extension.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        extension.addEventListener("destroy", e => {
            this.cache.delete(extension.id);
            this.emitEvent("extension_destroy", extension);
        });
        this.emitEvent("extension_load", extension);
        // cache
        this.cache.set(extension.id, extension);
        return extension;
    }
    allExtensions() {
        return Array.from(this.cache.values());
    }
    getExtension(id) {
        return this.cache.get(id) || null;
    }
    destroy() {
        const extensions = Array.from(this.cache.values());
        extensions.forEach(extension => extension.destroy());
        this.cache.clear();
    }
}


/***/ }),

/***/ "../index.js":
/*!*******************!*\
  !*** ../index.js ***!
  \*******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* reexport safe */ _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__.Event),
/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");
/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ "../Provider.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);


/***/ }),

/***/ "../shared.js":
/*!********************!*\
  !*** ../shared.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMessageData: () => (/* binding */ getMessageData),
/* harmony export */   getUrl: () => (/* binding */ getUrl),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   jsdelivr: () => (/* binding */ jsdelivr),
/* harmony export */   loadFile: () => (/* binding */ loadFile),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   receiveData: () => (/* binding */ receiveData),
/* harmony export */   relPath: () => (/* binding */ relPath)
/* harmony export */ });
function relPath(path) {
    if (path.startsWith("./"))
        path = path.slice(2);
    else if (path.startsWith("/"))
        path = path.slice(1);
    return path;
}
function getMessageData(e, type) {
    if (e.data && typeof e.data === "object" && e.data.__type === type)
        return e.data;
    return null;
}
/** 25 char long pseudo cryptic id */
function randomId() {
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let uniqueId = "";
    for (let i = 0; i < 25; i++) {
        const randomIndex = Math.floor(Math.random() * chars.length);
        uniqueId += chars[randomIndex];
    }
    return uniqueId;
}
const isBrowser = typeof window !== "undefined" && window === window.self;
async function receiveData(target, type, data, origin = "*", transfer, errTimeout = 5000) {
    return new Promise((resolve, reject) => {
        const channel = new MessageChannel();
        const out = channel.port1;
        const _in = channel.port2;
        let resolved = false;
        setTimeout(() => {
            if (!resolved)
                reject(new Error("Operation timeout"));
        }, errTimeout || 5000);
        out.onmessage = async (e) => {
            const data = getMessageData(e, type + ":result");
            if (data) {
                resolved = true;
                resolve(data.payload);
            }
        };
        _in.onmessageerror = e => {
            reject(new Error("Channel Error (in)"));
        };
        out.onmessageerror = e => {
            reject(new Error("Channel Error (out)"));
        };
        target.postMessage({ ...data, __type: type, __port: _in }, { targetOrigin: origin, transfer: [_in, ...(transfer || [])] });
    });
}
const jsdelivr = "https://cdn.jsdelivr.net";
function getUrl(type, name, version, path) {
    let baseUrl;
    if (type === "github") {
        const [owner, repo] = name.split("/");
        baseUrl = `${jsdelivr}/gh/${owner}/${repo}@${version}/`;
    }
    else if (type === "npm") {
        baseUrl = `${jsdelivr}/npm/${name}@${version}/`;
    }
    else
        throw new Error("Invalid type ('npm' or 'github' expected)");
    if (path) {
        path = relPath(path);
        return baseUrl + path;
    }
    else
        return baseUrl;
}
async function loadFile(type, name, version, path) {
    if (path.startsWith("/"))
        path = path.slice(1);
    else if (path.startsWith("./"))
        path = path.slice(2);
    const response = await fetch(getUrl(type, name, version, path), type === "github" ? {} : {});
    if (!response.ok) {
        const error = new Error(`Failed to load file: ${response.statusText}`);
        error.response = response;
        throw new Error(`Failed to load file: ${response.statusText}`);
    }
    return response;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ "../index.js");

const commitSha = "19229d109f2b538292e78f319dd06b5062523c6d";
main().catch(err => console.error(err));
const providerApi = {
    echo: text => {
        text = text || "";
        return text + "  " + text + "  " + text;
    },
    alert: message => {
        alert(message || "<empty>");
    },
    print: (...text) => {
        const container = document.getElementById("print");
        if (container)
            console.log("Print:", (text || ["<empty>"]).join(" "));
    },
    greet: (name, age) => {
        alert("Hello " + name + " AGE " + age);
    },
};
async function launchIFrames(extension) {
    const container = document.getElementById("iframe");
    const container2 = document.getElementById("iframe2");
    const resetBtn = document.getElementById("reset");
    if (container && container2 && resetBtn) {
        const componentModule = await extension.launchComponent(container, "dist/frames/counter/counter.html", providerApi, { allowPopulateState: true });
        const componentModule2 = await extension.launchComponent(container2, "dist/frames/counter/counter.html", providerApi, { allowPopulateState: true });
        setInterval(async () => {
            const newCounter = await componentModule.execute("increment");
            await componentModule2.execute("increment");
            console.log(`New counter <${newCounter}> returned by 'increment' execute (Should also be displayed in the iframe)`);
        }, 3000);
        resetBtn.onclick = () => {
            componentModule.execute("reset");
            componentModule.execute("print", "Resetted", "from", "main window");
        };
    }
}
async function launchModule(extension) {
    const module = await extension.launchModule("dist/math.js", providerApi);
    console.log("Module loaded:", extension);
    const operationBtn = document.getElementById("operation");
    if (operationBtn) {
        operationBtn.onclick = async () => {
            if (!module)
                return alert("Module not loaded");
            const sum = await module.execute("add", 1, 5);
            const d = await module.execute("substract", 10, 2);
            alert("Sum: " + sum + " Sub: " + d);
        };
    }
}
async function main() {
    addEventListener("message", e => {
        console.log("Message received ::", e.data);
    });
    const prov = new _index__WEBPACK_IMPORTED_MODULE_0__["default"]({ logs: true });
    const extension = await prov.loadExtension({
        type: "github",
        name: "andre-hctulc/extensionrunner-test-extension",
        version: commitSha,
    });
    console.log("Extension loaded:", extension);
    const info = document.getElementById("info");
    if (info)
        info.innerHTML = `${extension.pkg.name}@${extension.pkg.version} SHA ${commitSha}`;
    launchModule(extension).catch(err => console.error("Error launching module", err));
    launchIFrames(extension).catch(err => console.error("Error launching iframe", err));
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTs7Ozs7OztVQ2hGQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7O0FDTm1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEhBQThILDBCQUEwQjtBQUN4SixnSUFBZ0ksMEJBQTBCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQiw4Q0FBUSxHQUFHLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQixHQUFHLHVCQUF1QixNQUFNLFVBQVU7QUFDekY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC8uLi9Db3JzV29ya2VyLmpzIiwid2VicGFjazovL3Rlc3QvLi4vRXZlbnRzSGFuZGxlci5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL01vZHVsZS5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL1Byb3ZpZGVyLmpzIiwid2VicGFjazovL3Rlc3QvLi4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGVzdC8uLi9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Rlc3QvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9kaXNjdXNzaW9ucy8xNDY0OFxuXG5Ccm93c2VycyBkbyBub3Qgc3VwcG9ydCBDT1JTIGZvciB3ZWIgd29ya2VycyAoYnV0IHRoZXkgc2hvdWxkPykuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIGxvYWQgYSBzY3JpcHQgZnJvbSBhIGRpZmZlcmVudCBvcmlnaW4uXG4qL1xuZXhwb3J0IGNsYXNzIENvcnNXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy51cmwpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt0ZXh0XSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IFdvcmtlcihvYmplY3RVUkwsIHsgdHlwZTogdGhpcy5vcHRpb25zPy50eXBlLCBuYW1lOiB0aGlzLm9wdGlvbnM/Lm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSB3b3JrZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCB3b3JrZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29yc1dvcmtlciBkaWQgbm90IHN0YXJ0IHByb3Blcmx5XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyO1xuICAgIH1cbn1cbiIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRXZlbnRfZGVmYXVsdFByZXZlbnRlZCwgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnM7XG5leHBvcnQgY2xhc3MgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQsIHRydWUsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudF9kZWZhdWx0UHJldmVudGVkLCBcImZcIik7XG4gICAgfVxufVxuX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNsYXNzIEV2ZW50c0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMuc2V0KHRoaXMsIG5ldyBNYXAoKSk7XG4gICAgICAgIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycy5zZXQodGhpcywgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycywgXCJmXCIpLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLmhhcyh0eXBlKSlcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIFwiZlwiKS5nZXQodHlwZSk/LmFkZChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBudWxsKVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMsIFwiZlwiKS5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZW1pdEV2ZW50KHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgZXYgPSBuZXcgRXZlbnQodHlwZSwgcGF5bG9hZCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuZ2V0KHR5cGUpPy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGV2KSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzLCBcImZcIikuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihldikpO1xuICAgICAgICByZXR1cm4gZXY7XG4gICAgfVxuICAgIGNsZWFyTGlzdGVuZXJzKCkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycywgXCJmXCIpLmNsZWFyKCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuY2xlYXIoKTtcbiAgICB9XG59XG5fRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuIiwiaW1wb3J0IHsgQ29yc1dvcmtlciB9IGZyb20gXCIuL0NvcnNXb3JrZXIuanNcIjtcbmltcG9ydCB7IE1vZHVsZSB9IGZyb20gXCIuL01vZHVsZS5qc1wiO1xuaW1wb3J0IHsganNkZWxpdnIsIGxvYWRGaWxlLCByYW5kb21JZCwgcmVsUGF0aCB9IGZyb20gXCIuL3NoYXJlZC5qc1wiO1xuaW1wb3J0IHsgRXZlbnRzSGFuZGxlciB9IGZyb20gXCIuL0V2ZW50c0hhbmRsZXIuanNcIjtcbmV4cG9ydCBjbGFzcyBFeHRlbnNpb24gZXh0ZW5kcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgaW5pdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICAgICAgdGhpcy5fcGtnID0ge307XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAvKiogYDxwYXRoLCB7IGluc3RhbmNlczogPE1vZHVsZSwgZGF0YT4sIHNoYXJlZFN0YXRlOiBhbnkgfT5gICovXG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9ncyA9ICEhcHJvdmlkZXIub3B0aW9ucz8ubG9ncztcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGxvYWQgbWV0YSAocGFja2FnZS5qc29uKVxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5sb2FkRmlsZShcInBhY2thZ2UuanNvblwiKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGZpbGUudGV4dCgpO1xuICAgICAgICB0aGlzLl9wa2cgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgIH1cbiAgICAvKiogV2hlbiB0aGUgZmlsdGVyIGlzIGVtcHR5IG5vIG1vZHVsZXMgYXJlIHJldHVybmVkICovXG4gICAgZmlsdGVyTW9kdWxlcyhmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgYWxsID0gdGhpcy5nZXRBbGxNb2R1bGVzKCk7XG4gICAgICAgIGNvbnN0IGlkc1NldCA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheShmaWx0ZXIuaWQpID8gZmlsdGVyLmlkIDogW2ZpbHRlci5pZF0pO1xuICAgICAgICBjb25zdCBub3RJZHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLm5vdElkKSA/IGZpbHRlci5ub3RJZCA6IFtmaWx0ZXIubm90SWRdKTtcbiAgICAgICAgY29uc3QgcGF0aHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLnBhdGgpID8gZmlsdGVyLnBhdGggOiBbZmlsdGVyLnBhdGhdKTtcbiAgICAgICAgY29uc3Qgbm90UGF0aHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLm5vdFBhdGgpID8gZmlsdGVyLm5vdFBhdGggOiBbZmlsdGVyLm5vdFBhdGhdKTtcbiAgICAgICAgcmV0dXJuIGFsbC5maWx0ZXIobW9kdWxlID0+IHtcbiAgICAgICAgICAgIGxldCBpbmNsdWRlID0gaWRzU2V0Lmhhcyhtb2R1bGUuaWQpIHx8IHBhdGhzU2V0Lmhhcyhtb2R1bGUubWV0YS5wYXRoKSB8fCAhIWZpbHRlci5jaGVjaz8uKG1vZHVsZSk7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZSAmJiBub3RJZHNTZXQuc2l6ZSAmJiBub3RJZHNTZXQuaGFzKG1vZHVsZS5pZCkpXG4gICAgICAgICAgICAgICAgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGUgJiYgbm90UGF0aHNTZXQuc2l6ZSAmJiBub3RQYXRoc1NldC5oYXMobW9kdWxlLm1ldGEucGF0aCkpXG4gICAgICAgICAgICAgICAgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBbGxNb2R1bGVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLnZhbHVlcygpKS5mbGF0TWFwKCh7IGluc3RhbmNlcyB9KSA9PiBBcnJheS5mcm9tKGluc3RhbmNlcy52YWx1ZXMoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcGF0aCBVc2UgX251bGxfIG9yIGVtcHR5IHN0cmluZyBmb3IgdGhlIHBhY2thZ2VzIGVudHJ5IGZpbGVcbiAgICAgKi9cbiAgICBhc3luYyBsYXVuY2hNb2R1bGUocGF0aCwgb3V0LCBvcHRpb25zKSB7XG4gICAgICAgIHBhdGggPSByZWxQYXRoKHBhdGggfHwgXCJcIik7XG4gICAgICAgIC8vIElNUCB1c2UgY29ycmVjdCBucG0gdmVyc2lvbiBmb3IgdGhlIG5ld2VzdCB3b3JrZXIgYnVpbGQgKGV4dGVuc2lvbnJ1bm5lckB2ZXJzaW9uKVxuICAgICAgICBjb25zdCBjb3JzV29ya2VyID0gbmV3IENvcnNXb3JrZXIoanNkZWxpdnIgKyBcIi9ucG0vZXh0ZW5zaW9ucnVubmVyQDEuMC4zMy93b3JrZXIuanNcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuaW5pdC5uYW1lfToke3BhdGh9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGNvcnNXb3JrZXIuaW5pdCgpO1xuICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmluaXRNb2R1bGUoY29yc1dvcmtlci53b3JrZXIsIGpzZGVsaXZyLCBwYXRoLCBvdXQsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICByZXR1cm4gbW9kLnN0YXJ0KCk7XG4gICAgfVxuICAgIGFzeW5jIGxhdW5jaENvbXBvbmVudChwYXJlbnRFbGVtZW50LCBwYXRoLCBvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcGF0aCA9IHJlbFBhdGgocGF0aCk7XG4gICAgICAgIC8vIE1vc3QgQ0ROcyBkbyBub3QgZGlyZWN0bHkgc2VydmUgaHRtbCBmaWxlcywgdGhleSBzZXJ2ZSB0aGUgaHRtbCBhcyBhIHN0cmluZyBpbiBhIHJlc3BvbnNlLiBTbyBkb2VzIGpzZGVsaXZyIGFuZCB1bnBrZy5cbiAgICAgICAgLy8gU28gd2UgZmV0Y2ggdGhlIGh0bWwgYW5kIHVzZSBpZnJtLnNyY2RvYyB0byBsb2FkIHRoZSBodG1sXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIGxldCBvcmlnaW47XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiZ2l0aHViXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFtvd25lciwgcmVwb10gPSB0aGlzLmluaXQubmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICBvcmlnaW4gPSBcImh0dHBzOi8vcmF3LmdpdGhhY2suY29tXCI7XG4gICAgICAgICAgICB1cmwgPSBgJHtvcmlnaW59LyR7b3duZXJ9LyR7cmVwb30vJHt0aGlzLmluaXQudmVyc2lvbn0vJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcIm5wbVwiKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNlZSBJbmZvLm1kIENETnNcbiAgICAgICAgICAgIG9yaWdpbiA9IFwiaHR0cHM6Ly91bnBrZy5jb21cIjtcbiAgICAgICAgICAgIHVybCA9IGAke29yaWdpbn0vJHt0aGlzLmluaXQubmFtZX1AJHt0aGlzLmluaXQudmVyc2lvbn0vJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgICAgIGlmcmFtZS5zcmMgPSB1cmw7XG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzYW5kYm94XCIsIFwiYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpblwiKTtcbiAgICAgICAgLy8gVE9ET0QgbW9yZSBhdHRycz9cbiAgICAgICAgLy8gd2FpdCBmb3IgbG9hZFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcImBjb250ZW50V2luZG93YG5kb3cgbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kID0gdGhpcy5pbml0TW9kdWxlKGlmcmFtZS5jb250ZW50V2luZG93LCBvcmlnaW4sIHBhdGgsIG91dCwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtb2Quc3RhcnQoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0TW9kdWxlKHRhcmdldCwgb3JpZ2luLCBwYXRoLCBvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY3JlYXRlIG1ldGFcbiAgICAgICAgbGV0IG1ldGEgPSB7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHJhbmRvbUlkKCksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmluaXQubmFtZSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbml0aWFsU3RhdGU6IHRoaXMuY2FjaGUuZ2V0KHBhdGgpPy5zdGF0ZSxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMuaW5pdC52ZXJzaW9uLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5pbml0LnR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIG1ldGEgPSB0aGlzLmluaXQubWV0YSA/IHRoaXMuaW5pdC5tZXRhKG1ldGEpIDogbWV0YTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWV0YSlcbiAgICAgICAgICAgIG1ldGEgPSBvcHRpb25zLm1ldGEobWV0YSk7XG4gICAgICAgIGlmIChvcHRpb25zLmluaXRpYWxTdGF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWV0YS5pbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgLy8gY3JlYXRlIG1vZHVsZVxuICAgICAgICBjb25zdCBwb3B1bGF0ZVN0YXRlID0gb3B0aW9ucy5hbGxvd1BvcHVsYXRlU3RhdGUgPz8gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1vZCA9IG5ldyBNb2R1bGUodGhpcywge1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgbWV0YTogbWV0YSxcbiAgICAgICAgICAgIG91dCxcbiAgICAgICAgICAgIG9wZXJhdGlvblRpbWVvdXQ6IHRoaXMuaW5pdC5vcGVyYXRpb25UaW1lb3V0LFxuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHRoaXMuaW5pdC5jb25uZWN0aW9uVGltZW91dCxcbiAgICAgICAgICAgIGFsbG93UG9wdWxhdGVTdGF0ZTogdHlwZW9mIHBvcHVsYXRlU3RhdGUgPT09IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgPyBwb3B1bGF0ZVN0YXRlXG4gICAgICAgICAgICAgICAgOiAobmV3U3RhdGUsIG1lcmdlKSA9PiBwb3B1bGF0ZVN0YXRlKG5ld1N0YXRlLCBtZXJnZSwgbW9kKSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBldmVudHNcbiAgICAgICAgbW9kLmFkZEV2ZW50TGlzdGVuZXIobnVsbCwgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LnR5cGUuc3RhcnRzV2l0aChcIm9wOlwiKSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChldi50eXBlLCBldi5wYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZC5hZGRFdmVudExpc3RlbmVyKFwic3RhdGVfcG9wdWxhdGVcIiwgYXN5bmMgKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXYucGF5bG9hZC5vcHRpb25zPy5wb3B1bGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKHBhdGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuZ2V0KHBhdGgpLnN0YXRlID0gZXYucGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IHB1c2hSZXN1bHRzID0gYXdhaXQgdGhpcy5wdXNoU3RhdGUoZXYucGF5bG9hZC5zdGF0ZSwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogeyBub3RJZDogbW9kLmlkLCBwYXRoOiBtb2QubWV0YS5wYXRoIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwic3RhdGVfcG9wdWxhdGVcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBldi5wYXlsb2FkLnN0YXRlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV2LnBheWxvYWQub3B0aW9ucyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHB1c2hSZXN1bHRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb2QuYWRkRXZlbnRMaXN0ZW5lcihcImRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5nZXQocGF0aCk/Lmluc3RhbmNlcy5kZWxldGUobW9kLmlkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwibW9kdWxlX2Rlc3Ryb3lcIiwgbW9kKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXYgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJlcnJvclwiLCB7IGVycm9yOiBldi5wYXlsb2FkLCBvcmlnaW46IG1vZCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNhY2hlXG4gICAgICAgIGxldCBpbnN0YW5jZXMgPSB0aGlzLmNhY2hlLmdldChwYXRoKT8uaW5zdGFuY2VzO1xuICAgICAgICBpZiAoIWluc3RhbmNlcykge1xuICAgICAgICAgICAgaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgeyBpbnN0YW5jZXMsIHN0YXRlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2VzLnNldChtb2QuaWQsIG1vZCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwibW9kdWxlX2xvYWRcIiwgbW9kKTtcbiAgICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0LnR5cGUgKyBcIiVcIiArIHRoaXMuaW5pdC5uYW1lO1xuICAgIH1cbiAgICBnZXQgcGtnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGtnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC50eXBlO1xuICAgIH1cbiAgICAvKiogSWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBvaywgdGhlIGBSZXNwb25zZWAgd2lsbCBiZSBzZXQgb24gdGhlIHRocm93biBlcnJvciAoYEVycm9yLnJlc3BvbnNlYCkgKi9cbiAgICBhc3luYyBsb2FkRmlsZShwYXRoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBsb2FkRmlsZSh0aGlzLmluaXQudHlwZSwgdGhpcy5pbml0Lm5hbWUsIHRoaXMuaW5pdC52ZXJzaW9uLCBwYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgcHVzaFN0YXRlKG5ld1N0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZvckVhY2hNb2R1bGUobW9kdWxlID0+IHtcbiAgICAgICAgICAgIG1vZHVsZS5wdXNoU3RhdGUobmV3U3RhdGUsIHsgbWVyZ2U6IG9wdGlvbnM/Lm1lcmdlID8/IHRydWUgfSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHBhcmFsbGVsOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZm9yRWFjaE1vZHVsZShjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGZhaWxlZDogW10sIGFmZmVjdGVkOiBbXSwgcmVzdWx0OiBbXSwgZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gb3B0aW9ucz8uZmlsdGVyID8gdGhpcy5maWx0ZXJNb2R1bGVzKG9wdGlvbnMuZmlsdGVyKSA6IHRoaXMuZ2V0QWxsTW9kdWxlcygpO1xuICAgICAgICBpZiAob3B0aW9ucz8ucGFyYWxsZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhciA9IGF3YWl0IFByb21pc2UuYWxsKG1vZHVsZXMubWFwKGFzeW5jIChtb2R1bGUpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCwgcmVzdWx0OiBhd2FpdCBjYWxsYmFjayhtb2R1bGUpLCBtb2R1bGUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyLCByZXN1bHQ6IHVuZGVmaW5lZCwgbW9kdWxlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcGFyLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHAuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZhaWxlZC5wdXNoKHAubW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKHAuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFmZmVjdGVkLnB1c2gocC5tb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVzdWx0LnB1c2gocC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXN1bHQucHVzaChhd2FpdCBjYWxsYmFjayhtb2R1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFmZmVjdGVkLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZmFpbGVkLnB1c2gobW9kdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCB0aGlzLmZvckVhY2hNb2R1bGUobW9kdWxlID0+IG1vZHVsZS5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2xlYXJMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJkZXN0cm95XCIsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBhY3Rpb25zO1xuICAgIH1cbiAgICBlcnIoaW5mbywgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXZlbnQgaW5zdGFuY2VvZiBFdmVudFxuICAgICAgICAgICAgPyAoZXZlbnQubWVzc2FnZSB8fCBldmVudC5kYXRhIHx8IFwiXCIpLnRvU3RyaW5nKClcbiAgICAgICAgICAgIDogZXZlbnQgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgID8gZXZlbnQubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAke2luZm99JHttc2cgPyBcIjogXCIgKyBtc2cgOiBcIlwifWApO1xuICAgICAgICBpZiAodGhpcy5sb2dzKVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihpbmZvLCBlcnIpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcImVycm9yXCIsIGVycik7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRzSGFuZGxlciB9IGZyb20gXCIuL0V2ZW50c0hhbmRsZXIuanNcIjtcbmltcG9ydCB7IHJhbmRvbUlkLCByZWNlaXZlRGF0YSB9IGZyb20gXCIuL3NoYXJlZC5qc1wiO1xuLyoqIFJlcHJlc2VudHMgYW4gaWZyYW1lIG9yIGEgd29ya2VyICovXG5leHBvcnQgY2xhc3MgTW9kdWxlIGV4dGVuZHMgRXZlbnRzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoZXh0ZW5zaW9uLCBpbml0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICB0aGlzLmlkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9ncyA9ICEhdGhpcy5leHRlbnNpb24ucHJvdmlkZXIub3B0aW9ucz8ubG9ncztcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIEluIENPUlMgY29udGV4dCB0YXJnZXQgaXMgV2luZG93IChpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgIC8vIFdlIGNhbnQgZGVmaW5lIHRhcmdldC5vbm1lc3NhZ2Ugb3IgdGFyZ2V0Lm9uZXJyb3Igb24gYSBjcm9zcyBvcmlnaW4gV2luZG93XG4gICAgICAgICAgICAvLyBUaGF0cyB3aHkgd2UgbGlzdGVuIHRvIHRoZSBtZXNzYWdlIGV2ZW50IG9uIHRoZSBnbG9iYWwgb2JqZWN0IGFuZCBjaGVjayB0aGUgc291cmNlXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzTGlzdGVuZXIgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG9yaWdpbiA9IFwiXCIgLT4gc2FtZSBvcmlnaW5cbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gIT09IFwiXCIgJiYgZS5vcmlnaW4gIT09IHRoaXMuaW5pdC5vcmlnaW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhPy5fX3Rva2VuICE9PSB0aGlzLm1ldGEuYXV0aFRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlPy5kYXRhPy5fX3R5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZS5kYXRhLl9fdHlwZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXRlX3BvcHVsYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0LmFsbG93UG9wdWxhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlID0gISFlLmRhdGEub3B0aW9ucz8ubWVyZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY2VpdmVkU3RhdGUgPSBlLmRhdGEuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZFN0YXRlIHx8IHR5cGVvZiByZWNlaXZlZFN0YXRlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycihcIkludmFsaWQgc3RhdGVcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWQgPSB0aGlzLmluaXQuYWxsb3dQb3B1bGF0ZVN0YXRlID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5hbGxvd1BvcHVsYXRlU3RhdGU/LihyZWNlaXZlZFN0YXRlLCBtZXJnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgYWxsb3dlZCBidXQgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFsbG93ZWQgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdGUgPSBhbGxvd2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0Lm1lcmdlU3RhdGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzLmluaXQubWVyZ2VTdGF0ZXModGhpcy5zdGF0ZSwgcmVjZWl2ZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0geyAuLi50aGlzLnN0YXRlLCAuLi5yZWNlaXZlZFN0YXRlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSByZWNlaXZlZFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzdGF0ZSBnZXRzIHBvcHVsYXRlZCB0byBldmVyeSBtb2R1bGUgd2l0aCB0aGlzIHBhdGggYnV0IHRoaXMgb25lIGlmIGUuZGF0YS5vcHRpb25zLnBvcHVsYXRlICE9PSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU28gd2Ugc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIG1vZHVsZSBoZXJlLiBGb3IgdGhlIG90aGVyIG1vZHVsZXMgaXRzIHNldCBpbiBwdXNoU3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcInN0YXRlX3BvcHVsYXRlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogZS5kYXRhLm9wdGlvbnMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3BlcmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFyZ3MsIG9wZXJhdGlvbiwgX19wb3J0OiBwb3J0IH0gPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyKFwiT3BlcmF0aW9uIENoYW5uZWwgRXJyb3JcIiwgXCJQb3J0IG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvcCA9IGF3YWl0IHRoaXMuaW5pdC5vdXQ/LltvcGVyYXRpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQub25tZXNzYWdlZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycihcIk9wZXJhdGlvbiBDaGFubmVsIEVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogXCJvcGVyYXRpb246cmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChgb3A6JHtvcGVyYXRpb259YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcy5lcnIoXCJPcGVyYXRpb24gRXhlY3V0aW9uIEVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KGBvcDoke29wZXJhdGlvbn1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChgb3A6JHtvcGVyYXRpb259YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYWR5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcImxvYWRcIiwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgIHdvcmtlciBtZXNzYWdlcyBhcmUgb25seSByZWNlaXZlZCB2aWEgV29ya2VyLm9ubWVzc2FnZSxcbiAgICAgICAgICAgICB3aGVyZWFzIGlmcmFtZSBtZXNzYWdlcyBhcmUgcmVjZWl2ZWQgdmlhIHdpbmRvdy5vbm1lc3NhZ2Ugb3IgaWZyYW1lLmNvbnRlbnRXaW5kb3cub25tZXNzYWdlLlxuICAgICAgICAgICAgIFNvIHdlIG5lZWQgdG8gaGFuZGxlIHdvcmtlcnMgYW5kIGlmcmFtZXMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBXb3JrZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXQudGFyZ2V0IGluc3RhbmNlb2YgV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9ncylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMaXN0ZW5pbmcgb24gd29ya2VyIGZvciBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VzTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSUZyYW1lXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2dzKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxpc3RlbmluZyBvbiB3aW5kb3cgZm9yIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtZXNzYWdlc0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvc3QgbWV0YTpcbiAgICAgICAgICAgIC8vIC0gV29ya2VycyBuZWVkIHRoaXMgdG8gaW1wb3J0IHRoZSBtb2R1bGUgaW4gdGhlIHdvcmtlciBpbml0aWFsaXphdGlvbiwgd2hvaWNoIGR5bmFtaWNhbGx5IGltcG9ydHMgdGhlIG1vZHVsZVxuICAgICAgICAgICAgLy8gLSBJZnJhbWVzIG5lZWQgdGhpcyB0byBpbml0IHRoZWlyIG1ldGFcbiAgICAgICAgICAgIHRoaXMuaW5pdC50YXJnZXQucG9zdE1lc3NhZ2UoeyBfX3R5cGU6IFwibWV0YVwiLCBtZXRhOiB0aGlzLmluaXQubWV0YSB9LCB7IHRhcmdldE9yaWdpbjogdGhpcy5pbml0Lm9yaWdpbiB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmVycihcIkNvbm5lY3Rpb24gdGltZW91dFwiLCBudWxsKSk7XG4gICAgICAgICAgICB9LCB0aGlzLmluaXQuY29ubmVjdGlvblRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IG1ldGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQubWV0YTtcbiAgICB9XG4gICAgZXJyKGluZm8sIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGV2ZW50IGluc3RhbmNlb2YgRXZlbnRcbiAgICAgICAgICAgID8gKGV2ZW50Lm1lc3NhZ2UgfHwgZXZlbnQuZGF0YSB8fCBcIlwiKS50b1N0cmluZygpXG4gICAgICAgICAgICA6IGV2ZW50IGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICA/IGV2ZW50Lm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgJHtpbmZvfSR7bXNnID8gXCI6IFwiICsgbXNnIDogXCJcIn1gKTtcbiAgICAgICAgaWYgKHRoaXMubG9ncylcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoaW5mbywgZXJyKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgICBwb3N0TWVzc2FnZSh0eXBlLCBkYXRhLCB0cmFuc2Zlcikge1xuICAgICAgICB0aGlzLmluaXQudGFyZ2V0LnBvc3RNZXNzYWdlKHsgLi4uZGF0YSwgX190eXBlOiB0eXBlIH0sIHsgdHJhbnNmZXIsIHRhcmdldE9yaWdpbjogdGhpcy5pbml0Lm9yaWdpbiB9KTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZShvcGVyYXRpb24sIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlY2VpdmVEYXRhKHRoaXMuaW5pdC50YXJnZXQsIFwib3BlcmF0aW9uXCIsIHsgYXJncywgb3BlcmF0aW9uIH0sIHRoaXMuaW5pdC5vcmlnaW4sIFtdLCB0aGlzLmluaXQub3BlcmF0aW9uVGltZW91dCk7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hTdGF0ZShuZXdTdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgcztcbiAgICAgICAgaWYgKG9wdGlvbnM/Lm1lcmdlID8/IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbml0Lm1lcmdlU3RhdGVzKSB7XG4gICAgICAgICAgICAgICAgcyA9IHRoaXMuaW5pdC5tZXJnZVN0YXRlcyh0aGlzLnN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzID0geyAuLi50aGlzLnN0YXRlLCAuLi5uZXdTdGF0ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHMgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5wb3N0TWVzc2FnZShcInN0YXRlX3B1c2hcIiwge1xuICAgICAgICAgICAgc3RhdGU6IHMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHM7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pbml0LnRhcmdldCBpbnN0YW5jZW9mIFdvcmtlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQudGFyZ2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcImRlc3Ryb3lcIiwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudHNIYW5kbGVyIH0gZnJvbSBcIi4vRXZlbnRzSGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIi4vRXh0ZW5zaW9uLmpzXCI7XG5leHBvcnQgY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRFeHRlbnNpb24oZXh0ZW5zaW9uSW5pdCkge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uKHRoaXMsIGV4dGVuc2lvbkluaXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXh0ZW5zaW9uLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBleHRlbnNpb246ICR7ZXJyPy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBldmVudHNcbiAgICAgICAgZXh0ZW5zaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0ZV9wb3B1bGF0ZVwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwic3RhdGVfcG9wdWxhdGVcIiwgeyBleHRlbnNpb24sIG1vZHVsZTogZS5wYXlsb2FkLm1vZHVsZSwgc3RhdGU6IGUucGF5bG9hZC5zdGF0ZSwgb3B0aW9uczogZS5wYXlsb2FkLm1vZHVsZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4dGVuc2lvbi5hZGRFdmVudExpc3RlbmVyKG51bGwsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmIChldi50eXBlLnN0YXJ0c1dpdGgoXCJvcDpcIikpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZXYudHlwZSwgZXYucGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBleHRlbnNpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRlc3Ryb3lcIiwgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShleHRlbnNpb24uaWQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJleHRlbnNpb25fZGVzdHJveVwiLCBleHRlbnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJleHRlbnNpb25fbG9hZFwiLCBleHRlbnNpb24pO1xuICAgICAgICAvLyBjYWNoZVxuICAgICAgICB0aGlzLmNhY2hlLnNldChleHRlbnNpb24uaWQsIGV4dGVuc2lvbik7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGFsbEV4dGVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2FjaGUudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXRFeHRlbnNpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLnZhbHVlcygpKTtcbiAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiBleHRlbnNpb24uZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIH1cbn1cbiIsImV4cG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCIuL0V4dGVuc2lvbi5qc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi9Qcm92aWRlci5qc1wiO1xuZXhwb3J0IHsgRXZlbnQgfSBmcm9tIFwiLi9FdmVudHNIYW5kbGVyLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBQcm92aWRlcjtcbiIsImV4cG9ydCBmdW5jdGlvbiByZWxQYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgIGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUpIHtcbiAgICBpZiAoZS5kYXRhICYmIHR5cGVvZiBlLmRhdGEgPT09IFwib2JqZWN0XCIgJiYgZS5kYXRhLl9fdHlwZSA9PT0gdHlwZSlcbiAgICAgICAgcmV0dXJuIGUuZGF0YTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKiAyNSBjaGFyIGxvbmcgcHNldWRvIGNyeXB0aWMgaWQgKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgICBjb25zdCBjaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gICAgbGV0IHVuaXF1ZUlkID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpO1xuICAgICAgICB1bmlxdWVJZCArPSBjaGFyc1tyYW5kb21JbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVJZDtcbn1cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyA9PT0gd2luZG93LnNlbGY7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjZWl2ZURhdGEodGFyZ2V0LCB0eXBlLCBkYXRhLCBvcmlnaW4gPSBcIipcIiwgdHJhbnNmZXIsIGVyclRpbWVvdXQgPSA1MDAwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjb25zdCBvdXQgPSBjaGFubmVsLnBvcnQxO1xuICAgICAgICBjb25zdCBfaW4gPSBjaGFubmVsLnBvcnQyO1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJPcGVyYXRpb24gdGltZW91dFwiKSk7XG4gICAgICAgIH0sIGVyclRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIG91dC5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUgKyBcIjpyZXN1bHRcIik7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF9pbi5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKGluKVwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIG91dC5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKG91dClcIikpO1xuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQucG9zdE1lc3NhZ2UoeyAuLi5kYXRhLCBfX3R5cGU6IHR5cGUsIF9fcG9ydDogX2luIH0sIHsgdGFyZ2V0T3JpZ2luOiBvcmlnaW4sIHRyYW5zZmVyOiBbX2luLCAuLi4odHJhbnNmZXIgfHwgW10pXSB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBqc2RlbGl2ciA9IFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0XCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKHR5cGUsIG5hbWUsIHZlcnNpb24sIHBhdGgpIHtcbiAgICBsZXQgYmFzZVVybDtcbiAgICBpZiAodHlwZSA9PT0gXCJnaXRodWJcIikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgIGJhc2VVcmwgPSBgJHtqc2RlbGl2cn0vZ2gvJHtvd25lcn0vJHtyZXBvfUAke3ZlcnNpb259L2A7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwibnBtXCIpIHtcbiAgICAgICAgYmFzZVVybCA9IGAke2pzZGVsaXZyfS9ucG0vJHtuYW1lfUAke3ZlcnNpb259L2A7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHJlbFBhdGgocGF0aCk7XG4gICAgICAgIHJldHVybiBiYXNlVXJsICsgcGF0aDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYmFzZVVybDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkRmlsZSh0eXBlLCBuYW1lLCB2ZXJzaW9uLCBwYXRoKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKVxuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGdldFVybCh0eXBlLCBuYW1lLCB2ZXJzaW9uLCBwYXRoKSwgdHlwZSA9PT0gXCJnaXRodWJcIiA/IHt9IDoge30pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGZpbGU6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBmaWxlOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IFByb3ZpZGVyIGZyb20gXCIuLi8uLi9pbmRleFwiO1xuY29uc3QgY29tbWl0U2hhID0gXCIxOTIyOWQxMDlmMmI1MzgyOTJlNzhmMzE5ZGQwNmI1MDYyNTIzYzZkXCI7XG5tYWluKCkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG5jb25zdCBwcm92aWRlckFwaSA9IHtcbiAgICBlY2hvOiB0ZXh0ID0+IHtcbiAgICAgICAgdGV4dCA9IHRleHQgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHRleHQgKyBcIiAgXCIgKyB0ZXh0ICsgXCIgIFwiICsgdGV4dDtcbiAgICB9LFxuICAgIGFsZXJ0OiBtZXNzYWdlID0+IHtcbiAgICAgICAgYWxlcnQobWVzc2FnZSB8fCBcIjxlbXB0eT5cIik7XG4gICAgfSxcbiAgICBwcmludDogKC4uLnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcmludFwiKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJpbnQ6XCIsICh0ZXh0IHx8IFtcIjxlbXB0eT5cIl0pLmpvaW4oXCIgXCIpKTtcbiAgICB9LFxuICAgIGdyZWV0OiAobmFtZSwgYWdlKSA9PiB7XG4gICAgICAgIGFsZXJ0KFwiSGVsbG8gXCIgKyBuYW1lICsgXCIgQUdFIFwiICsgYWdlKTtcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGxhdW5jaElGcmFtZXMoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZnJhbWVcIik7XG4gICAgY29uc3QgY29udGFpbmVyMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaWZyYW1lMlwiKTtcbiAgICBjb25zdCByZXNldEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzZXRcIik7XG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIyICYmIHJlc2V0QnRuKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudE1vZHVsZSA9IGF3YWl0IGV4dGVuc2lvbi5sYXVuY2hDb21wb25lbnQoY29udGFpbmVyLCBcImRpc3QvZnJhbWVzL2NvdW50ZXIvY291bnRlci5odG1sXCIsIHByb3ZpZGVyQXBpLCB7IGFsbG93UG9wdWxhdGVTdGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50TW9kdWxlMiA9IGF3YWl0IGV4dGVuc2lvbi5sYXVuY2hDb21wb25lbnQoY29udGFpbmVyMiwgXCJkaXN0L2ZyYW1lcy9jb3VudGVyL2NvdW50ZXIuaHRtbFwiLCBwcm92aWRlckFwaSwgeyBhbGxvd1BvcHVsYXRlU3RhdGU6IHRydWUgfSk7XG4gICAgICAgIHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvdW50ZXIgPSBhd2FpdCBjb21wb25lbnRNb2R1bGUuZXhlY3V0ZShcImluY3JlbWVudFwiKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbXBvbmVudE1vZHVsZTIuZXhlY3V0ZShcImluY3JlbWVudFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBOZXcgY291bnRlciA8JHtuZXdDb3VudGVyfT4gcmV0dXJuZWQgYnkgJ2luY3JlbWVudCcgZXhlY3V0ZSAoU2hvdWxkIGFsc28gYmUgZGlzcGxheWVkIGluIHRoZSBpZnJhbWUpYCk7XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICByZXNldEJ0bi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgY29tcG9uZW50TW9kdWxlLmV4ZWN1dGUoXCJyZXNldFwiKTtcbiAgICAgICAgICAgIGNvbXBvbmVudE1vZHVsZS5leGVjdXRlKFwicHJpbnRcIiwgXCJSZXNldHRlZFwiLCBcImZyb21cIiwgXCJtYWluIHdpbmRvd1wiKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBsYXVuY2hNb2R1bGUoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgbW9kdWxlID0gYXdhaXQgZXh0ZW5zaW9uLmxhdW5jaE1vZHVsZShcImRpc3QvbWF0aC5qc1wiLCBwcm92aWRlckFwaSk7XG4gICAgY29uc29sZS5sb2coXCJNb2R1bGUgbG9hZGVkOlwiLCBleHRlbnNpb24pO1xuICAgIGNvbnN0IG9wZXJhdGlvbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BlcmF0aW9uXCIpO1xuICAgIGlmIChvcGVyYXRpb25CdG4pIHtcbiAgICAgICAgb3BlcmF0aW9uQnRuLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1vZHVsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxlcnQoXCJNb2R1bGUgbm90IGxvYWRlZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IGF3YWl0IG1vZHVsZS5leGVjdXRlKFwiYWRkXCIsIDEsIDUpO1xuICAgICAgICAgICAgY29uc3QgZCA9IGF3YWl0IG1vZHVsZS5leGVjdXRlKFwic3Vic3RyYWN0XCIsIDEwLCAyKTtcbiAgICAgICAgICAgIGFsZXJ0KFwiU3VtOiBcIiArIHN1bSArIFwiIFN1YjogXCIgKyBkKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGUgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIk1lc3NhZ2UgcmVjZWl2ZWQgOjpcIiwgZS5kYXRhKTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm92ID0gbmV3IFByb3ZpZGVyKHsgbG9nczogdHJ1ZSB9KTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBhd2FpdCBwcm92LmxvYWRFeHRlbnNpb24oe1xuICAgICAgICB0eXBlOiBcImdpdGh1YlwiLFxuICAgICAgICBuYW1lOiBcImFuZHJlLWhjdHVsYy9leHRlbnNpb25ydW5uZXItdGVzdC1leHRlbnNpb25cIixcbiAgICAgICAgdmVyc2lvbjogY29tbWl0U2hhLFxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKFwiRXh0ZW5zaW9uIGxvYWRlZDpcIiwgZXh0ZW5zaW9uKTtcbiAgICBjb25zdCBpbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvXCIpO1xuICAgIGlmIChpbmZvKVxuICAgICAgICBpbmZvLmlubmVySFRNTCA9IGAke2V4dGVuc2lvbi5wa2cubmFtZX1AJHtleHRlbnNpb24ucGtnLnZlcnNpb259IFNIQSAke2NvbW1pdFNoYX1gO1xuICAgIGxhdW5jaE1vZHVsZShleHRlbnNpb24pLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKFwiRXJyb3IgbGF1bmNoaW5nIG1vZHVsZVwiLCBlcnIpKTtcbiAgICBsYXVuY2hJRnJhbWVzKGV4dGVuc2lvbikuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsYXVuY2hpbmcgaWZyYW1lXCIsIGVycikpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <h2>Module (dist/math.js)</h2>
        <button id="operation">Operation (add and substract)</button>
        <h2>IFrame (dist/frames/counter/index.html)</h2>
        <button id="increment">Counter increment</button>
        <div style="display: flex; gap: 10px;">
            <div id="iframe" style="height: 500px width: 500px;;"></div>
            <div id="iframe2" style="height: 500px width: 500px;;"></div>
        </div>

        <button id="reset">Reset counter (frame1)</button>
    </body>
</html>
