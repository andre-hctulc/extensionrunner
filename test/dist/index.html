<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"../index.js\");\n\n\nmain().catch(err => console.error(err));\n\n\n// https://cdn.jsdelivr.net/npm/extensionrunner/worker.js\nasync function main() {\n    addEventListener(\"message\", e => {\n        console.log(\"Message received ::\", e.data);\n    });\n\n    const prov = new _index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ logs: true });\n    const commitSha = \"68df0ddaffe60addcc97ffc3bd045ee1016e4231\";\n    const extension = await prov.loadExtension({\n        type: \"github\",\n        name: \"andre-hctulc/extensionrunner-test-extension\",\n        version: commitSha,\n        out: {\n            echo: text => alert(text + \" ... \" + text + \" .. . .    .\" + text),\n        },\n        onStatePush: (newState, module) => {\n            alert(\"State Push received:\", newState);\n        },\n    });\n\n    console.log(\"Extension loaded:\", extension);\n\n    const info = document.getElementById(\"info\");\n    info.innerHTML = `Test-Extension loaded: ${extension.pkg.name}@${extension.pkg.version} SHA ${commitSha}`;\n\n    // pushState\n\n    const stateBtn = document.getElementById(\"state\");\n\n    let counter = 0;\n\n    stateBtn.onclick = () => {\n        extension.pushState({ message: \"Counter: \" + ++counter });\n    };\n\n    // launch\n\n    launchModule(extension).catch(err => console.error(\"Error launching module\", err));\n    // launchIFrame(extension).catch(err => console.error(\"Error launching iframe\", err));\n}\n\nasync function launchModule(extension) {\n    const module = await extension.launchModule(\"dist/math.js\");\n\n    console.log(\"Module loaded:\", extension);\n\n    // module operations\n\n    const eventBtn = document.getElementById(\"event\");\n    const operationBtn = document.getElementById(\"operation\");\n\n    eventBtn.onclick = () => {\n        extension.emitEvent(\"greet\", \"Hello world!\");\n    };\n\n    operationBtn.onclick = async () => {\n        if (!module) return alert(\"Module not loaded\");\n        const sum = await module.execute(\"add\", 1, 5);\n        const d = await module.execute(\"substract\", 10, 2);\n        alert(\"Sum: \" + sum + \" Sub: \" + d);\n    };\n}\n\nasync function launchIFrame(extension) {\n    // iframe\n\n    const container = document.getElementById(\"iframe\");\n\n    if (container) {\n        const iframeModule = await extension.launchIFrame(container, \"dist/frames/counter/index.html\", {});\n    }\n}\n\n\n//# sourceURL=webpack://test/./src/index.js?");

/***/ }),

/***/ "../CorsWorker.js":
/*!************************!*\
  !*** ../CorsWorker.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CorsWorker: () => (/* binding */ CorsWorker)\n/* harmony export */ });\n/*\nSource: https://github.com/webpack/webpack/discussions/14648\n\nBrowsers do not support CORS for web workers (but they should?). This is a workaround to load a script from a different origin.\n*/\nclass CorsWorker {\n    constructor(url, options) {\n        this.url = url;\n        this.options = options;\n        this.inited = false;\n    }\n    async init() {\n        if (this.inited)\n            return this;\n        this.inited = true;\n        try {\n            const response = await fetch(this.url);\n            if (!response.ok)\n                throw new Error();\n            const text = await response.text();\n            const objectURL = URL.createObjectURL(new Blob([text], {\n                type: \"application/javascript\",\n            }));\n            this._worker = new Worker(objectURL, { type: this.options?.type, name: this.options?.name });\n        }\n        catch (err) {\n            throw new Error(\"Failed to create worker\");\n        }\n        return this;\n    }\n    get worker() {\n        if (!this._worker)\n            throw new Error(\"CorsWorker did not start properly\");\n        return this._worker;\n    }\n}\n\n\n//# sourceURL=webpack://test/../CorsWorker.js?");

/***/ }),

/***/ "../Extension.js":
/*!***********************!*\
  !*** ../Extension.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Extension: () => (/* binding */ Extension)\n/* harmony export */ });\n/* harmony import */ var _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CorsWorker.js */ \"../CorsWorker.js\");\n/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Module.js */ \"../Module.js\");\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared.js */ \"../shared.js\");\n\n\n\nconst jsdelivr = \"https://cdn.jsdelivr.net\";\nclass Extension extends _shared_js__WEBPACK_IMPORTED_MODULE_2__.Events {\n    constructor(provider, init) {\n        super();\n        this.provider = provider;\n        this.init = init;\n        this.url = \"\";\n        this._pkg = {};\n        this.started = false;\n        /** `<module_id, { instances: <Module, data>, sharedState: any }>` */\n        this.cache = new Map();\n        if (this.type === \"github\") {\n            const [owner, repo] = this.init.name.split(\"/\");\n            this.url = `${jsdelivr}/gh/${owner}/${repo}@${init.version}/`;\n        }\n        else if (this.type === \"npm\") {\n            this.url = `${jsdelivr}/npm/${init.name}@${init.version}/`;\n        }\n        else\n            throw new Error(\"Invalid type ('npm' or 'github' expected)\");\n    }\n    async start() {\n        if (this.started)\n            return;\n        this.started = true;\n        // load meta (package.json)\n        const file = await this.loadFile(\"package.json\");\n        const text = await file.text();\n        this._pkg = JSON.parse(text);\n    }\n    /**\n     * @param path Use _null_ or empty string for the packages entry file\n     */\n    async launchModule(path, out, meta) {\n        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path || \"\");\n        // TODO npm/extensiontunner@version/...  version not specified -> latest version is used\n        const corsWorker = new _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__.CorsWorker(jsdelivr + \"/npm/extensionrunner/worker.js\", { type: \"module\", name: `${this.init.name}:${path}` });\n        await corsWorker.init();\n        const mod = this.initModule(corsWorker.worker, jsdelivr, path, out, meta);\n        return mod.start();\n    }\n    async launchIFrame(parentElement, path, out, meta) {\n        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path);\n        // Most CDNs do not directly serve html files, they serve the html as a string in a response. So does jsdelivr and unpkg.\n        // So we fetch the html and use ifrm.srcdoc to load the html\n        const iframe = document.createElement(\"iframe\");\n        let url;\n        let origin;\n        if (this.type === \"github\") {\n            const [owner, repo] = this.init.name.split(\"/\");\n            origin = \"https://raw.githack.com\";\n            url = `${origin}/${owner}/${repo}/${this.init.version}/${path}`;\n        }\n        else if (this.type === \"npm\") {\n            // TODO see Info.md CDNs\n            origin = \"https://unpkg.com\";\n            url = `${origin}/${this.init.name}@${this.init.version}/${path}`;\n        }\n        else\n            throw new Error(\"Invalid type ('npm' or 'github' expected)\");\n        iframe.src = url;\n        iframe.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin\");\n        // TODOD more attrs?\n        // wait for load\n        return new Promise((resolve, reject) => {\n            iframe.onload = async (e) => {\n                if (!iframe.contentWindow)\n                    return reject(\"`contentWindow`ndow not defined\");\n                const mod = this.initModule(iframe.contentWindow, origin, path, out, meta);\n                resolve(mod.start());\n            };\n            iframe.addEventListener(\"error\", e => {\n                reject(new Error(e.message));\n            });\n            parentElement.appendChild(iframe);\n        });\n    }\n    initModule(target, origin, path, out, meta) {\n        // genrate random id\n        let _meta = {\n            authToken: (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.randomId)(),\n            name: this.init.name,\n            path,\n            state: this.cache.get(path)?.sharedState,\n            version: this.init.version,\n            type: this.init.type,\n        };\n        _meta = this.init.meta ? this.init.meta(_meta) : _meta;\n        if (meta)\n            _meta = meta(_meta);\n        // create module\n        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_1__.Module(this, origin, target, _meta, out, {\n            onPushState: (newState, populate) => {\n                if (populate)\n                    this.pushState(path, newState, undefined, [mod]);\n                this.init.onPushState?.(newState, mod);\n            },\n            onEvent: (type, payload) => {\n                this.notifyListeners?.(type, payload, mod);\n            },\n            operationTimeout: this.init.operationTimeout,\n            connectionTimeout: this.init.connectionTimeout,\n        });\n        // cache\n        let instances = this.cache.get(path)?.instances;\n        if (!instances) {\n            instances = new Map();\n            this.cache.set(path, { instances, sharedState: undefined });\n        }\n        instances.set(mod, { state: undefined });\n        return mod;\n    }\n    get id() {\n        return this.init.type + \"%\" + this.init.name;\n    }\n    get pkg() {\n        return this._pkg;\n    }\n    get type() {\n        return this.init.type;\n    }\n    getUrl(path, searchParams) {\n        if (searchParams && !searchParams.startsWith(\"?\"))\n            searchParams = \"?\" + searchParams;\n        return this.url + path + (searchParams || \"\");\n    }\n    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */\n    async loadFile(path) {\n        if (path.startsWith(\"/\"))\n            path = path.slice(1);\n        else if (path.startsWith(\"./\"))\n            path = path.slice(2);\n        const response = await fetch(this.getUrl(path), this.type === \"github\" ? {} : {});\n        if (!response.ok) {\n            const error = new Error(`Failed to load file: ${response.statusText}`);\n            error.response = response;\n            throw new Error(`Failed to load file: ${response.statusText}`);\n        }\n        return response;\n    }\n    pushState(moduleId, newState, instance, exclude) {\n        const exclSet = new Set(exclude);\n        const cache = this.cache.get(moduleId);\n        if (cache) {\n            if (instance) {\n                if (!exclSet.has(instance))\n                    instance.pushState(newState);\n            }\n            else {\n                const modules = Array.from(cache.instances.keys());\n                modules.forEach(instance => {\n                    if (!exclSet.has(instance))\n                        instance.pushState(newState);\n                });\n            }\n        }\n    }\n    emitEvent(type, payload, filter) {\n        for (const moduleId of this.cache.keys()) {\n            const modules = Array.from(this.cache.get(moduleId)?.instances.keys() || []);\n            modules.forEach(instance => {\n                if (filter && !filter(moduleId, instance))\n                    return;\n                instance.emitEvent(type, payload);\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://test/../Extension.js?");

/***/ }),

/***/ "../Module.js":
/*!********************!*\
  !*** ../Module.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Module: () => (/* binding */ Module)\n/* harmony export */ });\n/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.js */ \"../shared.js\");\n\n/** Represents an iframe or a worker */\nclass Module {\n    constructor(extension, origin, target, meta, out, options) {\n        this.extension = extension;\n        this.origin = origin;\n        this.target = target;\n        this.meta = meta;\n        this.out = out;\n        this.options = options;\n        this.inited = false;\n        this.started = false;\n        this.logs = !!this.extension.provider.options?.logs;\n    }\n    async start() {\n        if (this.started)\n            return this;\n        this.started = true;\n        return new Promise((resolve, reject) => {\n            // In CORS context target is Window (iframe.contentWindow)\n            // We cant define target.onmessage or target.onerror on a cross origin Window\n            // Thats why we listen to the message event on the global object and check the source\n            let resolved = false;\n            const messagesListener = async (e) => {\n                // authenticate\n                // TODO if (e.origin !== this.origin) return;\n                // TODO if (e.data?.__token !== this.meta.authToken) return;\n                if (typeof e?.data?.__type !== \"string\")\n                    return;\n                const type = e.data.__type;\n                switch (type) {\n                    case \"state_push\":\n                        this._state = e.data.state;\n                        this.options.onPushState?.(e.data.state, !!e.data.populate);\n                        break;\n                    case \"event\":\n                        this.options.onEvent?.(e.data.event, e.data.args);\n                        break;\n                    case \"operation\":\n                        const { args, operation, __port: port } = e.data;\n                        if (!port)\n                            return this.err(\"Operation Channel Error\", \"Port not found\");\n                        const op = await this.out[operation];\n                        if (typeof op !== \"function\")\n                            return this.err(\"Operation not found\", null);\n                        port.onmessageerror = e => {\n                            this.err(\"Operation Channel Error\", e);\n                        };\n                        try {\n                            const result = await op(...args);\n                            port.postMessage({ __type: \"operation:result\", payload: result });\n                        }\n                        catch (err) {\n                            return this.err(\"Operation Execution Error\", err);\n                        }\n                        break;\n                    case \"ready\":\n                        resolved = true;\n                        // init events once\n                        if (!this.inited) {\n                            this.inited = true;\n                            // init postMessage (received by worker.ts or iframe)\n                            const events = new MessageChannel();\n                            const eventsIn = events.port1;\n                            const eventsOut = events.port2;\n                            eventsIn.onmessageerror = e => {\n                                this.err(\"Events Channel (in) Error\", e);\n                            };\n                            eventsOut.onmessageerror = e => {\n                                this.err(\"Events Channel (out) Error\", e);\n                            };\n                            resolve(this);\n                        }\n                        break;\n                }\n            };\n            /*\n             worker messages are only received via Worker.onmessage,\n             whereas iframe messages are received via window.onmessage or iframe.contentWindow.onmessage.\n             So we need to handle workers and iframes differently\n            */\n            // Worker\n            if (this.target instanceof Worker) {\n                if (this.logs)\n                    console.log(\"Listening on worker for messages\");\n                this.target.addEventListener(\"message\", messagesListener);\n            }\n            // IFrame\n            else {\n                if (this.logs)\n                    console.log(\"Listening on window for messages\");\n                window.addEventListener(\"message\", messagesListener);\n            }\n            // Post meta:\n            // - Workers need this to import the module in the worker initialization, whoich dynamically imports the module\n            // - Iframes need this to init their meta\n            this.target.postMessage({ __type: \"meta\", meta: this.meta }, { targetOrigin: \"*\" }); // TODO targetOrigin\n            setTimeout(() => {\n                if (!resolved)\n                    reject(this.err(\"Connection timeout\", null));\n            }, this.options.connectionTimeout || 5000);\n        });\n    }\n    get state() {\n        return this._state;\n    }\n    err(info, event) {\n        const msg = event instanceof Event ? (event.message || event.data || \"\").toString() : event instanceof Error ? event.message : \"\";\n        const err = new Error(`${info}${msg ? \": \" + msg : \"\"}`);\n        this.options?.onError?.(err);\n        console.error(info, err);\n        return err;\n    }\n    postMessage(type, data, transfer) {\n        this.target.postMessage({ ...data, __type: type }, { transfer });\n    }\n    async execute(operation, ...args) {\n        // TODO \"*\" origin\n        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_0__.receiveData)(this.target, \"operation\", { args, operation }, \"*\", [], this.options.operationTimeout);\n    }\n    async emitEvent(type, payload) {\n        this.postMessage(\"event\", { event: type, args: payload });\n    }\n    async pushState(newState) {\n        this.postMessage(\"state_push\", { state: newState });\n    }\n}\n\n\n//# sourceURL=webpack://test/../Module.js?");

/***/ }),

/***/ "../Provider.js":
/*!**********************!*\
  !*** ../Provider.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ \"../Extension.js\");\n\nclass Provider {\n    constructor(options) {\n        this.options = options;\n        this.cache = new Map();\n    }\n    async loadExtension(extensionInit) {\n        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension(this, extensionInit);\n        try {\n            await extension.start();\n        }\n        catch (err) {\n            throw new Error(`Failed to load extension: ${err}`);\n        }\n        this.cache.set(extension.id, extension);\n        return extension;\n    }\n    allExtensions() {\n        return Array.from(this.cache.values());\n    }\n    getExtension(id) {\n        return this.cache.get(id) || null;\n    }\n}\n\n\n//# sourceURL=webpack://test/../Provider.js?");

/***/ }),

/***/ "../index.js":
/*!*******************!*\
  !*** ../index.js ***!
  \*******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ \"../Extension.js\");\n/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ \"../Provider.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);\n\n\n//# sourceURL=webpack://test/../index.js?");

/***/ }),

/***/ "../shared.js":
/*!********************!*\
  !*** ../shared.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   getMessageData: () => (/* binding */ getMessageData),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   postToParent: () => (/* binding */ postToParent),\n/* harmony export */   randomId: () => (/* binding */ randomId),\n/* harmony export */   receiveData: () => (/* binding */ receiveData),\n/* harmony export */   relPath: () => (/* binding */ relPath)\n/* harmony export */ });\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Events_listeners;\nfunction relPath(path) {\n    if (path.startsWith(\"./\"))\n        path = path.slice(2);\n    else if (path.startsWith(\"/\"))\n        path = path.slice(1);\n    return path;\n}\nfunction getMessageData(e, type) {\n    if (e.data && typeof e.data === \"object\" && e.data.__type === type)\n        return e.data;\n    return null;\n}\nfunction randomId() {\n    const timestamp = new Date().getTime();\n    const random = Math.random().toString(36).substring(2, 9);\n    return `${timestamp}${random}`;\n}\nconst isBrowser = typeof window !== \"undefined\" && window === window.self;\n// TODO origin\nfunction postToParent(type, data, origin = \"*\", transfer) {\n    if (isBrowser)\n        window.parent.postMessage({ ...data, __type: type }, origin, transfer || []);\n    else\n        self.postMessage({ ...data, __type: type }, origin, transfer || []);\n}\nasync function receiveData(target, type, data, origin = \"*\", transfer, errTimeout = 5000) {\n    return new Promise((resolve, reject) => {\n        const channel = new MessageChannel();\n        const out = channel.port1;\n        const _in = channel.port2;\n        let resolved = false;\n        setTimeout(() => {\n            if (!resolved)\n                reject(new Error(\"Operation timeout\"));\n        }, errTimeout || 5000);\n        out.onmessage = async (e) => {\n            const data = getMessageData(e, type + \":result\");\n            if (data) {\n                resolved = true;\n                resolve(data.payload);\n            }\n        };\n        _in.onmessageerror = e => {\n            reject(new Error(\"Channel Error (in)\"));\n        };\n        out.onmessageerror = e => {\n            reject(new Error(\"Channel Error (out)\"));\n        };\n        if (target instanceof Worker) {\n            target.postMessage({ ...data, __type: type, __port: _in }, { transfer: [_in, ...(transfer || [])] });\n        }\n        else\n            target.postMessage({ ...data, __type: type, __port: _in }, origin, [_in, ...(transfer || [])]);\n    });\n}\nclass Events {\n    constructor() {\n        _Events_listeners.set(this, new Map());\n    }\n    addEventListener(type, listener) {\n        if (!__classPrivateFieldGet(this, _Events_listeners, \"f\").has(type))\n            __classPrivateFieldGet(this, _Events_listeners, \"f\").set(type, new Set());\n        __classPrivateFieldGet(this, _Events_listeners, \"f\").get(type)?.add(listener);\n    }\n    removeEventListener(type, listener) {\n        __classPrivateFieldGet(this, _Events_listeners, \"f\").get(type)?.delete(listener);\n    }\n    notifyListeners(type, ...args) {\n        __classPrivateFieldGet(this, _Events_listeners, \"f\").get(type)?.forEach(listener => listener(...args));\n    }\n}\n_Events_listeners = new WeakMap();\n\n\n//# sourceURL=webpack://test/../shared.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <button id="operation">Operation (add and substract)</button>
        <button id="state">Push state</button>
        <button id="event">Emit Event (shape_change)</button>
        <div id="iframe"></div>
    </body>
</html>
