<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../CorsWorker.js":
/*!************************!*\
  !*** ../CorsWorker.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CorsWorker: () => (/* binding */ CorsWorker)
/* harmony export */ });
/*
Source: https://github.com/webpack/webpack/discussions/14648

Browsers do not support CORS for web workers (but they should?). This is a workaround to load a script from a different origin.
*/
class CorsWorker {
    constructor(url, options) {
        this.url = url;
        this.options = options;
        this.inited = false;
    }
    async init() {
        if (this.inited)
            return this;
        this.inited = true;
        try {
            const response = await fetch(this.url);
            if (!response.ok)
                throw new Error();
            const text = await response.text();
            const objectURL = URL.createObjectURL(new Blob([text], {
                type: "application/javascript",
            }));
            this._worker = new Worker(objectURL, { type: this.options?.type, name: this.options?.name });
        }
        catch (err) {
            throw new Error("Failed to create worker");
        }
        return this;
    }
    get worker() {
        if (!this._worker)
            throw new Error("CorsWorker did not start properly");
        return this._worker;
    }
}


/***/ }),

/***/ "../EventsHandler.js":
/*!***************************!*\
  !*** ../EventsHandler.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* binding */ Event),
/* harmony export */   EventsHandler: () => (/* binding */ EventsHandler)
/* harmony export */ });
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Event_defaultPrevented, _EventsHandler_listeners, _EventsHandler_globalListeners;
class Event {
    constructor(type, payload) {
        this.type = type;
        this.payload = payload;
        _Event_defaultPrevented.set(this, false);
    }
    preventDefault() {
        __classPrivateFieldSet(this, _Event_defaultPrevented, true, "f");
    }
    get defaultPrevented() {
        return __classPrivateFieldGet(this, _Event_defaultPrevented, "f");
    }
}
_Event_defaultPrevented = new WeakMap();
class EventsHandler {
    constructor() {
        _EventsHandler_listeners.set(this, new Map());
        _EventsHandler_globalListeners.set(this, new Set());
    }
    addEventListener(type, listener) {
        if (!type)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").add(listener);
        else {
            if (!__classPrivateFieldGet(this, _EventsHandler_listeners, "f").has(type))
                __classPrivateFieldGet(this, _EventsHandler_listeners, "f").set(type, new Set());
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.add(listener);
        }
        return listener;
    }
    removeEventListener(type, listener) {
        if (type === null)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").delete(listener);
        else
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.delete(listener);
    }
    emitEvent(type, payload) {
        const ev = new Event(type, payload);
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.forEach(listener => listener(ev));
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").forEach(listener => listener(ev));
        return ev;
    }
    clearListeners() {
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").clear();
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").clear();
    }
}
_EventsHandler_listeners = new WeakMap(), _EventsHandler_globalListeners = new WeakMap();


/***/ }),

/***/ "../Extension.js":
/*!***********************!*\
  !*** ../Extension.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension)
/* harmony export */ });
/* harmony import */ var _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CorsWorker.js */ "../CorsWorker.js");
/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Module.js */ "../Module.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared.js */ "../shared.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");




class Extension extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__.EventsHandler {
    constructor(provider, init) {
        super();
        this.provider = provider;
        this.init = init;
        this.url = "";
        this._pkg = {};
        this.started = false;
        /** `<path, { instances: <Module, data>, sharedState: any }>` */
        this.cache = new Map();
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        // load meta (package.json)
        const file = await this.loadFile("package.json");
        const text = await file.text();
        this._pkg = JSON.parse(text);
    }
    /** When the filter is empty no modules are returned */
    filterModules(filter) {
        const all = this.getAllModules();
        const idsSet = new Set(Array.isArray(filter.id) ? filter.id : [filter.id]);
        const notIdsSet = new Set(Array.isArray(filter.notId) ? filter.notId : [filter.notId]);
        const pathsSet = new Set(Array.isArray(filter.path) ? filter.path : [filter.path]);
        const notPathsSet = new Set(Array.isArray(filter.notPath) ? filter.notPath : [filter.notPath]);
        return all.filter(module => {
            let include = idsSet.has(module.id) || pathsSet.has(module.meta.path) || !!filter.check?.(module);
            if (include && notIdsSet.size && notIdsSet.has(module.id))
                include = false;
            if (include && notPathsSet.size && notPathsSet.has(module.meta.path))
                include = false;
            return include;
        });
    }
    getAllModules() {
        return Array.from(this.cache.values()).flatMap(({ instances }) => Array.from(instances.values()));
    }
    /**
     * @param path Use _null_ or empty string for the packages entry file
     */
    async launchModule(path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path || "");
        // IMP use correct npm version for the newest wroker build (extensionrunner@version)
        const corsWorker = new _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__.CorsWorker(_shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr + "/npm/extensionrunner@1.0.29/worker.js", {
            type: "module",
            name: `${this.init.name}:${path}`,
        });
        await corsWorker.init();
        const mod = this.initModule(corsWorker.worker, _shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr, path, out, options || {});
        return mod.start();
    }
    async launchComponent(parentElement, path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path);
        // Most CDNs do not directly serve html files, they serve the html as a string in a response. So does jsdelivr and unpkg.
        // So we fetch the html and use ifrm.srcdoc to load the html
        const iframe = document.createElement("iframe");
        let url;
        let origin;
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            origin = "https://raw.githack.com";
            url = `${origin}/${owner}/${repo}/${this.init.version}/${path}`;
        }
        else if (this.type === "npm") {
            // TODO see Info.md CDNs
            origin = "https://unpkg.com";
            url = `${origin}/${this.init.name}@${this.init.version}/${path}`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        iframe.src = url;
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
        // TODOD more attrs?
        // wait for load
        return new Promise((resolve, reject) => {
            iframe.onload = async (e) => {
                if (!iframe.contentWindow)
                    return reject("`contentWindow`ndow not defined");
                const mod = this.initModule(iframe.contentWindow, origin, path, out, options || {});
                resolve(mod.start());
            };
            iframe.addEventListener("error", e => {
                reject(new Error(e.message));
            });
            parentElement.appendChild(iframe);
        });
    }
    initModule(target, origin, path, out, options) {
        // create meta
        let meta = {
            authToken: (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.randomId)(),
            name: this.init.name,
            path,
            initialState: this.cache.get(path)?.sharedState,
            version: this.init.version,
            type: this.init.type,
        };
        meta = this.init.meta ? this.init.meta(meta) : meta;
        if (options.meta)
            meta = options.meta(meta);
        if (options.initialState !== undefined)
            meta.initialState = options.initialState;
        // create module
        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_1__.Module(this, {
            origin,
            target,
            meta: meta,
            out,
            operationTimeout: this.init.operationTimeout,
            connectionTimeout: this.init.connectionTimeout,
            allowPopulateState: options.allowPopulateState,
        });
        // propagate events
        mod.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        mod.addEventListener("state_populate", ev => {
            if (this.cache.has(path))
                this.cache.get(path).sharedState = ev.payload;
            this.pushState(ev.payload.state, { filter: { notId: mod.id, path: mod.meta.path } });
            this.emitEvent("state_populate", {
                module: mod,
                state: ev.payload.state,
                options: ev.payload.options,
            });
        });
        mod.addEventListener("destroy", () => {
            this.cache.get(path)?.instances.delete(mod.id);
            this.emitEvent("module_destroy", mod);
        });
        // cache
        let instances = this.cache.get(path)?.instances;
        if (!instances) {
            instances = new Map();
            this.cache.set(path, { instances, sharedState: undefined });
        }
        instances.set(mod.id, mod);
        this.emitEvent("module_load", mod);
        return mod;
    }
    get id() {
        return this.init.type + "%" + this.init.name;
    }
    get pkg() {
        return this._pkg;
    }
    get type() {
        return this.init.type;
    }
    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */
    async loadFile(path) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.loadFile)(this.init.type, this.init.name, this.init.version, path);
    }
    pushState(newState, options) {
        const modules = options?.filter ? this.filterModules(options?.filter || {}) : this.getAllModules();
        for (const module of modules) {
            module.pushState(newState, { merge: !options?.overwrite });
        }
    }
    destroy() {
        const all = this.getAllModules();
        all.forEach(module => module.destroy());
        this.cache.clear();
        this.clearListeners();
        this.emitEvent("destroy", undefined);
    }
}


/***/ }),

/***/ "../Module.js":
/*!********************!*\
  !*** ../Module.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "../shared.js");


/** Represents an iframe or a worker */
class Module extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(extension, init) {
        super();
        this.extension = extension;
        this.init = init;
        this.id = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.randomId)();
        this.started = false;
        this.logs = !!this.extension.provider.options?.logs;
    }
    async start() {
        if (this.started)
            return this;
        this.started = true;
        return new Promise((resolve, reject) => {
            // In CORS context target is Window (iframe.contentWindow)
            // We cant define target.onmessage or target.onerror on a cross origin Window
            // Thats why we listen to the message event on the global object and check the source
            let resolved = false;
            const messagesListener = async (e) => {
                if (e.origin !== this.init.origin)
                    return;
                if (e.data?.__token !== this.meta.authToken)
                    return;
                if (typeof e?.data?.__type !== "string")
                    return;
                const type = e.data.__type;
                switch (type) {
                    case "state_populate":
                        let newState;
                        if (this.init.allowPopulateState) {
                            const merge = !!e.data.options?.merge;
                            const allowed = this.init.allowPopulateState === true ||
                                this.init.allowPopulateState(e.data.state, merge);
                            if (!allowed)
                                return;
                            if (merge) {
                                if (this.init.mergeStates)
                                    newState = this.init.mergeStates(this.state, e.data.state);
                                else
                                    newState = { ...this.state, ...e.data.state };
                            }
                            else
                                newState = e.data.state;
                        }
                        else
                            return;
                        this._state = newState;
                        this.emitEvent("state_populate", {
                            state: newState,
                            options: e.data.options,
                        });
                        break;
                    case "operation":
                        const { args, operation, __port: port } = e.data;
                        if (!port)
                            return this.err("Operation Channel Error", "Port not found");
                        let op = await this.init.out?.[operation];
                        if (typeof op !== "function")
                            op = null;
                        port.onmessageerror = e => {
                            this.err("Operation Channel Error", e);
                        };
                        if (op) {
                            try {
                                const result = await op.apply(this, args);
                                port.postMessage({
                                    __type: "operation:result",
                                    payload: result,
                                });
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result,
                                    error: null,
                                });
                            }
                            catch (err) {
                                const e = this.err("Operation Execution Error", err);
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result: undefined,
                                    error: e,
                                });
                                return;
                            }
                        }
                        else {
                            this.emitEvent(`op:${operation}`, {
                                args,
                                result: undefined,
                                error: null,
                            });
                        }
                        break;
                    case "ready":
                        if (!resolved)
                            resolve(this);
                        this.emitEvent("load", undefined);
                        resolved = true;
                        break;
                }
            };
            /*
             worker messages are only received via Worker.onmessage,
             whereas iframe messages are received via window.onmessage or iframe.contentWindow.onmessage.
             So we need to handle workers and iframes differently
            */
            // Worker
            if (this.init.target instanceof Worker) {
                if (this.logs)
                    console.log("Listening on worker for messages");
                this.init.target.addEventListener("message", messagesListener);
            }
            // IFrame
            else {
                if (this.logs)
                    console.log("Listening on window for messages");
                window.addEventListener("message", messagesListener);
            }
            // Post meta:
            // - Workers need this to import the module in the worker initialization, whoich dynamically imports the module
            // - Iframes need this to init their meta
            this.init.target.postMessage({ __type: "meta", meta: this.init.meta }, { targetOrigin: this.init.origin });
            setTimeout(() => {
                if (!resolved)
                    reject(this.err("Connection timeout", null));
            }, this.init.connectionTimeout || 5000);
        });
    }
    get state() {
        return this._state;
    }
    get meta() {
        return this.init.meta;
    }
    err(info, event) {
        const msg = event instanceof Event
            ? (event.message || event.data || "").toString()
            : event instanceof Error
                ? event.message
                : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        console.error(info, err);
        return err;
    }
    postMessage(type, data, transfer) {
        this.init.target.postMessage({ ...data, __type: type }, { transfer, targetOrigin: this.init.origin });
    }
    async execute(operation, ...args) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.receiveData)(this.init.target, "operation", { args, operation }, this.init.origin, [], this.init.operationTimeout);
    }
    async pushState(newState, options) {
        let s;
        if (options?.merge) {
            if (this.init.mergeStates) {
                s = this.init.mergeStates(this.state, newState);
            }
            else {
                s = { ...this.state, ...newState };
            }
        }
        else
            s = newState;
        this.postMessage("state_push", {
            state: s,
        });
        return s;
    }
    destroy() {
        if (this.init.target instanceof Worker) {
            try {
                this.init.target.terminate();
            }
            catch (err) { }
        }
        this.clearListeners();
        this.emitEvent("destroy", undefined);
    }
}


/***/ }),

/***/ "../Provider.js":
/*!**********************!*\
  !*** ../Provider.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");


class Provider extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(options) {
        super();
        this.options = options;
        this.cache = new Map();
    }
    async loadExtension(extensionInit) {
        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_1__.Extension(this, extensionInit);
        try {
            await extension.start();
        }
        catch (err) {
            throw new Error(`Failed to load extension: ${err?.toString()}`);
        }
        // propagate events
        extension.addEventListener("state_populate", e => {
            this.emitEvent("state_populate", { extension, module: e.payload.module, state: e.payload.state, options: e.payload.module });
        });
        extension.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        extension.addEventListener("destroy", e => {
            this.cache.delete(extension.id);
            this.emitEvent("extension_destroy", extension);
        });
        this.emitEvent("extension_load", extension);
        // cache
        this.cache.set(extension.id, extension);
        return extension;
    }
    allExtensions() {
        return Array.from(this.cache.values());
    }
    getExtension(id) {
        return this.cache.get(id) || null;
    }
    destroy() {
        const extensions = Array.from(this.cache.values());
        extensions.forEach(extension => extension.destroy());
        this.cache.clear();
    }
}


/***/ }),

/***/ "../index.js":
/*!*******************!*\
  !*** ../index.js ***!
  \*******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* reexport safe */ _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__.Event),
/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");
/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ "../Provider.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);


/***/ }),

/***/ "../shared.js":
/*!********************!*\
  !*** ../shared.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMessageData: () => (/* binding */ getMessageData),
/* harmony export */   getUrl: () => (/* binding */ getUrl),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   jsdelivr: () => (/* binding */ jsdelivr),
/* harmony export */   loadFile: () => (/* binding */ loadFile),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   receiveData: () => (/* binding */ receiveData),
/* harmony export */   relPath: () => (/* binding */ relPath)
/* harmony export */ });
function relPath(path) {
    if (path.startsWith("./"))
        path = path.slice(2);
    else if (path.startsWith("/"))
        path = path.slice(1);
    return path;
}
function getMessageData(e, type) {
    if (e.data && typeof e.data === "object" && e.data.__type === type)
        return e.data;
    return null;
}
/** 25 char long pseudo cryptic id */
function randomId() {
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let uniqueId = "";
    for (let i = 0; i < 25; i++) {
        const randomIndex = Math.floor(Math.random() * chars.length);
        uniqueId += chars[randomIndex];
    }
    return uniqueId;
}
const isBrowser = typeof window !== "undefined" && window === window.self;
async function receiveData(target, type, data, origin = "*", transfer, errTimeout = 5000) {
    return new Promise((resolve, reject) => {
        const channel = new MessageChannel();
        const out = channel.port1;
        const _in = channel.port2;
        let resolved = false;
        setTimeout(() => {
            if (!resolved)
                reject(new Error("Operation timeout"));
        }, errTimeout || 5000);
        out.onmessage = async (e) => {
            const data = getMessageData(e, type + ":result");
            if (data) {
                resolved = true;
                resolve(data.payload);
            }
        };
        _in.onmessageerror = e => {
            reject(new Error("Channel Error (in)"));
        };
        out.onmessageerror = e => {
            reject(new Error("Channel Error (out)"));
        };
        target.postMessage({ ...data, __type: type, __port: _in }, { targetOrigin: origin, transfer: [_in, ...(transfer || [])] });
    });
}
const jsdelivr = "https://cdn.jsdelivr.net";
function getUrl(type, name, version, path) {
    let baseUrl;
    if (type === "github") {
        const [owner, repo] = name.split("/");
        baseUrl = `${jsdelivr}/gh/${owner}/${repo}@${version}/`;
    }
    else if (type === "npm") {
        baseUrl = `${jsdelivr}/npm/${name}@${version}/`;
    }
    else
        throw new Error("Invalid type ('npm' or 'github' expected)");
    if (path) {
        path = relPath(path);
        return baseUrl + path;
    }
    else
        return baseUrl;
}
async function loadFile(type, name, version, path) {
    if (path.startsWith("/"))
        path = path.slice(1);
    else if (path.startsWith("./"))
        path = path.slice(2);
    const response = await fetch(getUrl(type, name, version, path), type === "github" ? {} : {});
    if (!response.ok) {
        const error = new Error(`Failed to load file: ${response.statusText}`);
        error.response = response;
        throw new Error(`Failed to load file: ${response.statusText}`);
    }
    return response;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ "../index.js");

const commitSha = "9f134899a073058b43d08be44e2295c9f3f2df39";
main().catch(err => console.error(err));
const providerApi = {
    echo: text => {
        text = text || "";
        return text + "  " + text + "  " + text;
    },
    alert: message => {
        alert(message || "<empty>");
    },
    print: (...text) => {
        const container = document.getElementById("print");
        if (container)
            console.log("Print:", (text || ["<empty>"]).join(" "));
    },
    greet: (name, age) => {
        alert("Hello " + name + " AGE " + age);
    },
};
async function launchIFrames(extension) {
    const container = document.getElementById("iframe");
    const container2 = document.getElementById("iframe2");
    const resetBtn = document.getElementById("reset");
    if (container && container2 && resetBtn) {
        const componentModule = await extension.launchComponent(container, "dist/frames/counter/index.html", providerApi, { allowPopulateState: true });
        const componentModule2 = await extension.launchComponent(container2, "dist/frames/counter/index.html", providerApi, { allowPopulateState: true });
        setInterval(async () => {
            const newCounter = await componentModule.execute("increment");
            await componentModule2.execute("increment");
            console.log(`New counter <${newCounter}> returned by 'increment' execute (Should also be displayed in the iframe)`);
        }, 3000);
        resetBtn.onclick = () => {
            componentModule.execute("reset");
            componentModule.execute("print", "Resetted", "from", "main window");
        };
    }
}
async function launchModule(extension) {
    const module = await extension.launchModule("dist/math.js", providerApi);
    console.log("Module loaded:", extension);
    const operationBtn = document.getElementById("operation");
    if (operationBtn) {
        operationBtn.onclick = async () => {
            if (!module)
                return alert("Module not loaded");
            const sum = await module.execute("add", 1, 5);
            const d = await module.execute("substract", 10, 2);
            alert("Sum: " + sum + " Sub: " + d);
        };
    }
}
async function main() {
    addEventListener("message", e => {
        console.log("Message received ::", e.data);
    });
    const prov = new _index__WEBPACK_IMPORTED_MODULE_0__["default"]({ logs: true });
    const extension = await prov.loadExtension({
        type: "github",
        name: "andre-hctulc/extensionrunner-test-extension",
        version: commitSha,
    });
    console.log("Extension loaded:", extension);
    const info = document.getElementById("info");
    if (info)
        info.innerHTML = `${extension.pkg.name}@${extension.pkg.version} SHA ${commitSha}`;
    launchModule(extension).catch(err => console.error("Error launching module", err));
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsOENBQVEsR0FBRyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUIsR0FBRyx1QkFBdUIsTUFBTSxVQUFVO0FBQ3pGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0Ly4uL0NvcnNXb3JrZXIuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uLi9FdmVudHNIYW5kbGVyLmpzIiwid2VicGFjazovL3Rlc3QvLi4vRXh0ZW5zaW9uLmpzIiwid2VicGFjazovL3Rlc3QvLi4vTW9kdWxlLmpzIiwid2VicGFjazovL3Rlc3QvLi4vUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vdGVzdC8uLi9pbmRleC5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL3NoYXJlZC5qcyIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3Rlc3Qvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdGVzdC8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Rpc2N1c3Npb25zLzE0NjQ4XG5cbkJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IENPUlMgZm9yIHdlYiB3b3JrZXJzIChidXQgdGhleSBzaG91bGQ/KS4gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gbG9hZCBhIHNjcmlwdCBmcm9tIGEgZGlmZmVyZW50IG9yaWdpbi5cbiovXG5leHBvcnQgY2xhc3MgQ29yc1dvcmtlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBpbml0KCkge1xuICAgICAgICBpZiAodGhpcy5pbml0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnVybCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW3RleHRdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgV29ya2VyKG9iamVjdFVSTCwgeyB0eXBlOiB0aGlzLm9wdGlvbnM/LnR5cGUsIG5hbWU6IHRoaXMub3B0aW9ucz8ubmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIHdvcmtlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IHdvcmtlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93b3JrZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JzV29ya2VyIGRpZCBub3Qgc3RhcnQgcHJvcGVybHlcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JrZXI7XG4gICAgfVxufVxuIiwidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9FdmVudF9kZWZhdWx0UHJldmVudGVkLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycztcbmV4cG9ydCBjbGFzcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgcGF5bG9hZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICBfRXZlbnRfZGVmYXVsdFByZXZlbnRlZC5zZXQodGhpcywgZmFsc2UpO1xuICAgIH1cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXZlbnRfZGVmYXVsdFByZXZlbnRlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgZGVmYXVsdFByZXZlbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQsIFwiZlwiKTtcbiAgICB9XG59XG5fRXZlbnRfZGVmYXVsdFByZXZlbnRlZCA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnQgY2xhc3MgRXZlbnRzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycy5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzLnNldCh0aGlzLCBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzLCBcImZcIikuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuaGFzKHR5cGUpKVxuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuc2V0KHR5cGUsIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgfVxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IG51bGwpXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycywgXCJmXCIpLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuZ2V0KHR5cGUpPy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgICBlbWl0RXZlbnQodHlwZSwgcGF5bG9hZCkge1xuICAgICAgICBjb25zdCBldiA9IG5ldyBFdmVudCh0eXBlLCBwYXlsb2FkKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIFwiZlwiKS5nZXQodHlwZSk/LmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZXYpKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMsIFwiZlwiKS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGV2KSk7XG4gICAgICAgIHJldHVybiBldjtcbiAgICB9XG4gICAgY2xlYXJMaXN0ZW5lcnMoKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzLCBcImZcIikuY2xlYXIoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIFwiZlwiKS5jbGVhcigpO1xuICAgIH1cbn1cbl9FdmVudHNIYW5kbGVyX2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCksIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG4iLCJpbXBvcnQgeyBDb3JzV29ya2VyIH0gZnJvbSBcIi4vQ29yc1dvcmtlci5qc1wiO1xuaW1wb3J0IHsgTW9kdWxlIH0gZnJvbSBcIi4vTW9kdWxlLmpzXCI7XG5pbXBvcnQgeyBqc2RlbGl2ciwgbG9hZEZpbGUsIHJhbmRvbUlkLCByZWxQYXRoIH0gZnJvbSBcIi4vc2hhcmVkLmpzXCI7XG5pbXBvcnQgeyBFdmVudHNIYW5kbGVyIH0gZnJvbSBcIi4vRXZlbnRzSGFuZGxlci5qc1wiO1xuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbiBleHRlbmRzIEV2ZW50c0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBpbml0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgdGhpcy51cmwgPSBcIlwiO1xuICAgICAgICB0aGlzLl9wa2cgPSB7fTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBgPHBhdGgsIHsgaW5zdGFuY2VzOiA8TW9kdWxlLCBkYXRhPiwgc2hhcmVkU3RhdGU6IGFueSB9PmAgKi9cbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGxvYWQgbWV0YSAocGFja2FnZS5qc29uKVxuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgdGhpcy5sb2FkRmlsZShcInBhY2thZ2UuanNvblwiKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGZpbGUudGV4dCgpO1xuICAgICAgICB0aGlzLl9wa2cgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgIH1cbiAgICAvKiogV2hlbiB0aGUgZmlsdGVyIGlzIGVtcHR5IG5vIG1vZHVsZXMgYXJlIHJldHVybmVkICovXG4gICAgZmlsdGVyTW9kdWxlcyhmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgYWxsID0gdGhpcy5nZXRBbGxNb2R1bGVzKCk7XG4gICAgICAgIGNvbnN0IGlkc1NldCA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheShmaWx0ZXIuaWQpID8gZmlsdGVyLmlkIDogW2ZpbHRlci5pZF0pO1xuICAgICAgICBjb25zdCBub3RJZHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLm5vdElkKSA/IGZpbHRlci5ub3RJZCA6IFtmaWx0ZXIubm90SWRdKTtcbiAgICAgICAgY29uc3QgcGF0aHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLnBhdGgpID8gZmlsdGVyLnBhdGggOiBbZmlsdGVyLnBhdGhdKTtcbiAgICAgICAgY29uc3Qgbm90UGF0aHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLm5vdFBhdGgpID8gZmlsdGVyLm5vdFBhdGggOiBbZmlsdGVyLm5vdFBhdGhdKTtcbiAgICAgICAgcmV0dXJuIGFsbC5maWx0ZXIobW9kdWxlID0+IHtcbiAgICAgICAgICAgIGxldCBpbmNsdWRlID0gaWRzU2V0Lmhhcyhtb2R1bGUuaWQpIHx8IHBhdGhzU2V0Lmhhcyhtb2R1bGUubWV0YS5wYXRoKSB8fCAhIWZpbHRlci5jaGVjaz8uKG1vZHVsZSk7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZSAmJiBub3RJZHNTZXQuc2l6ZSAmJiBub3RJZHNTZXQuaGFzKG1vZHVsZS5pZCkpXG4gICAgICAgICAgICAgICAgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGUgJiYgbm90UGF0aHNTZXQuc2l6ZSAmJiBub3RQYXRoc1NldC5oYXMobW9kdWxlLm1ldGEucGF0aCkpXG4gICAgICAgICAgICAgICAgaW5jbHVkZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBbGxNb2R1bGVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLnZhbHVlcygpKS5mbGF0TWFwKCh7IGluc3RhbmNlcyB9KSA9PiBBcnJheS5mcm9tKGluc3RhbmNlcy52YWx1ZXMoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcGF0aCBVc2UgX251bGxfIG9yIGVtcHR5IHN0cmluZyBmb3IgdGhlIHBhY2thZ2VzIGVudHJ5IGZpbGVcbiAgICAgKi9cbiAgICBhc3luYyBsYXVuY2hNb2R1bGUocGF0aCwgb3V0LCBvcHRpb25zKSB7XG4gICAgICAgIHBhdGggPSByZWxQYXRoKHBhdGggfHwgXCJcIik7XG4gICAgICAgIC8vIElNUCB1c2UgY29ycmVjdCBucG0gdmVyc2lvbiBmb3IgdGhlIG5ld2VzdCB3cm9rZXIgYnVpbGQgKGV4dGVuc2lvbnJ1bm5lckB2ZXJzaW9uKVxuICAgICAgICBjb25zdCBjb3JzV29ya2VyID0gbmV3IENvcnNXb3JrZXIoanNkZWxpdnIgKyBcIi9ucG0vZXh0ZW5zaW9ucnVubmVyQDEuMC4yOS93b3JrZXIuanNcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICAgICAgICAgIG5hbWU6IGAke3RoaXMuaW5pdC5uYW1lfToke3BhdGh9YCxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGNvcnNXb3JrZXIuaW5pdCgpO1xuICAgICAgICBjb25zdCBtb2QgPSB0aGlzLmluaXRNb2R1bGUoY29yc1dvcmtlci53b3JrZXIsIGpzZGVsaXZyLCBwYXRoLCBvdXQsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICByZXR1cm4gbW9kLnN0YXJ0KCk7XG4gICAgfVxuICAgIGFzeW5jIGxhdW5jaENvbXBvbmVudChwYXJlbnRFbGVtZW50LCBwYXRoLCBvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcGF0aCA9IHJlbFBhdGgocGF0aCk7XG4gICAgICAgIC8vIE1vc3QgQ0ROcyBkbyBub3QgZGlyZWN0bHkgc2VydmUgaHRtbCBmaWxlcywgdGhleSBzZXJ2ZSB0aGUgaHRtbCBhcyBhIHN0cmluZyBpbiBhIHJlc3BvbnNlLiBTbyBkb2VzIGpzZGVsaXZyIGFuZCB1bnBrZy5cbiAgICAgICAgLy8gU28gd2UgZmV0Y2ggdGhlIGh0bWwgYW5kIHVzZSBpZnJtLnNyY2RvYyB0byBsb2FkIHRoZSBodG1sXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIGxldCB1cmw7XG4gICAgICAgIGxldCBvcmlnaW47XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiZ2l0aHViXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IFtvd25lciwgcmVwb10gPSB0aGlzLmluaXQubmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICBvcmlnaW4gPSBcImh0dHBzOi8vcmF3LmdpdGhhY2suY29tXCI7XG4gICAgICAgICAgICB1cmwgPSBgJHtvcmlnaW59LyR7b3duZXJ9LyR7cmVwb30vJHt0aGlzLmluaXQudmVyc2lvbn0vJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcIm5wbVwiKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNlZSBJbmZvLm1kIENETnNcbiAgICAgICAgICAgIG9yaWdpbiA9IFwiaHR0cHM6Ly91bnBrZy5jb21cIjtcbiAgICAgICAgICAgIHVybCA9IGAke29yaWdpbn0vJHt0aGlzLmluaXQubmFtZX1AJHt0aGlzLmluaXQudmVyc2lvbn0vJHtwYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgICAgIGlmcmFtZS5zcmMgPSB1cmw7XG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzYW5kYm94XCIsIFwiYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpblwiKTtcbiAgICAgICAgLy8gVE9ET0QgbW9yZSBhdHRycz9cbiAgICAgICAgLy8gd2FpdCBmb3IgbG9hZFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChcImBjb250ZW50V2luZG93YG5kb3cgbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kID0gdGhpcy5pbml0TW9kdWxlKGlmcmFtZS5jb250ZW50V2luZG93LCBvcmlnaW4sIHBhdGgsIG91dCwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtb2Quc3RhcnQoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0TW9kdWxlKHRhcmdldCwgb3JpZ2luLCBwYXRoLCBvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY3JlYXRlIG1ldGFcbiAgICAgICAgbGV0IG1ldGEgPSB7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHJhbmRvbUlkKCksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmluaXQubmFtZSxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBpbml0aWFsU3RhdGU6IHRoaXMuY2FjaGUuZ2V0KHBhdGgpPy5zaGFyZWRTdGF0ZSxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMuaW5pdC52ZXJzaW9uLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5pbml0LnR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIG1ldGEgPSB0aGlzLmluaXQubWV0YSA/IHRoaXMuaW5pdC5tZXRhKG1ldGEpIDogbWV0YTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWV0YSlcbiAgICAgICAgICAgIG1ldGEgPSBvcHRpb25zLm1ldGEobWV0YSk7XG4gICAgICAgIGlmIChvcHRpb25zLmluaXRpYWxTdGF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWV0YS5pbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZTtcbiAgICAgICAgLy8gY3JlYXRlIG1vZHVsZVxuICAgICAgICBjb25zdCBtb2QgPSBuZXcgTW9kdWxlKHRoaXMsIHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgICAgICBvdXQsXG4gICAgICAgICAgICBvcGVyYXRpb25UaW1lb3V0OiB0aGlzLmluaXQub3BlcmF0aW9uVGltZW91dCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiB0aGlzLmluaXQuY29ubmVjdGlvblRpbWVvdXQsXG4gICAgICAgICAgICBhbGxvd1BvcHVsYXRlU3RhdGU6IG9wdGlvbnMuYWxsb3dQb3B1bGF0ZVN0YXRlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHJvcGFnYXRlIGV2ZW50c1xuICAgICAgICBtb2QuYWRkRXZlbnRMaXN0ZW5lcihudWxsLCBldiA9PiB7XG4gICAgICAgICAgICBpZiAoZXYudHlwZS5zdGFydHNXaXRoKFwib3A6XCIpKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KGV2LnR5cGUsIGV2LnBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0ZV9wb3B1bGF0ZVwiLCBldiA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMocGF0aCkpXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5nZXQocGF0aCkuc2hhcmVkU3RhdGUgPSBldi5wYXlsb2FkO1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUoZXYucGF5bG9hZC5zdGF0ZSwgeyBmaWx0ZXI6IHsgbm90SWQ6IG1vZC5pZCwgcGF0aDogbW9kLm1ldGEucGF0aCB9IH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJzdGF0ZV9wb3B1bGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlOiBtb2QsXG4gICAgICAgICAgICAgICAgc3RhdGU6IGV2LnBheWxvYWQuc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXYucGF5bG9hZC5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb2QuYWRkRXZlbnRMaXN0ZW5lcihcImRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5nZXQocGF0aCk/Lmluc3RhbmNlcy5kZWxldGUobW9kLmlkKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwibW9kdWxlX2Rlc3Ryb3lcIiwgbW9kKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNhY2hlXG4gICAgICAgIGxldCBpbnN0YW5jZXMgPSB0aGlzLmNhY2hlLmdldChwYXRoKT8uaW5zdGFuY2VzO1xuICAgICAgICBpZiAoIWluc3RhbmNlcykge1xuICAgICAgICAgICAgaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQocGF0aCwgeyBpbnN0YW5jZXMsIHNoYXJlZFN0YXRlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2VzLnNldChtb2QuaWQsIG1vZCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwibW9kdWxlX2xvYWRcIiwgbW9kKTtcbiAgICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0LnR5cGUgKyBcIiVcIiArIHRoaXMuaW5pdC5uYW1lO1xuICAgIH1cbiAgICBnZXQgcGtnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGtnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC50eXBlO1xuICAgIH1cbiAgICAvKiogSWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBvaywgdGhlIGBSZXNwb25zZWAgd2lsbCBiZSBzZXQgb24gdGhlIHRocm93biBlcnJvciAoYEVycm9yLnJlc3BvbnNlYCkgKi9cbiAgICBhc3luYyBsb2FkRmlsZShwYXRoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBsb2FkRmlsZSh0aGlzLmluaXQudHlwZSwgdGhpcy5pbml0Lm5hbWUsIHRoaXMuaW5pdC52ZXJzaW9uLCBwYXRoKTtcbiAgICB9XG4gICAgcHVzaFN0YXRlKG5ld1N0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBvcHRpb25zPy5maWx0ZXIgPyB0aGlzLmZpbHRlck1vZHVsZXMob3B0aW9ucz8uZmlsdGVyIHx8IHt9KSA6IHRoaXMuZ2V0QWxsTW9kdWxlcygpO1xuICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICAgICAgICBtb2R1bGUucHVzaFN0YXRlKG5ld1N0YXRlLCB7IG1lcmdlOiAhb3B0aW9ucz8ub3ZlcndyaXRlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGFsbCA9IHRoaXMuZ2V0QWxsTW9kdWxlcygpO1xuICAgICAgICBhbGwuZm9yRWFjaChtb2R1bGUgPT4gbW9kdWxlLmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMuY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcImRlc3Ryb3lcIiwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudHNIYW5kbGVyIH0gZnJvbSBcIi4vRXZlbnRzSGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgcmFuZG9tSWQsIHJlY2VpdmVEYXRhIH0gZnJvbSBcIi4vc2hhcmVkLmpzXCI7XG4vKiogUmVwcmVzZW50cyBhbiBpZnJhbWUgb3IgYSB3b3JrZXIgKi9cbmV4cG9ydCBjbGFzcyBNb2R1bGUgZXh0ZW5kcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihleHRlbnNpb24sIGluaXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBleHRlbnNpb247XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMuaWQgPSByYW5kb21JZCgpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dzID0gISF0aGlzLmV4dGVuc2lvbi5wcm92aWRlci5vcHRpb25zPy5sb2dzO1xuICAgIH1cbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gSW4gQ09SUyBjb250ZXh0IHRhcmdldCBpcyBXaW5kb3cgKGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgLy8gV2UgY2FudCBkZWZpbmUgdGFyZ2V0Lm9ubWVzc2FnZSBvciB0YXJnZXQub25lcnJvciBvbiBhIGNyb3NzIG9yaWdpbiBXaW5kb3dcbiAgICAgICAgICAgIC8vIFRoYXRzIHdoeSB3ZSBsaXN0ZW4gdG8gdGhlIG1lc3NhZ2UgZXZlbnQgb24gdGhlIGdsb2JhbCBvYmplY3QgYW5kIGNoZWNrIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXNMaXN0ZW5lciA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luICE9PSB0aGlzLmluaXQub3JpZ2luKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YT8uX190b2tlbiAhPT0gdGhpcy5tZXRhLmF1dGhUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZT8uZGF0YT8uX190eXBlICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGUuZGF0YS5fX3R5cGU7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdGF0ZV9wb3B1bGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdC5hbGxvd1BvcHVsYXRlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXJnZSA9ICEhZS5kYXRhLm9wdGlvbnM/Lm1lcmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93ZWQgPSB0aGlzLmluaXQuYWxsb3dQb3B1bGF0ZVN0YXRlID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdC5hbGxvd1BvcHVsYXRlU3RhdGUoZS5kYXRhLnN0YXRlLCBtZXJnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXQubWVyZ2VTdGF0ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXMuaW5pdC5tZXJnZVN0YXRlcyh0aGlzLnN0YXRlLCBlLmRhdGEuc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHsgLi4udGhpcy5zdGF0ZSwgLi4uZS5kYXRhLnN0YXRlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBlLmRhdGEuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwic3RhdGVfcG9wdWxhdGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBlLmRhdGEub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYXJncywgb3BlcmF0aW9uLCBfX3BvcnQ6IHBvcnQgfSA9IGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnIoXCJPcGVyYXRpb24gQ2hhbm5lbCBFcnJvclwiLCBcIlBvcnQgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9wID0gYXdhaXQgdGhpcy5pbml0Lm91dD8uW29wZXJhdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3AgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydC5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyKFwiT3BlcmF0aW9uIENoYW5uZWwgRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3AuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlOiBcIm9wZXJhdGlvbjpyZXN1bHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KGBvcDoke29wZXJhdGlvbn1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLmVycihcIk9wZXJhdGlvbiBFeGVjdXRpb24gRXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoYG9wOiR7b3BlcmF0aW9ufWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KGBvcDoke29wZXJhdGlvbn1gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhZHlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwibG9hZFwiLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgd29ya2VyIG1lc3NhZ2VzIGFyZSBvbmx5IHJlY2VpdmVkIHZpYSBXb3JrZXIub25tZXNzYWdlLFxuICAgICAgICAgICAgIHdoZXJlYXMgaWZyYW1lIG1lc3NhZ2VzIGFyZSByZWNlaXZlZCB2aWEgd2luZG93Lm9ubWVzc2FnZSBvciBpZnJhbWUuY29udGVudFdpbmRvdy5vbm1lc3NhZ2UuXG4gICAgICAgICAgICAgU28gd2UgbmVlZCB0byBoYW5kbGUgd29ya2VycyBhbmQgaWZyYW1lcyBkaWZmZXJlbnRseVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIFdvcmtlclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdC50YXJnZXQgaW5zdGFuY2VvZiBXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2dzKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxpc3RlbmluZyBvbiB3b3JrZXIgZm9yIG1lc3NhZ2VzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdC50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbWVzc2FnZXNMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJRnJhbWVcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvZ3MpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTGlzdGVuaW5nIG9uIHdpbmRvdyBmb3IgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1lc3NhZ2VzTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9zdCBtZXRhOlxuICAgICAgICAgICAgLy8gLSBXb3JrZXJzIG5lZWQgdGhpcyB0byBpbXBvcnQgdGhlIG1vZHVsZSBpbiB0aGUgd29ya2VyIGluaXRpYWxpemF0aW9uLCB3aG9pY2ggZHluYW1pY2FsbHkgaW1wb3J0cyB0aGUgbW9kdWxlXG4gICAgICAgICAgICAvLyAtIElmcmFtZXMgbmVlZCB0aGlzIHRvIGluaXQgdGhlaXIgbWV0YVxuICAgICAgICAgICAgdGhpcy5pbml0LnRhcmdldC5wb3N0TWVzc2FnZSh7IF9fdHlwZTogXCJtZXRhXCIsIG1ldGE6IHRoaXMuaW5pdC5tZXRhIH0sIHsgdGFyZ2V0T3JpZ2luOiB0aGlzLmluaXQub3JpZ2luIH0pO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZXJyKFwiQ29ubmVjdGlvbiB0aW1lb3V0XCIsIG51bGwpKTtcbiAgICAgICAgICAgIH0sIHRoaXMuaW5pdC5jb25uZWN0aW9uVGltZW91dCB8fCA1MDAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICBnZXQgbWV0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5tZXRhO1xuICAgIH1cbiAgICBlcnIoaW5mbywgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXZlbnQgaW5zdGFuY2VvZiBFdmVudFxuICAgICAgICAgICAgPyAoZXZlbnQubWVzc2FnZSB8fCBldmVudC5kYXRhIHx8IFwiXCIpLnRvU3RyaW5nKClcbiAgICAgICAgICAgIDogZXZlbnQgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgID8gZXZlbnQubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGAke2luZm99JHttc2cgPyBcIjogXCIgKyBtc2cgOiBcIlwifWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGluZm8sIGVycik7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIHBvc3RNZXNzYWdlKHR5cGUsIGRhdGEsIHRyYW5zZmVyKSB7XG4gICAgICAgIHRoaXMuaW5pdC50YXJnZXQucG9zdE1lc3NhZ2UoeyAuLi5kYXRhLCBfX3R5cGU6IHR5cGUgfSwgeyB0cmFuc2ZlciwgdGFyZ2V0T3JpZ2luOiB0aGlzLmluaXQub3JpZ2luIH0pO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlKG9wZXJhdGlvbiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVjZWl2ZURhdGEodGhpcy5pbml0LnRhcmdldCwgXCJvcGVyYXRpb25cIiwgeyBhcmdzLCBvcGVyYXRpb24gfSwgdGhpcy5pbml0Lm9yaWdpbiwgW10sIHRoaXMuaW5pdC5vcGVyYXRpb25UaW1lb3V0KTtcbiAgICB9XG4gICAgYXN5bmMgcHVzaFN0YXRlKG5ld1N0YXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBzO1xuICAgICAgICBpZiAob3B0aW9ucz8ubWVyZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXQubWVyZ2VTdGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBzID0gdGhpcy5pbml0Lm1lcmdlU3RhdGVzKHRoaXMuc3RhdGUsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSB7IC4uLnRoaXMuc3RhdGUsIC4uLm5ld1N0YXRlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcyA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLnBvc3RNZXNzYWdlKFwic3RhdGVfcHVzaFwiLCB7XG4gICAgICAgICAgICBzdGF0ZTogcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5pbml0LnRhcmdldCBpbnN0YW5jZW9mIFdvcmtlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQudGFyZ2V0LnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcImRlc3Ryb3lcIiwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudHNIYW5kbGVyIH0gZnJvbSBcIi4vRXZlbnRzSGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIi4vRXh0ZW5zaW9uLmpzXCI7XG5leHBvcnQgY2xhc3MgUHJvdmlkZXIgZXh0ZW5kcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRFeHRlbnNpb24oZXh0ZW5zaW9uSW5pdCkge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uKHRoaXMsIGV4dGVuc2lvbkluaXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgZXh0ZW5zaW9uLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBleHRlbnNpb246ICR7ZXJyPy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBldmVudHNcbiAgICAgICAgZXh0ZW5zaW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGF0ZV9wb3B1bGF0ZVwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwic3RhdGVfcG9wdWxhdGVcIiwgeyBleHRlbnNpb24sIG1vZHVsZTogZS5wYXlsb2FkLm1vZHVsZSwgc3RhdGU6IGUucGF5bG9hZC5zdGF0ZSwgb3B0aW9uczogZS5wYXlsb2FkLm1vZHVsZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4dGVuc2lvbi5hZGRFdmVudExpc3RlbmVyKG51bGwsIGV2ID0+IHtcbiAgICAgICAgICAgIGlmIChldi50eXBlLnN0YXJ0c1dpdGgoXCJvcDpcIikpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZXYudHlwZSwgZXYucGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBleHRlbnNpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRlc3Ryb3lcIiwgZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShleHRlbnNpb24uaWQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJleHRlbnNpb25fZGVzdHJveVwiLCBleHRlbnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJleHRlbnNpb25fbG9hZFwiLCBleHRlbnNpb24pO1xuICAgICAgICAvLyBjYWNoZVxuICAgICAgICB0aGlzLmNhY2hlLnNldChleHRlbnNpb24uaWQsIGV4dGVuc2lvbik7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGFsbEV4dGVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2FjaGUudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXRFeHRlbnNpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLnZhbHVlcygpKTtcbiAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiBleHRlbnNpb24uZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIH1cbn1cbiIsImV4cG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gXCIuL0V4dGVuc2lvbi5qc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi9Qcm92aWRlci5qc1wiO1xuZXhwb3J0IHsgRXZlbnQgfSBmcm9tIFwiLi9FdmVudHNIYW5kbGVyLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBQcm92aWRlcjtcbiIsImV4cG9ydCBmdW5jdGlvbiByZWxQYXRoKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgIGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUpIHtcbiAgICBpZiAoZS5kYXRhICYmIHR5cGVvZiBlLmRhdGEgPT09IFwib2JqZWN0XCIgJiYgZS5kYXRhLl9fdHlwZSA9PT0gdHlwZSlcbiAgICAgICAgcmV0dXJuIGUuZGF0YTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKiAyNSBjaGFyIGxvbmcgcHNldWRvIGNyeXB0aWMgaWQgKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgICBjb25zdCBjaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gICAgbGV0IHVuaXF1ZUlkID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgY29uc3QgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpO1xuICAgICAgICB1bmlxdWVJZCArPSBjaGFyc1tyYW5kb21JbmRleF07XG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVJZDtcbn1cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyA9PT0gd2luZG93LnNlbGY7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjZWl2ZURhdGEodGFyZ2V0LCB0eXBlLCBkYXRhLCBvcmlnaW4gPSBcIipcIiwgdHJhbnNmZXIsIGVyclRpbWVvdXQgPSA1MDAwKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjb25zdCBvdXQgPSBjaGFubmVsLnBvcnQxO1xuICAgICAgICBjb25zdCBfaW4gPSBjaGFubmVsLnBvcnQyO1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJPcGVyYXRpb24gdGltZW91dFwiKSk7XG4gICAgICAgIH0sIGVyclRpbWVvdXQgfHwgNTAwMCk7XG4gICAgICAgIG91dC5vbm1lc3NhZ2UgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGdldE1lc3NhZ2VEYXRhKGUsIHR5cGUgKyBcIjpyZXN1bHRcIik7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF9pbi5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKGluKVwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIG91dC5vbm1lc3NhZ2VlcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNoYW5uZWwgRXJyb3IgKG91dClcIikpO1xuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQucG9zdE1lc3NhZ2UoeyAuLi5kYXRhLCBfX3R5cGU6IHR5cGUsIF9fcG9ydDogX2luIH0sIHsgdGFyZ2V0T3JpZ2luOiBvcmlnaW4sIHRyYW5zZmVyOiBbX2luLCAuLi4odHJhbnNmZXIgfHwgW10pXSB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBqc2RlbGl2ciA9IFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0XCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKHR5cGUsIG5hbWUsIHZlcnNpb24sIHBhdGgpIHtcbiAgICBsZXQgYmFzZVVybDtcbiAgICBpZiAodHlwZSA9PT0gXCJnaXRodWJcIikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gbmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAgIGJhc2VVcmwgPSBgJHtqc2RlbGl2cn0vZ2gvJHtvd25lcn0vJHtyZXBvfUAke3ZlcnNpb259L2A7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwibnBtXCIpIHtcbiAgICAgICAgYmFzZVVybCA9IGAke2pzZGVsaXZyfS9ucG0vJHtuYW1lfUAke3ZlcnNpb259L2A7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlICgnbnBtJyBvciAnZ2l0aHViJyBleHBlY3RlZClcIik7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHJlbFBhdGgocGF0aCk7XG4gICAgICAgIHJldHVybiBiYXNlVXJsICsgcGF0aDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gYmFzZVVybDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkRmlsZSh0eXBlLCBuYW1lLCB2ZXJzaW9uLCBwYXRoKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xuICAgIGVsc2UgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKVxuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGdldFVybCh0eXBlLCBuYW1lLCB2ZXJzaW9uLCBwYXRoKSwgdHlwZSA9PT0gXCJnaXRodWJcIiA/IHt9IDoge30pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGZpbGU6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBmaWxlOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IFByb3ZpZGVyIGZyb20gXCIuLi8uLi9pbmRleFwiO1xuY29uc3QgY29tbWl0U2hhID0gXCI5ZjEzNDg5OWEwNzMwNThiNDNkMDhiZTQ0ZTIyOTVjOWYzZjJkZjM5XCI7XG5tYWluKCkuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG5jb25zdCBwcm92aWRlckFwaSA9IHtcbiAgICBlY2hvOiB0ZXh0ID0+IHtcbiAgICAgICAgdGV4dCA9IHRleHQgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHRleHQgKyBcIiAgXCIgKyB0ZXh0ICsgXCIgIFwiICsgdGV4dDtcbiAgICB9LFxuICAgIGFsZXJ0OiBtZXNzYWdlID0+IHtcbiAgICAgICAgYWxlcnQobWVzc2FnZSB8fCBcIjxlbXB0eT5cIik7XG4gICAgfSxcbiAgICBwcmludDogKC4uLnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcmludFwiKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcilcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUHJpbnQ6XCIsICh0ZXh0IHx8IFtcIjxlbXB0eT5cIl0pLmpvaW4oXCIgXCIpKTtcbiAgICB9LFxuICAgIGdyZWV0OiAobmFtZSwgYWdlKSA9PiB7XG4gICAgICAgIGFsZXJ0KFwiSGVsbG8gXCIgKyBuYW1lICsgXCIgQUdFIFwiICsgYWdlKTtcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uIGxhdW5jaElGcmFtZXMoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZnJhbWVcIik7XG4gICAgY29uc3QgY29udGFpbmVyMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaWZyYW1lMlwiKTtcbiAgICBjb25zdCByZXNldEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzZXRcIik7XG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIyICYmIHJlc2V0QnRuKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudE1vZHVsZSA9IGF3YWl0IGV4dGVuc2lvbi5sYXVuY2hDb21wb25lbnQoY29udGFpbmVyLCBcImRpc3QvZnJhbWVzL2NvdW50ZXIvaW5kZXguaHRtbFwiLCBwcm92aWRlckFwaSwgeyBhbGxvd1BvcHVsYXRlU3RhdGU6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudE1vZHVsZTIgPSBhd2FpdCBleHRlbnNpb24ubGF1bmNoQ29tcG9uZW50KGNvbnRhaW5lcjIsIFwiZGlzdC9mcmFtZXMvY291bnRlci9pbmRleC5odG1sXCIsIHByb3ZpZGVyQXBpLCB7IGFsbG93UG9wdWxhdGVTdGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q291bnRlciA9IGF3YWl0IGNvbXBvbmVudE1vZHVsZS5leGVjdXRlKFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgYXdhaXQgY29tcG9uZW50TW9kdWxlMi5leGVjdXRlKFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE5ldyBjb3VudGVyIDwke25ld0NvdW50ZXJ9PiByZXR1cm5lZCBieSAnaW5jcmVtZW50JyBleGVjdXRlIChTaG91bGQgYWxzbyBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlmcmFtZSlgKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIHJlc2V0QnRuLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb21wb25lbnRNb2R1bGUuZXhlY3V0ZShcInJlc2V0XCIpO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kdWxlLmV4ZWN1dGUoXCJwcmludFwiLCBcIlJlc2V0dGVkXCIsIFwiZnJvbVwiLCBcIm1haW4gd2luZG93XCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxhdW5jaE1vZHVsZShleHRlbnNpb24pIHtcbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBleHRlbnNpb24ubGF1bmNoTW9kdWxlKFwiZGlzdC9tYXRoLmpzXCIsIHByb3ZpZGVyQXBpKTtcbiAgICBjb25zb2xlLmxvZyhcIk1vZHVsZSBsb2FkZWQ6XCIsIGV4dGVuc2lvbik7XG4gICAgY29uc3Qgb3BlcmF0aW9uQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGVyYXRpb25cIik7XG4gICAgaWYgKG9wZXJhdGlvbkJ0bikge1xuICAgICAgICBvcGVyYXRpb25CdG4ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghbW9kdWxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhbGVydChcIk1vZHVsZSBub3QgbG9hZGVkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gYXdhaXQgbW9kdWxlLmV4ZWN1dGUoXCJhZGRcIiwgMSwgNSk7XG4gICAgICAgICAgICBjb25zdCBkID0gYXdhaXQgbW9kdWxlLmV4ZWN1dGUoXCJzdWJzdHJhY3RcIiwgMTAsIDIpO1xuICAgICAgICAgICAgYWxlcnQoXCJTdW06IFwiICsgc3VtICsgXCIgU3ViOiBcIiArIGQpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTWVzc2FnZSByZWNlaXZlZCA6OlwiLCBlLmRhdGEpO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb3YgPSBuZXcgUHJvdmlkZXIoeyBsb2dzOiB0cnVlIH0pO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGF3YWl0IHByb3YubG9hZEV4dGVuc2lvbih7XG4gICAgICAgIHR5cGU6IFwiZ2l0aHViXCIsXG4gICAgICAgIG5hbWU6IFwiYW5kcmUtaGN0dWxjL2V4dGVuc2lvbnJ1bm5lci10ZXN0LWV4dGVuc2lvblwiLFxuICAgICAgICB2ZXJzaW9uOiBjb21taXRTaGEsXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coXCJFeHRlbnNpb24gbG9hZGVkOlwiLCBleHRlbnNpb24pO1xuICAgIGNvbnN0IGluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9cIik7XG4gICAgaWYgKGluZm8pXG4gICAgICAgIGluZm8uaW5uZXJIVE1MID0gYCR7ZXh0ZW5zaW9uLnBrZy5uYW1lfUAke2V4dGVuc2lvbi5wa2cudmVyc2lvbn0gU0hBICR7Y29tbWl0U2hhfWA7XG4gICAgbGF1bmNoTW9kdWxlKGV4dGVuc2lvbikuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsYXVuY2hpbmcgbW9kdWxlXCIsIGVycikpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <h2>Module (dist/math.js)</h2>
        <button id="operation">Operation (add and substract)</button>
        <h2>IFrame (dist/frames/counter/index.html)</h2>
        <button id="increment">Counter increment</button>
        <div style="display: flex; gap: 10px;">
            <div id="iframe" style="height: 500px width: 500px;;"></div>
            <div id="iframe2" style="height: 500px width: 500px;;"></div>
        </div>

        <button id="reset">Reset counter (frame1)</button>
    </body>
</html>
