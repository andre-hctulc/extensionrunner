<!DOCTYPE html>
<html>
    <head>
        <title>Test web-extension</title>
        <script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../CorsWorker.js":
/*!************************!*\
  !*** ../CorsWorker.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CorsWorker: () => (/* binding */ CorsWorker)
/* harmony export */ });
/*
Source: https://github.com/webpack/webpack/discussions/14648

Browsers do not support CORS for web workers (but they should?). This is a workaround to load a script from a different origin.
*/
class CorsWorker {
    constructor(url, options) {
        this.url = url;
        this.options = options;
        this.inited = false;
    }
    async init() {
        if (this.inited)
            return this;
        this.inited = true;
        try {
            const response = await fetch(this.url);
            if (!response.ok)
                throw new Error();
            const text = await response.text();
            const objectURL = URL.createObjectURL(new Blob([text], {
                type: "application/javascript",
            }));
            this._worker = new Worker(objectURL, { type: this.options?.type, name: this.options?.name });
        }
        catch (err) {
            throw new Error("Failed to create worker");
        }
        return this;
    }
    get worker() {
        if (!this._worker)
            throw new Error("CorsWorker did not start properly");
        return this._worker;
    }
}


/***/ }),

/***/ "../EventsHandler.js":
/*!***************************!*\
  !*** ../EventsHandler.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* binding */ Event),
/* harmony export */   EventsHandler: () => (/* binding */ EventsHandler)
/* harmony export */ });
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Event_defaultPrevented, _EventsHandler_listeners, _EventsHandler_globalListeners;
class Event {
    constructor(type, payload) {
        this.type = type;
        this.payload = payload;
        _Event_defaultPrevented.set(this, false);
    }
    preventDefault() {
        __classPrivateFieldSet(this, _Event_defaultPrevented, true, "f");
    }
    get defaultPrevented() {
        return __classPrivateFieldGet(this, _Event_defaultPrevented, "f");
    }
}
_Event_defaultPrevented = new WeakMap();
class EventsHandler {
    constructor() {
        _EventsHandler_listeners.set(this, new Map());
        _EventsHandler_globalListeners.set(this, new Set());
    }
    addEventListener(type, listener) {
        if (!type)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").add(listener);
        else {
            if (!__classPrivateFieldGet(this, _EventsHandler_listeners, "f").has(type))
                __classPrivateFieldGet(this, _EventsHandler_listeners, "f").set(type, new Set());
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.add(listener);
        }
        return listener;
    }
    removeEventListener(type, listener) {
        if (type === null)
            __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").delete(listener);
        else
            __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.delete(listener);
    }
    emitEvent(type, payload) {
        const ev = new Event(type, payload);
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").get(type)?.forEach(listener => listener(ev));
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").forEach(listener => listener(ev));
        return ev;
    }
    clearListeners() {
        __classPrivateFieldGet(this, _EventsHandler_globalListeners, "f").clear();
        __classPrivateFieldGet(this, _EventsHandler_listeners, "f").clear();
    }
}
_EventsHandler_listeners = new WeakMap(), _EventsHandler_globalListeners = new WeakMap();


/***/ }),

/***/ "../Extension.js":
/*!***********************!*\
  !*** ../Extension.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension)
/* harmony export */ });
/* harmony import */ var _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CorsWorker.js */ "../CorsWorker.js");
/* harmony import */ var _Module_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Module.js */ "../Module.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared.js */ "../shared.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");




class Extension extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_3__.EventsHandler {
    constructor(provider, init) {
        super();
        this.provider = provider;
        this.init = init;
        this.url = "";
        this._pkg = {};
        this.started = false;
        /** `<path, { instances: <Module, data>, sharedState: any }>` */
        this.cache = new Map();
    }
    async start() {
        if (this.started)
            return;
        this.started = true;
        // load meta (package.json)
        const file = await this.loadFile("package.json");
        const text = await file.text();
        this._pkg = JSON.parse(text);
    }
    /** When the filter is empty no modules are returned */
    filterModules(filter) {
        const all = this.getAllModules();
        const idsSet = new Set(Array.isArray(filter.id) ? filter.id : [filter.id]);
        const notIdsSet = new Set(Array.isArray(filter.notId) ? filter.notId : [filter.notId]);
        const pathsSet = new Set(Array.isArray(filter.path) ? filter.path : [filter.path]);
        const notPathsSet = new Set(Array.isArray(filter.notPath) ? filter.notPath : [filter.notPath]);
        return all.filter(module => {
            let include = idsSet.has(module.id) || pathsSet.has(module.meta.path) || !!filter.check?.(module);
            if (include && notIdsSet.size && notIdsSet.has(module.id))
                include = false;
            if (include && notPathsSet.size && notPathsSet.has(module.meta.path))
                include = false;
            return include;
        });
    }
    getAllModules() {
        return Array.from(this.cache.values()).flatMap(({ instances }) => Array.from(instances.values()));
    }
    /**
     * @param path Use _null_ or empty string for the packages entry file
     */
    async launchModule(path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path || "");
        // IMP use correct npm version for the newest wroker build (extensionrunner@version)
        const corsWorker = new _CorsWorker_js__WEBPACK_IMPORTED_MODULE_0__.CorsWorker(_shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr + "/npm/extensionrunner@1.0.33/worker.js", {
            type: "module",
            name: `${this.init.name}:${path}`,
        });
        await corsWorker.init();
        const mod = this.initModule(corsWorker.worker, _shared_js__WEBPACK_IMPORTED_MODULE_2__.jsdelivr, path, out, options || {});
        return mod.start();
    }
    async launchComponent(parentElement, path, out, options) {
        path = (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.relPath)(path);
        // Most CDNs do not directly serve html files, they serve the html as a string in a response. So does jsdelivr and unpkg.
        // So we fetch the html and use ifrm.srcdoc to load the html
        const iframe = document.createElement("iframe");
        let url;
        let origin;
        if (this.type === "github") {
            const [owner, repo] = this.init.name.split("/");
            origin = "https://raw.githack.com";
            url = `${origin}/${owner}/${repo}/${this.init.version}/${path}`;
        }
        else if (this.type === "npm") {
            // TODO see Info.md CDNs
            origin = "https://unpkg.com";
            url = `${origin}/${this.init.name}@${this.init.version}/${path}`;
        }
        else
            throw new Error("Invalid type ('npm' or 'github' expected)");
        iframe.src = url;
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
        // TODOD more attrs?
        // wait for load
        return new Promise((resolve, reject) => {
            iframe.onload = async (e) => {
                if (!iframe.contentWindow)
                    return reject("`contentWindow`ndow not defined");
                const mod = this.initModule(iframe.contentWindow, origin, path, out, options || {});
                resolve(mod.start());
            };
            iframe.addEventListener("error", e => {
                reject(new Error(e.message));
            });
            parentElement.appendChild(iframe);
        });
    }
    initModule(target, origin, path, out, options) {
        // create meta
        let meta = {
            authToken: (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.randomId)(),
            name: this.init.name,
            path,
            initialState: this.cache.get(path)?.sharedState,
            version: this.init.version,
            type: this.init.type,
        };
        meta = this.init.meta ? this.init.meta(meta) : meta;
        if (options.meta)
            meta = options.meta(meta);
        if (options.initialState !== undefined)
            meta.initialState = options.initialState;
        // create module
        const mod = new _Module_js__WEBPACK_IMPORTED_MODULE_1__.Module(this, {
            origin,
            target,
            meta: meta,
            out,
            operationTimeout: this.init.operationTimeout,
            connectionTimeout: this.init.connectionTimeout,
            allowPopulateState: options.allowPopulateState,
        });
        // propagate events
        mod.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        mod.addEventListener("state_populate", ev => {
            if (this.cache.has(path))
                this.cache.get(path).sharedState = ev.payload;
            this.pushState(ev.payload.state, { filter: { notId: mod.id, path: mod.meta.path } });
            this.emitEvent("state_populate", {
                module: mod,
                state: ev.payload.state,
                options: ev.payload.options,
            });
        });
        mod.addEventListener("destroy", () => {
            this.cache.get(path)?.instances.delete(mod.id);
            this.emitEvent("module_destroy", mod);
        });
        // cache
        let instances = this.cache.get(path)?.instances;
        if (!instances) {
            instances = new Map();
            this.cache.set(path, { instances, sharedState: undefined });
        }
        instances.set(mod.id, mod);
        this.emitEvent("module_load", mod);
        return mod;
    }
    get id() {
        return this.init.type + "%" + this.init.name;
    }
    get pkg() {
        return this._pkg;
    }
    get type() {
        return this.init.type;
    }
    /** If the response is not ok, the `Response` will be set on the thrown error (`Error.response`) */
    async loadFile(path) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_2__.loadFile)(this.init.type, this.init.name, this.init.version, path);
    }
    pushState(newState, options) {
        const modules = options?.filter ? this.filterModules(options?.filter || {}) : this.getAllModules();
        for (const module of modules) {
            module.pushState(newState, { merge: !options?.overwrite });
        }
    }
    destroy() {
        const all = this.getAllModules();
        all.forEach(module => module.destroy());
        this.cache.clear();
        this.clearListeners();
        this.emitEvent("destroy", undefined);
    }
}


/***/ }),

/***/ "../Module.js":
/*!********************!*\
  !*** ../Module.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _shared_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared.js */ "../shared.js");


/** Represents an iframe or a worker */
class Module extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(extension, init) {
        super();
        this.extension = extension;
        this.init = init;
        this.id = (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.randomId)();
        this.started = false;
        this.logs = !!this.extension.provider.options?.logs;
    }
    async start() {
        if (this.started)
            return this;
        this.started = true;
        return new Promise((resolve, reject) => {
            // In CORS context target is Window (iframe.contentWindow)
            // We cant define target.onmessage or target.onerror on a cross origin Window
            // Thats why we listen to the message event on the global object and check the source
            let resolved = false;
            const messagesListener = async (e) => {
                // origin = "" -> same origin
                if (e.origin !== "" && e.origin !== this.init.origin)
                    return;
                if (e.data?.__token !== this.meta.authToken)
                    return;
                if (typeof e?.data?.__type !== "string")
                    return;
                const type = e.data.__type;
                switch (type) {
                    case "state_populate":
                        let newState;
                        if (this.init.allowPopulateState) {
                            const merge = !!e.data.options?.merge;
                            const allowed = this.init.allowPopulateState === true ||
                                this.init.allowPopulateState(e.data.state, merge);
                            if (!allowed)
                                return;
                            if (merge) {
                                if (this.init.mergeStates)
                                    newState = this.init.mergeStates(this.state, e.data.state);
                                else
                                    newState = { ...this.state, ...e.data.state };
                            }
                            else
                                newState = e.data.state;
                        }
                        else
                            return;
                        this._state = newState;
                        this.emitEvent("state_populate", {
                            state: newState,
                            options: e.data.options,
                        });
                        break;
                    case "operation":
                        const { args, operation, __port: port } = e.data;
                        if (!port)
                            return this.err("Operation Channel Error", "Port not found");
                        let op = await this.init.out?.[operation];
                        if (typeof op !== "function")
                            op = null;
                        port.onmessageerror = e => {
                            this.err("Operation Channel Error", e);
                        };
                        if (op) {
                            try {
                                const result = await op.apply(this, args);
                                port.postMessage({
                                    __type: "operation:result",
                                    payload: result,
                                });
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result,
                                    error: null,
                                });
                            }
                            catch (err) {
                                const e = this.err("Operation Execution Error", err);
                                this.emitEvent(`op:${operation}`, {
                                    args,
                                    result: undefined,
                                    error: e,
                                });
                                return;
                            }
                        }
                        else {
                            this.emitEvent(`op:${operation}`, {
                                args,
                                result: undefined,
                                error: null,
                            });
                        }
                        break;
                    case "ready":
                        if (!resolved)
                            resolve(this);
                        this.emitEvent("load", undefined);
                        resolved = true;
                        break;
                }
            };
            /*
             worker messages are only received via Worker.onmessage,
             whereas iframe messages are received via window.onmessage or iframe.contentWindow.onmessage.
             So we need to handle workers and iframes differently
            */
            // Worker
            if (this.init.target instanceof Worker) {
                if (this.logs)
                    console.log("Listening on worker for messages");
                this.init.target.addEventListener("message", messagesListener);
            }
            // IFrame
            else {
                if (this.logs)
                    console.log("Listening on window for messages");
                window.addEventListener("message", messagesListener);
            }
            // Post meta:
            // - Workers need this to import the module in the worker initialization, whoich dynamically imports the module
            // - Iframes need this to init their meta
            this.init.target.postMessage({ __type: "meta", meta: this.init.meta }, { targetOrigin: this.init.origin });
            setTimeout(() => {
                if (!resolved)
                    reject(this.err("Connection timeout", null));
            }, this.init.connectionTimeout || 5000);
        });
    }
    get state() {
        return this._state;
    }
    get meta() {
        return this.init.meta;
    }
    err(info, event) {
        const msg = event instanceof Event
            ? (event.message || event.data || "").toString()
            : event instanceof Error
                ? event.message
                : "";
        const err = new Error(`${info}${msg ? ": " + msg : ""}`);
        console.error(info, err);
        return err;
    }
    postMessage(type, data, transfer) {
        this.init.target.postMessage({ ...data, __type: type }, { transfer, targetOrigin: this.init.origin });
    }
    async execute(operation, ...args) {
        return await (0,_shared_js__WEBPACK_IMPORTED_MODULE_1__.receiveData)(this.init.target, "operation", { args, operation }, this.init.origin, [], this.init.operationTimeout);
    }
    async pushState(newState, options) {
        let s;
        if (options?.merge) {
            if (this.init.mergeStates) {
                s = this.init.mergeStates(this.state, newState);
            }
            else {
                s = { ...this.state, ...newState };
            }
        }
        else
            s = newState;
        this.postMessage("state_push", {
            state: s,
        });
        return s;
    }
    destroy() {
        if (this.init.target instanceof Worker) {
            try {
                this.init.target.terminate();
            }
            catch (err) { }
        }
        this.clearListeners();
        this.emitEvent("destroy", undefined);
    }
}


/***/ }),

/***/ "../Provider.js":
/*!**********************!*\
  !*** ../Provider.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Provider: () => (/* binding */ Provider)
/* harmony export */ });
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");


class Provider extends _EventsHandler_js__WEBPACK_IMPORTED_MODULE_0__.EventsHandler {
    constructor(options) {
        super();
        this.options = options;
        this.cache = new Map();
    }
    async loadExtension(extensionInit) {
        const extension = new _Extension_js__WEBPACK_IMPORTED_MODULE_1__.Extension(this, extensionInit);
        try {
            await extension.start();
        }
        catch (err) {
            throw new Error(`Failed to load extension: ${err?.toString()}`);
        }
        // propagate events
        extension.addEventListener("state_populate", e => {
            this.emitEvent("state_populate", { extension, module: e.payload.module, state: e.payload.state, options: e.payload.module });
        });
        extension.addEventListener(null, ev => {
            if (ev.type.startsWith("op:"))
                this.emitEvent(ev.type, ev.payload);
        });
        extension.addEventListener("destroy", e => {
            this.cache.delete(extension.id);
            this.emitEvent("extension_destroy", extension);
        });
        this.emitEvent("extension_load", extension);
        // cache
        this.cache.set(extension.id, extension);
        return extension;
    }
    allExtensions() {
        return Array.from(this.cache.values());
    }
    getExtension(id) {
        return this.cache.get(id) || null;
    }
    destroy() {
        const extensions = Array.from(this.cache.values());
        extensions.forEach(extension => extension.destroy());
        this.cache.clear();
    }
}


/***/ }),

/***/ "../index.js":
/*!*******************!*\
  !*** ../index.js ***!
  \*******************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Event: () => (/* reexport safe */ _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__.Event),
/* harmony export */   Extension: () => (/* reexport safe */ _Extension_js__WEBPACK_IMPORTED_MODULE_0__.Extension),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extension.js */ "../Extension.js");
/* harmony import */ var _Provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Provider.js */ "../Provider.js");
/* harmony import */ var _EventsHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventsHandler.js */ "../EventsHandler.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Provider_js__WEBPACK_IMPORTED_MODULE_1__.Provider);


/***/ }),

/***/ "../shared.js":
/*!********************!*\
  !*** ../shared.js ***!
  \********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getMessageData: () => (/* binding */ getMessageData),
/* harmony export */   getUrl: () => (/* binding */ getUrl),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   jsdelivr: () => (/* binding */ jsdelivr),
/* harmony export */   loadFile: () => (/* binding */ loadFile),
/* harmony export */   randomId: () => (/* binding */ randomId),
/* harmony export */   receiveData: () => (/* binding */ receiveData),
/* harmony export */   relPath: () => (/* binding */ relPath)
/* harmony export */ });
function relPath(path) {
    if (path.startsWith("./"))
        path = path.slice(2);
    else if (path.startsWith("/"))
        path = path.slice(1);
    return path;
}
function getMessageData(e, type) {
    if (e.data && typeof e.data === "object" && e.data.__type === type)
        return e.data;
    return null;
}
/** 25 char long pseudo cryptic id */
function randomId() {
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let uniqueId = "";
    for (let i = 0; i < 25; i++) {
        const randomIndex = Math.floor(Math.random() * chars.length);
        uniqueId += chars[randomIndex];
    }
    return uniqueId;
}
const isBrowser = typeof window !== "undefined" && window === window.self;
async function receiveData(target, type, data, origin = "*", transfer, errTimeout = 5000) {
    return new Promise((resolve, reject) => {
        const channel = new MessageChannel();
        const out = channel.port1;
        const _in = channel.port2;
        let resolved = false;
        setTimeout(() => {
            if (!resolved)
                reject(new Error("Operation timeout"));
        }, errTimeout || 5000);
        out.onmessage = async (e) => {
            const data = getMessageData(e, type + ":result");
            if (data) {
                resolved = true;
                resolve(data.payload);
            }
        };
        _in.onmessageerror = e => {
            reject(new Error("Channel Error (in)"));
        };
        out.onmessageerror = e => {
            reject(new Error("Channel Error (out)"));
        };
        target.postMessage({ ...data, __type: type, __port: _in }, { targetOrigin: origin, transfer: [_in, ...(transfer || [])] });
    });
}
const jsdelivr = "https://cdn.jsdelivr.net";
function getUrl(type, name, version, path) {
    let baseUrl;
    if (type === "github") {
        const [owner, repo] = name.split("/");
        baseUrl = `${jsdelivr}/gh/${owner}/${repo}@${version}/`;
    }
    else if (type === "npm") {
        baseUrl = `${jsdelivr}/npm/${name}@${version}/`;
    }
    else
        throw new Error("Invalid type ('npm' or 'github' expected)");
    if (path) {
        path = relPath(path);
        return baseUrl + path;
    }
    else
        return baseUrl;
}
async function loadFile(type, name, version, path) {
    if (path.startsWith("/"))
        path = path.slice(1);
    else if (path.startsWith("./"))
        path = path.slice(2);
    const response = await fetch(getUrl(type, name, version, path), type === "github" ? {} : {});
    if (!response.ok) {
        const error = new Error(`Failed to load file: ${response.statusText}`);
        error.response = response;
        throw new Error(`Failed to load file: ${response.statusText}`);
    }
    return response;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index */ "../index.js");

const commitSha = "da64178aa28b66db02ca2c7bce3d3e4a35d02ad6";
main().catch(err => console.error(err));
const providerApi = {
    echo: text => {
        text = text || "";
        return text + "  " + text + "  " + text;
    },
    alert: message => {
        alert(message || "<empty>");
    },
    print: (...text) => {
        const container = document.getElementById("print");
        if (container)
            console.log("Print:", (text || ["<empty>"]).join(" "));
    },
    greet: (name, age) => {
        alert("Hello " + name + " AGE " + age);
    },
};
async function launchIFrames(extension) {
    const container = document.getElementById("iframe");
    const container2 = document.getElementById("iframe2");
    const resetBtn = document.getElementById("reset");
    if (container && container2 && resetBtn) {
        const componentModule = await extension.launchComponent(container, "dist/frames/counter/counter.html", providerApi, { allowPopulateState: true });
        const componentModule2 = await extension.launchComponent(container2, "dist/frames/counter/counter.html", providerApi, { allowPopulateState: true });
        setInterval(async () => {
            const newCounter = await componentModule.execute("increment");
            await componentModule2.execute("increment");
            console.log(`New counter <${newCounter}> returned by 'increment' execute (Should also be displayed in the iframe)`);
        }, 3000);
        resetBtn.onclick = () => {
            componentModule.execute("reset");
            componentModule.execute("print", "Resetted", "from", "main window");
        };
    }
}
async function launchModule(extension) {
    const module = await extension.launchModule("dist/math.js", providerApi);
    console.log("Module loaded:", extension);
    const operationBtn = document.getElementById("operation");
    if (operationBtn) {
        operationBtn.onclick = async () => {
            if (!module)
                return alert("Module not loaded");
            const sum = await module.execute("add", 1, 5);
            const d = await module.execute("substract", 10, 2);
            alert("Sum: " + sum + " Sub: " + d);
        };
    }
}
async function main() {
    addEventListener("message", e => {
        console.log("Message received ::", e.data);
    });
    const prov = new _index__WEBPACK_IMPORTED_MODULE_0__["default"]({ logs: true });
    const extension = await prov.loadExtension({
        type: "github",
        name: "andre-hctulc/extensionrunner-test-extension",
        version: commitSha,
    });
    console.log("Extension loaded:", extension);
    const info = document.getElementById("info");
    if (info)
        info.innerHTML = `${extension.pkg.name}@${extension.pkg.version} SHA ${commitSha}`;
    launchModule(extension).catch(err => console.error("Error launching module", err));
    launchIFrames(extension).catch(err => console.error("Error launching iframe", err));
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25ELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQiw4Q0FBUSxHQUFHLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQixHQUFHLHVCQUF1QixNQUFNLFVBQVU7QUFDekY7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC8uLi9Db3JzV29ya2VyLmpzIiwid2VicGFjazovL3Rlc3QvLi4vRXZlbnRzSGFuZGxlci5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL0V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL01vZHVsZS5qcyIsIndlYnBhY2s6Ly90ZXN0Ly4uL1Byb3ZpZGVyLmpzIiwid2VicGFjazovL3Rlc3QvLi4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGVzdC8uLi9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90ZXN0L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdGVzdC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3Rlc3QvLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcblNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9kaXNjdXNzaW9ucy8xNDY0OFxuXG5Ccm93c2VycyBkbyBub3Qgc3VwcG9ydCBDT1JTIGZvciB3ZWIgd29ya2VycyAoYnV0IHRoZXkgc2hvdWxkPykuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIGxvYWQgYSBzY3JpcHQgZnJvbSBhIGRpZmZlcmVudCBvcmlnaW4uXG4qL1xuZXhwb3J0IGNsYXNzIENvcnNXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pbml0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy51cmwpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt0ZXh0XSwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyID0gbmV3IFdvcmtlcihvYmplY3RVUkwsIHsgdHlwZTogdGhpcy5vcHRpb25zPy50eXBlLCBuYW1lOiB0aGlzLm9wdGlvbnM/Lm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSB3b3JrZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCB3b3JrZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29yc1dvcmtlciBkaWQgbm90IHN0YXJ0IHByb3Blcmx5XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd29ya2VyO1xuICAgIH1cbn1cbiIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRXZlbnRfZGVmYXVsdFByZXZlbnRlZCwgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnM7XG5leHBvcnQgY2xhc3MgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQsIHRydWUsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGRlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudF9kZWZhdWx0UHJldmVudGVkLCBcImZcIik7XG4gICAgfVxufVxuX0V2ZW50X2RlZmF1bHRQcmV2ZW50ZWQgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGNsYXNzIEV2ZW50c0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMuc2V0KHRoaXMsIG5ldyBNYXAoKSk7XG4gICAgICAgIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycy5zZXQodGhpcywgbmV3IFNldCgpKTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycywgXCJmXCIpLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLmhhcyh0eXBlKSlcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLnNldCh0eXBlLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMsIFwiZlwiKS5nZXQodHlwZSk/LmFkZChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlID09PSBudWxsKVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMsIFwiZlwiKS5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2xpc3RlbmVycywgXCJmXCIpLmdldCh0eXBlKT8uZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgZW1pdEV2ZW50KHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgZXYgPSBuZXcgRXZlbnQodHlwZSwgcGF5bG9hZCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuZ2V0KHR5cGUpPy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGV2KSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfZ2xvYmFsTGlzdGVuZXJzLCBcImZcIikuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihldikpO1xuICAgICAgICByZXR1cm4gZXY7XG4gICAgfVxuICAgIGNsZWFyTGlzdGVuZXJzKCkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FdmVudHNIYW5kbGVyX2dsb2JhbExpc3RlbmVycywgXCJmXCIpLmNsZWFyKCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V2ZW50c0hhbmRsZXJfbGlzdGVuZXJzLCBcImZcIikuY2xlYXIoKTtcbiAgICB9XG59XG5fRXZlbnRzSGFuZGxlcl9saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpLCBfRXZlbnRzSGFuZGxlcl9nbG9iYWxMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuIiwiaW1wb3J0IHsgQ29yc1dvcmtlciB9IGZyb20gXCIuL0NvcnNXb3JrZXIuanNcIjtcbmltcG9ydCB7IE1vZHVsZSB9IGZyb20gXCIuL01vZHVsZS5qc1wiO1xuaW1wb3J0IHsganNkZWxpdnIsIGxvYWRGaWxlLCByYW5kb21JZCwgcmVsUGF0aCB9IGZyb20gXCIuL3NoYXJlZC5qc1wiO1xuaW1wb3J0IHsgRXZlbnRzSGFuZGxlciB9IGZyb20gXCIuL0V2ZW50c0hhbmRsZXIuanNcIjtcbmV4cG9ydCBjbGFzcyBFeHRlbnNpb24gZXh0ZW5kcyBFdmVudHNIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgaW5pdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICAgICAgdGhpcy5fcGtnID0ge307XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAvKiogYDxwYXRoLCB7IGluc3RhbmNlczogPE1vZHVsZSwgZGF0YT4sIHNoYXJlZFN0YXRlOiBhbnkgfT5gICovXG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBsb2FkIG1ldGEgKHBhY2thZ2UuanNvbilcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMubG9hZEZpbGUoXCJwYWNrYWdlLmpzb25cIik7XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCBmaWxlLnRleHQoKTtcbiAgICAgICAgdGhpcy5fcGtnID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gICAgLyoqIFdoZW4gdGhlIGZpbHRlciBpcyBlbXB0eSBubyBtb2R1bGVzIGFyZSByZXR1cm5lZCAqL1xuICAgIGZpbHRlck1vZHVsZXMoZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IGFsbCA9IHRoaXMuZ2V0QWxsTW9kdWxlcygpO1xuICAgICAgICBjb25zdCBpZHNTZXQgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkoZmlsdGVyLmlkKSA/IGZpbHRlci5pZCA6IFtmaWx0ZXIuaWRdKTtcbiAgICAgICAgY29uc3Qgbm90SWRzU2V0ID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZpbHRlci5ub3RJZCkgPyBmaWx0ZXIubm90SWQgOiBbZmlsdGVyLm5vdElkXSk7XG4gICAgICAgIGNvbnN0IHBhdGhzU2V0ID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZpbHRlci5wYXRoKSA/IGZpbHRlci5wYXRoIDogW2ZpbHRlci5wYXRoXSk7XG4gICAgICAgIGNvbnN0IG5vdFBhdGhzU2V0ID0gbmV3IFNldChBcnJheS5pc0FycmF5KGZpbHRlci5ub3RQYXRoKSA/IGZpbHRlci5ub3RQYXRoIDogW2ZpbHRlci5ub3RQYXRoXSk7XG4gICAgICAgIHJldHVybiBhbGwuZmlsdGVyKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5jbHVkZSA9IGlkc1NldC5oYXMobW9kdWxlLmlkKSB8fCBwYXRoc1NldC5oYXMobW9kdWxlLm1ldGEucGF0aCkgfHwgISFmaWx0ZXIuY2hlY2s/Lihtb2R1bGUpO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGUgJiYgbm90SWRzU2V0LnNpemUgJiYgbm90SWRzU2V0Lmhhcyhtb2R1bGUuaWQpKVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlICYmIG5vdFBhdGhzU2V0LnNpemUgJiYgbm90UGF0aHNTZXQuaGFzKG1vZHVsZS5tZXRhLnBhdGgpKVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWxsTW9kdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jYWNoZS52YWx1ZXMoKSkuZmxhdE1hcCgoeyBpbnN0YW5jZXMgfSkgPT4gQXJyYXkuZnJvbShpbnN0YW5jZXMudmFsdWVzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhdGggVXNlIF9udWxsXyBvciBlbXB0eSBzdHJpbmcgZm9yIHRoZSBwYWNrYWdlcyBlbnRyeSBmaWxlXG4gICAgICovXG4gICAgYXN5bmMgbGF1bmNoTW9kdWxlKHBhdGgsIG91dCwgb3B0aW9ucykge1xuICAgICAgICBwYXRoID0gcmVsUGF0aChwYXRoIHx8IFwiXCIpO1xuICAgICAgICAvLyBJTVAgdXNlIGNvcnJlY3QgbnBtIHZlcnNpb24gZm9yIHRoZSBuZXdlc3Qgd3Jva2VyIGJ1aWxkIChleHRlbnNpb25ydW5uZXJAdmVyc2lvbilcbiAgICAgICAgY29uc3QgY29yc1dvcmtlciA9IG5ldyBDb3JzV29ya2VyKGpzZGVsaXZyICsgXCIvbnBtL2V4dGVuc2lvbnJ1bm5lckAxLjAuMzMvd29ya2VyLmpzXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwibW9kdWxlXCIsXG4gICAgICAgICAgICBuYW1lOiBgJHt0aGlzLmluaXQubmFtZX06JHtwYXRofWAsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBjb3JzV29ya2VyLmluaXQoKTtcbiAgICAgICAgY29uc3QgbW9kID0gdGhpcy5pbml0TW9kdWxlKGNvcnNXb3JrZXIud29ya2VyLCBqc2RlbGl2ciwgcGF0aCwgb3V0LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgcmV0dXJuIG1vZC5zdGFydCgpO1xuICAgIH1cbiAgICBhc3luYyBsYXVuY2hDb21wb25lbnQocGFyZW50RWxlbWVudCwgcGF0aCwgb3V0LCBvcHRpb25zKSB7XG4gICAgICAgIHBhdGggPSByZWxQYXRoKHBhdGgpO1xuICAgICAgICAvLyBNb3N0IENETnMgZG8gbm90IGRpcmVjdGx5IHNlcnZlIGh0bWwgZmlsZXMsIHRoZXkgc2VydmUgdGhlIGh0bWwgYXMgYSBzdHJpbmcgaW4gYSByZXNwb25zZS4gU28gZG9lcyBqc2RlbGl2ciBhbmQgdW5wa2cuXG4gICAgICAgIC8vIFNvIHdlIGZldGNoIHRoZSBodG1sIGFuZCB1c2UgaWZybS5zcmNkb2MgdG8gbG9hZCB0aGUgaHRtbFxuICAgICAgICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBsZXQgb3JpZ2luO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImdpdGh1YlwiKSB7XG4gICAgICAgICAgICBjb25zdCBbb3duZXIsIHJlcG9dID0gdGhpcy5pbml0Lm5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgb3JpZ2luID0gXCJodHRwczovL3Jhdy5naXRoYWNrLmNvbVwiO1xuICAgICAgICAgICAgdXJsID0gYCR7b3JpZ2lufS8ke293bmVyfS8ke3JlcG99LyR7dGhpcy5pbml0LnZlcnNpb259LyR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJucG1cIikge1xuICAgICAgICAgICAgLy8gVE9ETyBzZWUgSW5mby5tZCBDRE5zXG4gICAgICAgICAgICBvcmlnaW4gPSBcImh0dHBzOi8vdW5wa2cuY29tXCI7XG4gICAgICAgICAgICB1cmwgPSBgJHtvcmlnaW59LyR7dGhpcy5pbml0Lm5hbWV9QCR7dGhpcy5pbml0LnZlcnNpb259LyR7cGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSAoJ25wbScgb3IgJ2dpdGh1YicgZXhwZWN0ZWQpXCIpO1xuICAgICAgICBpZnJhbWUuc3JjID0gdXJsO1xuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwic2FuZGJveFwiLCBcImFsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW5cIik7XG4gICAgICAgIC8vIFRPRE9EIG1vcmUgYXR0cnM/XG4gICAgICAgIC8vIHdhaXQgZm9yIGxvYWRcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmcmFtZS5vbmxvYWQgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoXCJgY29udGVudFdpbmRvd2BuZG93IG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZCA9IHRoaXMuaW5pdE1vZHVsZShpZnJhbWUuY29udGVudFdpbmRvdywgb3JpZ2luLCBwYXRoLCBvdXQsIG9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobW9kLnN0YXJ0KCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmcmFtZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdE1vZHVsZSh0YXJnZXQsIG9yaWdpbiwgcGF0aCwgb3V0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBtZXRhXG4gICAgICAgIGxldCBtZXRhID0ge1xuICAgICAgICAgICAgYXV0aFRva2VuOiByYW5kb21JZCgpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5pbml0Lm5hbWUsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgaW5pdGlhbFN0YXRlOiB0aGlzLmNhY2hlLmdldChwYXRoKT8uc2hhcmVkU3RhdGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmluaXQudmVyc2lvbixcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuaW5pdC50eXBlLFxuICAgICAgICB9O1xuICAgICAgICBtZXRhID0gdGhpcy5pbml0Lm1ldGEgPyB0aGlzLmluaXQubWV0YShtZXRhKSA6IG1ldGE7XG4gICAgICAgIGlmIChvcHRpb25zLm1ldGEpXG4gICAgICAgICAgICBtZXRhID0gb3B0aW9ucy5tZXRhKG1ldGEpO1xuICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG1ldGEuaW5pdGlhbFN0YXRlID0gb3B0aW9ucy5pbml0aWFsU3RhdGU7XG4gICAgICAgIC8vIGNyZWF0ZSBtb2R1bGVcbiAgICAgICAgY29uc3QgbW9kID0gbmV3IE1vZHVsZSh0aGlzLCB7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICAgICAgb3V0LFxuICAgICAgICAgICAgb3BlcmF0aW9uVGltZW91dDogdGhpcy5pbml0Lm9wZXJhdGlvblRpbWVvdXQsXG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogdGhpcy5pbml0LmNvbm5lY3Rpb25UaW1lb3V0LFxuICAgICAgICAgICAgYWxsb3dQb3B1bGF0ZVN0YXRlOiBvcHRpb25zLmFsbG93UG9wdWxhdGVTdGF0ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBldmVudHNcbiAgICAgICAgbW9kLmFkZEV2ZW50TGlzdGVuZXIobnVsbCwgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LnR5cGUuc3RhcnRzV2l0aChcIm9wOlwiKSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChldi50eXBlLCBldi5wYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZC5hZGRFdmVudExpc3RlbmVyKFwic3RhdGVfcG9wdWxhdGVcIiwgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKHBhdGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuZ2V0KHBhdGgpLnNoYXJlZFN0YXRlID0gZXYucGF5bG9hZDtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0YXRlKGV2LnBheWxvYWQuc3RhdGUsIHsgZmlsdGVyOiB7IG5vdElkOiBtb2QuaWQsIHBhdGg6IG1vZC5tZXRhLnBhdGggfSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwic3RhdGVfcG9wdWxhdGVcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBldi5wYXlsb2FkLnN0YXRlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV2LnBheWxvYWQub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbW9kLmFkZEV2ZW50TGlzdGVuZXIoXCJkZXN0cm95XCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZ2V0KHBhdGgpPy5pbnN0YW5jZXMuZGVsZXRlKG1vZC5pZCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcIm1vZHVsZV9kZXN0cm95XCIsIG1vZCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjYWNoZVxuICAgICAgICBsZXQgaW5zdGFuY2VzID0gdGhpcy5jYWNoZS5nZXQocGF0aCk/Lmluc3RhbmNlcztcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KHBhdGgsIHsgaW5zdGFuY2VzLCBzaGFyZWRTdGF0ZTogdW5kZWZpbmVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlcy5zZXQobW9kLmlkLCBtb2QpO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcIm1vZHVsZV9sb2FkXCIsIG1vZCk7XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC50eXBlICsgXCIlXCIgKyB0aGlzLmluaXQubmFtZTtcbiAgICB9XG4gICAgZ2V0IHBrZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BrZztcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQudHlwZTtcbiAgICB9XG4gICAgLyoqIElmIHRoZSByZXNwb25zZSBpcyBub3Qgb2ssIHRoZSBgUmVzcG9uc2VgIHdpbGwgYmUgc2V0IG9uIHRoZSB0aHJvd24gZXJyb3IgKGBFcnJvci5yZXNwb25zZWApICovXG4gICAgYXN5bmMgbG9hZEZpbGUocGF0aCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgbG9hZEZpbGUodGhpcy5pbml0LnR5cGUsIHRoaXMuaW5pdC5uYW1lLCB0aGlzLmluaXQudmVyc2lvbiwgcGF0aCk7XG4gICAgfVxuICAgIHB1c2hTdGF0ZShuZXdTdGF0ZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtb2R1bGVzID0gb3B0aW9ucz8uZmlsdGVyID8gdGhpcy5maWx0ZXJNb2R1bGVzKG9wdGlvbnM/LmZpbHRlciB8fCB7fSkgOiB0aGlzLmdldEFsbE1vZHVsZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgICAgICAgbW9kdWxlLnB1c2hTdGF0ZShuZXdTdGF0ZSwgeyBtZXJnZTogIW9wdGlvbnM/Lm92ZXJ3cml0ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjb25zdCBhbGwgPSB0aGlzLmdldEFsbE1vZHVsZXMoKTtcbiAgICAgICAgYWxsLmZvckVhY2gobW9kdWxlID0+IG1vZHVsZS5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2xlYXJMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJkZXN0cm95XCIsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRzSGFuZGxlciB9IGZyb20gXCIuL0V2ZW50c0hhbmRsZXIuanNcIjtcbmltcG9ydCB7IHJhbmRvbUlkLCByZWNlaXZlRGF0YSB9IGZyb20gXCIuL3NoYXJlZC5qc1wiO1xuLyoqIFJlcHJlc2VudHMgYW4gaWZyYW1lIG9yIGEgd29ya2VyICovXG5leHBvcnQgY2xhc3MgTW9kdWxlIGV4dGVuZHMgRXZlbnRzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoZXh0ZW5zaW9uLCBpbml0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuICAgICAgICB0aGlzLmluaXQgPSBpbml0O1xuICAgICAgICB0aGlzLmlkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9ncyA9ICEhdGhpcy5leHRlbnNpb24ucHJvdmlkZXIub3B0aW9ucz8ubG9ncztcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIEluIENPUlMgY29udGV4dCB0YXJnZXQgaXMgV2luZG93IChpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgIC8vIFdlIGNhbnQgZGVmaW5lIHRhcmdldC5vbm1lc3NhZ2Ugb3IgdGFyZ2V0Lm9uZXJyb3Igb24gYSBjcm9zcyBvcmlnaW4gV2luZG93XG4gICAgICAgICAgICAvLyBUaGF0cyB3aHkgd2UgbGlzdGVuIHRvIHRoZSBtZXNzYWdlIGV2ZW50IG9uIHRoZSBnbG9iYWwgb2JqZWN0IGFuZCBjaGVjayB0aGUgc291cmNlXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzTGlzdGVuZXIgPSBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG9yaWdpbiA9IFwiXCIgLT4gc2FtZSBvcmlnaW5cbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW4gIT09IFwiXCIgJiYgZS5vcmlnaW4gIT09IHRoaXMuaW5pdC5vcmlnaW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhPy5fX3Rva2VuICE9PSB0aGlzLm1ldGEuYXV0aFRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlPy5kYXRhPy5fX3R5cGUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gZS5kYXRhLl9fdHlwZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInN0YXRlX3BvcHVsYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0LmFsbG93UG9wdWxhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlID0gISFlLmRhdGEub3B0aW9ucz8ubWVyZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZCA9IHRoaXMuaW5pdC5hbGxvd1BvcHVsYXRlU3RhdGUgPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0LmFsbG93UG9wdWxhdGVTdGF0ZShlLmRhdGEuc3RhdGUsIG1lcmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdC5tZXJnZVN0YXRlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5pbml0Lm1lcmdlU3RhdGVzKHRoaXMuc3RhdGUsIGUuZGF0YS5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0geyAuLi50aGlzLnN0YXRlLCAuLi5lLmRhdGEuc3RhdGUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IGUuZGF0YS5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJzdGF0ZV9wb3B1bGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGUuZGF0YS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm9wZXJhdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhcmdzLCBvcGVyYXRpb24sIF9fcG9ydDogcG9ydCB9ID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb3J0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycihcIk9wZXJhdGlvbiBDaGFubmVsIEVycm9yXCIsIFwiUG9ydCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3AgPSBhd2FpdCB0aGlzLmluaXQub3V0Py5bb3BlcmF0aW9uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3AgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0Lm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnIoXCJPcGVyYXRpb24gQ2hhbm5lbCBFcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGU6IFwib3BlcmF0aW9uOnJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoYG9wOiR7b3BlcmF0aW9ufWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZSA9IHRoaXMuZXJyKFwiT3BlcmF0aW9uIEV4ZWN1dGlvbiBFcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChgb3A6JHtvcGVyYXRpb259YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoYG9wOiR7b3BlcmF0aW9ufWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFkeVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJsb2FkXCIsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICB3b3JrZXIgbWVzc2FnZXMgYXJlIG9ubHkgcmVjZWl2ZWQgdmlhIFdvcmtlci5vbm1lc3NhZ2UsXG4gICAgICAgICAgICAgd2hlcmVhcyBpZnJhbWUgbWVzc2FnZXMgYXJlIHJlY2VpdmVkIHZpYSB3aW5kb3cub25tZXNzYWdlIG9yIGlmcmFtZS5jb250ZW50V2luZG93Lm9ubWVzc2FnZS5cbiAgICAgICAgICAgICBTbyB3ZSBuZWVkIHRvIGhhbmRsZSB3b3JrZXJzIGFuZCBpZnJhbWVzIGRpZmZlcmVudGx5XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gV29ya2VyXG4gICAgICAgICAgICBpZiAodGhpcy5pbml0LnRhcmdldCBpbnN0YW5jZW9mIFdvcmtlcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvZ3MpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTGlzdGVuaW5nIG9uIHdvcmtlciBmb3IgbWVzc2FnZXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0LnRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtZXNzYWdlc0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElGcmFtZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9ncylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMaXN0ZW5pbmcgb24gd2luZG93IGZvciBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbWVzc2FnZXNMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb3N0IG1ldGE6XG4gICAgICAgICAgICAvLyAtIFdvcmtlcnMgbmVlZCB0aGlzIHRvIGltcG9ydCB0aGUgbW9kdWxlIGluIHRoZSB3b3JrZXIgaW5pdGlhbGl6YXRpb24sIHdob2ljaCBkeW5hbWljYWxseSBpbXBvcnRzIHRoZSBtb2R1bGVcbiAgICAgICAgICAgIC8vIC0gSWZyYW1lcyBuZWVkIHRoaXMgdG8gaW5pdCB0aGVpciBtZXRhXG4gICAgICAgICAgICB0aGlzLmluaXQudGFyZ2V0LnBvc3RNZXNzYWdlKHsgX190eXBlOiBcIm1ldGFcIiwgbWV0YTogdGhpcy5pbml0Lm1ldGEgfSwgeyB0YXJnZXRPcmlnaW46IHRoaXMuaW5pdC5vcmlnaW4gfSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgICAgICByZWplY3QodGhpcy5lcnIoXCJDb25uZWN0aW9uIHRpbWVvdXRcIiwgbnVsbCkpO1xuICAgICAgICAgICAgfSwgdGhpcy5pbml0LmNvbm5lY3Rpb25UaW1lb3V0IHx8IDUwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIGdldCBtZXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0Lm1ldGE7XG4gICAgfVxuICAgIGVycihpbmZvLCBldmVudCkge1xuICAgICAgICBjb25zdCBtc2cgPSBldmVudCBpbnN0YW5jZW9mIEV2ZW50XG4gICAgICAgICAgICA/IChldmVudC5tZXNzYWdlIHx8IGV2ZW50LmRhdGEgfHwgXCJcIikudG9TdHJpbmcoKVxuICAgICAgICAgICAgOiBldmVudCBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgPyBldmVudC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYCR7aW5mb30ke21zZyA/IFwiOiBcIiArIG1zZyA6IFwiXCJ9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoaW5mbywgZXJyKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgcG9zdE1lc3NhZ2UodHlwZSwgZGF0YSwgdHJhbnNmZXIpIHtcbiAgICAgICAgdGhpcy5pbml0LnRhcmdldC5wb3N0TWVzc2FnZSh7IC4uLmRhdGEsIF9fdHlwZTogdHlwZSB9LCB7IHRyYW5zZmVyLCB0YXJnZXRPcmlnaW46IHRoaXMuaW5pdC5vcmlnaW4gfSk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGUob3BlcmF0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZWNlaXZlRGF0YSh0aGlzLmluaXQudGFyZ2V0LCBcIm9wZXJhdGlvblwiLCB7IGFyZ3MsIG9wZXJhdGlvbiB9LCB0aGlzLmluaXQub3JpZ2luLCBbXSwgdGhpcy5pbml0Lm9wZXJhdGlvblRpbWVvdXQpO1xuICAgIH1cbiAgICBhc3luYyBwdXNoU3RhdGUobmV3U3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHM7XG4gICAgICAgIGlmIChvcHRpb25zPy5tZXJnZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdC5tZXJnZVN0YXRlcykge1xuICAgICAgICAgICAgICAgIHMgPSB0aGlzLmluaXQubWVyZ2VTdGF0ZXModGhpcy5zdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHsgLi4udGhpcy5zdGF0ZSwgLi4ubmV3U3RhdGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMucG9zdE1lc3NhZ2UoXCJzdGF0ZV9wdXNoXCIsIHtcbiAgICAgICAgICAgIHN0YXRlOiBzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXQudGFyZ2V0IGluc3RhbmNlb2YgV29ya2VyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdC50YXJnZXQudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7IH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiZGVzdHJveVwiLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50c0hhbmRsZXIgfSBmcm9tIFwiLi9FdmVudHNIYW5kbGVyLmpzXCI7XG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tIFwiLi9FeHRlbnNpb24uanNcIjtcbmV4cG9ydCBjbGFzcyBQcm92aWRlciBleHRlbmRzIEV2ZW50c0hhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZEV4dGVuc2lvbihleHRlbnNpb25Jbml0KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBFeHRlbnNpb24odGhpcywgZXh0ZW5zaW9uSW5pdCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBleHRlbnNpb24uc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGV4dGVuc2lvbjogJHtlcnI/LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGFnYXRlIGV2ZW50c1xuICAgICAgICBleHRlbnNpb24uYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlX3BvcHVsYXRlXCIsIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJzdGF0ZV9wb3B1bGF0ZVwiLCB7IGV4dGVuc2lvbiwgbW9kdWxlOiBlLnBheWxvYWQubW9kdWxlLCBzdGF0ZTogZS5wYXlsb2FkLnN0YXRlLCBvcHRpb25zOiBlLnBheWxvYWQubW9kdWxlIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXh0ZW5zaW9uLmFkZEV2ZW50TGlzdGVuZXIobnVsbCwgZXYgPT4ge1xuICAgICAgICAgICAgaWYgKGV2LnR5cGUuc3RhcnRzV2l0aChcIm9wOlwiKSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChldi50eXBlLCBldi5wYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4dGVuc2lvbi5hZGRFdmVudExpc3RlbmVyKFwiZGVzdHJveVwiLCBlID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGV4dGVuc2lvbi5pZCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcImV4dGVuc2lvbl9kZXN0cm95XCIsIGV4dGVuc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXRFdmVudChcImV4dGVuc2lvbl9sb2FkXCIsIGV4dGVuc2lvbik7XG4gICAgICAgIC8vIGNhY2hlXG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGV4dGVuc2lvbi5pZCwgZXh0ZW5zaW9uKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG4gICAgYWxsRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jYWNoZS52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGdldEV4dGVuc2lvbihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoaWQpIHx8IG51bGw7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBBcnJheS5mcm9tKHRoaXMuY2FjaGUudmFsdWVzKCkpO1xuICAgICAgICBleHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgfVxufVxuIiwiZXhwb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSBcIi4vRXh0ZW5zaW9uLmpzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCIuL1Byb3ZpZGVyLmpzXCI7XG5leHBvcnQgeyBFdmVudCB9IGZyb20gXCIuL0V2ZW50c0hhbmRsZXIuanNcIjtcbmV4cG9ydCBkZWZhdWx0IFByb3ZpZGVyO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHJlbFBhdGgocGF0aCkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSlcbiAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMik7XG4gICAgZWxzZSBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZURhdGEoZSwgdHlwZSkge1xuICAgIGlmIChlLmRhdGEgJiYgdHlwZW9mIGUuZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBlLmRhdGEuX190eXBlID09PSB0eXBlKVxuICAgICAgICByZXR1cm4gZS5kYXRhO1xuICAgIHJldHVybiBudWxsO1xufVxuLyoqIDI1IGNoYXIgbG9uZyBwc2V1ZG8gY3J5cHRpYyBpZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUlkKCkge1xuICAgIGNvbnN0IGNoYXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgICBsZXQgdW5pcXVlSWQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xuICAgICAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCk7XG4gICAgICAgIHVuaXF1ZUlkICs9IGNoYXJzW3JhbmRvbUluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZUlkO1xufVxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ID09PSB3aW5kb3cuc2VsZjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWNlaXZlRGF0YSh0YXJnZXQsIHR5cGUsIGRhdGEsIG9yaWdpbiA9IFwiKlwiLCB0cmFuc2ZlciwgZXJyVGltZW91dCA9IDUwMDApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNvbnN0IG91dCA9IGNoYW5uZWwucG9ydDE7XG4gICAgICAgIGNvbnN0IF9pbiA9IGNoYW5uZWwucG9ydDI7XG4gICAgICAgIGxldCByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIk9wZXJhdGlvbiB0aW1lb3V0XCIpKTtcbiAgICAgICAgfSwgZXJyVGltZW91dCB8fCA1MDAwKTtcbiAgICAgICAgb3V0Lm9ubWVzc2FnZSA9IGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZ2V0TWVzc2FnZURhdGEoZSwgdHlwZSArIFwiOnJlc3VsdFwiKTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX2luLm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ2hhbm5lbCBFcnJvciAoaW4pXCIpKTtcbiAgICAgICAgfTtcbiAgICAgICAgb3V0Lm9ubWVzc2FnZWVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ2hhbm5lbCBFcnJvciAob3V0KVwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5wb3N0TWVzc2FnZSh7IC4uLmRhdGEsIF9fdHlwZTogdHlwZSwgX19wb3J0OiBfaW4gfSwgeyB0YXJnZXRPcmlnaW46IG9yaWdpbiwgdHJhbnNmZXI6IFtfaW4sIC4uLih0cmFuc2ZlciB8fCBbXSldIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IGpzZGVsaXZyID0gXCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXRcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwodHlwZSwgbmFtZSwgdmVyc2lvbiwgcGF0aCkge1xuICAgIGxldCBiYXNlVXJsO1xuICAgIGlmICh0eXBlID09PSBcImdpdGh1YlwiKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcmVwb10gPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgYmFzZVVybCA9IGAke2pzZGVsaXZyfS9naC8ke293bmVyfS8ke3JlcG99QCR7dmVyc2lvbn0vYDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJucG1cIikge1xuICAgICAgICBiYXNlVXJsID0gYCR7anNkZWxpdnJ9L25wbS8ke25hbWV9QCR7dmVyc2lvbn0vYDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHR5cGUgKCducG0nIG9yICdnaXRodWInIGV4cGVjdGVkKVwiKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgICBwYXRoID0gcmVsUGF0aChwYXRoKTtcbiAgICAgICAgcmV0dXJuIGJhc2VVcmwgKyBwYXRoO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBiYXNlVXJsO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRGaWxlKHR5cGUsIG5hbWUsIHZlcnNpb24sIHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSlcbiAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gICAgZWxzZSBpZiAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikpXG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZ2V0VXJsKHR5cGUsIG5hbWUsIHZlcnNpb24sIHBhdGgpLCB0eXBlID09PSBcImdpdGh1YlwiID8ge30gOiB7fSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgZmlsZTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIGZpbGU6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgUHJvdmlkZXIgZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5jb25zdCBjb21taXRTaGEgPSBcImRhNjQxNzhhYTI4YjY2ZGIwMmNhMmM3YmNlM2QzZTRhMzVkMDJhZDZcIjtcbm1haW4oKS5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihlcnIpKTtcbmNvbnN0IHByb3ZpZGVyQXBpID0ge1xuICAgIGVjaG86IHRleHQgPT4ge1xuICAgICAgICB0ZXh0ID0gdGV4dCB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gdGV4dCArIFwiICBcIiArIHRleHQgKyBcIiAgXCIgKyB0ZXh0O1xuICAgIH0sXG4gICAgYWxlcnQ6IG1lc3NhZ2UgPT4ge1xuICAgICAgICBhbGVydChtZXNzYWdlIHx8IFwiPGVtcHR5PlwiKTtcbiAgICB9LFxuICAgIHByaW50OiAoLi4udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByaW50XCIpO1xuICAgICAgICBpZiAoY29udGFpbmVyKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQcmludDpcIiwgKHRleHQgfHwgW1wiPGVtcHR5PlwiXSkuam9pbihcIiBcIikpO1xuICAgIH0sXG4gICAgZ3JlZXQ6IChuYW1lLCBhZ2UpID0+IHtcbiAgICAgICAgYWxlcnQoXCJIZWxsbyBcIiArIG5hbWUgKyBcIiBBR0UgXCIgKyBhZ2UpO1xuICAgIH0sXG59O1xuYXN5bmMgZnVuY3Rpb24gbGF1bmNoSUZyYW1lcyhleHRlbnNpb24pIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImlmcmFtZVwiKTtcbiAgICBjb25zdCBjb250YWluZXIyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpZnJhbWUyXCIpO1xuICAgIGNvbnN0IHJlc2V0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXNldFwiKTtcbiAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lcjIgJiYgcmVzZXRCdG4pIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50TW9kdWxlID0gYXdhaXQgZXh0ZW5zaW9uLmxhdW5jaENvbXBvbmVudChjb250YWluZXIsIFwiZGlzdC9mcmFtZXMvY291bnRlci9jb3VudGVyLmh0bWxcIiwgcHJvdmlkZXJBcGksIHsgYWxsb3dQb3B1bGF0ZVN0YXRlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBjb21wb25lbnRNb2R1bGUyID0gYXdhaXQgZXh0ZW5zaW9uLmxhdW5jaENvbXBvbmVudChjb250YWluZXIyLCBcImRpc3QvZnJhbWVzL2NvdW50ZXIvY291bnRlci5odG1sXCIsIHByb3ZpZGVyQXBpLCB7IGFsbG93UG9wdWxhdGVTdGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Q291bnRlciA9IGF3YWl0IGNvbXBvbmVudE1vZHVsZS5leGVjdXRlKFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgYXdhaXQgY29tcG9uZW50TW9kdWxlMi5leGVjdXRlKFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYE5ldyBjb3VudGVyIDwke25ld0NvdW50ZXJ9PiByZXR1cm5lZCBieSAnaW5jcmVtZW50JyBleGVjdXRlIChTaG91bGQgYWxzbyBiZSBkaXNwbGF5ZWQgaW4gdGhlIGlmcmFtZSlgKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIHJlc2V0QnRuLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb21wb25lbnRNb2R1bGUuZXhlY3V0ZShcInJlc2V0XCIpO1xuICAgICAgICAgICAgY29tcG9uZW50TW9kdWxlLmV4ZWN1dGUoXCJwcmludFwiLCBcIlJlc2V0dGVkXCIsIFwiZnJvbVwiLCBcIm1haW4gd2luZG93XCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxhdW5jaE1vZHVsZShleHRlbnNpb24pIHtcbiAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBleHRlbnNpb24ubGF1bmNoTW9kdWxlKFwiZGlzdC9tYXRoLmpzXCIsIHByb3ZpZGVyQXBpKTtcbiAgICBjb25zb2xlLmxvZyhcIk1vZHVsZSBsb2FkZWQ6XCIsIGV4dGVuc2lvbik7XG4gICAgY29uc3Qgb3BlcmF0aW9uQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGVyYXRpb25cIik7XG4gICAgaWYgKG9wZXJhdGlvbkJ0bikge1xuICAgICAgICBvcGVyYXRpb25CdG4ub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghbW9kdWxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhbGVydChcIk1vZHVsZSBub3QgbG9hZGVkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gYXdhaXQgbW9kdWxlLmV4ZWN1dGUoXCJhZGRcIiwgMSwgNSk7XG4gICAgICAgICAgICBjb25zdCBkID0gYXdhaXQgbW9kdWxlLmV4ZWN1dGUoXCJzdWJzdHJhY3RcIiwgMTAsIDIpO1xuICAgICAgICAgICAgYWxlcnQoXCJTdW06IFwiICsgc3VtICsgXCIgU3ViOiBcIiArIGQpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTWVzc2FnZSByZWNlaXZlZCA6OlwiLCBlLmRhdGEpO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb3YgPSBuZXcgUHJvdmlkZXIoeyBsb2dzOiB0cnVlIH0pO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGF3YWl0IHByb3YubG9hZEV4dGVuc2lvbih7XG4gICAgICAgIHR5cGU6IFwiZ2l0aHViXCIsXG4gICAgICAgIG5hbWU6IFwiYW5kcmUtaGN0dWxjL2V4dGVuc2lvbnJ1bm5lci10ZXN0LWV4dGVuc2lvblwiLFxuICAgICAgICB2ZXJzaW9uOiBjb21taXRTaGEsXG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coXCJFeHRlbnNpb24gbG9hZGVkOlwiLCBleHRlbnNpb24pO1xuICAgIGNvbnN0IGluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9cIik7XG4gICAgaWYgKGluZm8pXG4gICAgICAgIGluZm8uaW5uZXJIVE1MID0gYCR7ZXh0ZW5zaW9uLnBrZy5uYW1lfUAke2V4dGVuc2lvbi5wa2cudmVyc2lvbn0gU0hBICR7Y29tbWl0U2hhfWA7XG4gICAgbGF1bmNoTW9kdWxlKGV4dGVuc2lvbikuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsYXVuY2hpbmcgbW9kdWxlXCIsIGVycikpO1xuICAgIGxhdW5jaElGcmFtZXMoZXh0ZW5zaW9uKS5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihcIkVycm9yIGxhdW5jaGluZyBpZnJhbWVcIiwgZXJyKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=</script>
    </head>
    <body>
        <h1>Test</h1>
        <span>Test-Extension:</span>
        <p id="info"></p>
        <h2>Module (dist/math.js)</h2>
        <button id="operation">Operation (add and substract)</button>
        <h2>IFrame (dist/frames/counter/index.html)</h2>
        <button id="increment">Counter increment</button>
        <div style="display: flex; gap: 10px;">
            <div id="iframe" style="height: 500px width: 500px;;"></div>
            <div id="iframe2" style="height: 500px width: 500px;;"></div>
        </div>

        <button id="reset">Reset counter (frame1)</button>
    </body>
</html>
